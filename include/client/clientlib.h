#ifndef CHEERP_CLIENTLIB_H
#define CHEERP_CLIENTLIB_H
#include "types.h"
#include "function.h"
#include "jshelper.h"
namespace [[cheerp::genericjs]] client {
	class ArrayConstructor: public Object {
	public:
		template<class _T0>
		TArray<_T0>* from(ArrayLike<_T0>* arrayLike);
		template<class _T0, class _T1>
		TArray<_T1>* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0, class _T1>
		TArray<_T1>* from(ArrayLike<_T0>* arrayLike, const _Function<_T1(_T0, double)>& mapfn);
		template<class _T0, class _T1>
		TArray<_T1>* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0, class _T1>
		TArray<_T1>* from(ArrayLike<_T0>* arrayLike, const _Function<_T1(_T0, double)>& mapfn, const _Any& thisArg);
		template<class _T0>
		TArray<_T0>* from(Iterable<_T0>* iterable);
		template<class _T0>
		TArray<_T0>* from(const _Union<Iterable<_T0>*, ArrayLike<_T0>*>& iterable);
		template<class _T0, class _T1>
		TArray<_T1>* from(Iterable<_T0>* iterable, EventListener* mapfn);
		template<class _T0, class _T1>
		TArray<_T1>* from(const _Union<Iterable<_T0>*, ArrayLike<_T0>*>& iterable, EventListener* mapfn);
		template<class _T0, class _T1>
		TArray<_T1>* from(Iterable<_T0>* iterable, const _Function<_T1(_T0, double)>& mapfn);
		template<class _T0, class _T1>
		TArray<_T1>* from(const _Union<Iterable<_T0>*, ArrayLike<_T0>*>& iterable, const _Function<_T1(_T0, double)>& mapfn);
		template<class _T0, class _T1>
		TArray<_T1>* from(Iterable<_T0>* iterable, EventListener* mapfn, const _Any& thisArg);
		template<class _T0, class _T1>
		TArray<_T1>* from(const _Union<Iterable<_T0>*, ArrayLike<_T0>*>& iterable, EventListener* mapfn, const _Any& thisArg);
		template<class _T0, class _T1>
		TArray<_T1>* from(Iterable<_T0>* iterable, const _Function<_T1(_T0, double)>& mapfn, const _Any& thisArg);
		template<class _T0, class _T1>
		TArray<_T1>* from(const _Union<Iterable<_T0>*, ArrayLike<_T0>*>& iterable, const _Function<_T1(_T0, double)>& mapfn, const _Any& thisArg);
		template<class _T0, class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, _T0> && ...), TArray<_T0>*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::TArray<_T0>*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	public:
		[[cheerp::interface_name(("get_[Symbol.species]"))]]
		_Union<_Function<TArray<_Any*>*(double)>*, _Function<TArray<_Any*>*(TArray<_Any*>*)>*>* get__91_Symbol_46_species_93_();
		bool isArray(const _Any& arg);
		TArray<_Any*>* get_prototype();
	};
	class Date;
	class DateConstructor: public Object {
	public:
		double UTC(double year);
		double UTC(double year, double monthIndex);
		double UTC(double year, double monthIndex, double date);
		double UTC(double year, double monthIndex, double date, double hours);
		double UTC(double year, double monthIndex, double date, double hours, double minutes);
		double UTC(double year, double monthIndex, double date, double hours, double minutes, double seconds);
		double UTC(double year, double monthIndex, double date, double hours, double minutes, double seconds, double ms);
		Date* get_prototype();
		double parse(const String& s);
		double now();
	};
	class MathClass;
	extern MathClass Math;
	class MathClass: public Object {
	public:
		double clz32(double x);
		double imul(double x, double y);
		double sign(double x);
		double log10(double x);
		double log2(double x);
		double log1p(double x);
		double expm1(double x);
		double cosh(double x);
		double sinh(double x);
		double tanh(double x);
		double acosh(double x);
		double asinh(double x);
		double atanh(double x);
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), double> hypot(_Args... values) {
			return _hypot(cheerp::clientCast(values)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("hypot"))]]
		_Any* _hypot(_Args... data);
	public:
		double trunc(double x);
		double fround(double x);
		double cbrt(double x);
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		double get_E();
		double get_LN10();
		double get_LN2();
		double get_LOG2E();
		double get_LOG10E();
		double get_PI();
		double get_SQRT1_2();
		double get_SQRT2();
		double abs(double x);
		double acos(double x);
		double asin(double x);
		double atan(double x);
		double atan2(double y, double x);
		double ceil(double x);
		double cos(double x);
		double exp(double x);
		double floor(double x);
		double log(double x);
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), double> max(_Args... values) {
			return _max(cheerp::clientCast(values)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("max"))]]
		_Any* _max(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), double> min(_Args... values) {
			return _min(cheerp::clientCast(values)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("min"))]]
		_Any* _min(_Args... data);
	public:
		double pow(double x, double y);
		double random();
		double round(double x);
		double sin(double x);
		double sqrt(double x);
		double tan(double x);
	};
	class NumberConstructor: public Object {
	public:
		double get_EPSILON();
		bool isFinite(Object* number);
		bool isInteger(Object* number);
		bool isNaN(Object* number);
		bool isSafeInteger(Object* number);
		double get_MAX_SAFE_INTEGER();
		double get_MIN_SAFE_INTEGER();
		double parseFloat(const String& string);
		double parseInt(const String& string);
		double parseInt(const String& string, double radix);
		Number* get_prototype();
		double get_MAX_VALUE();
		double get_MIN_VALUE();
		double get_NaN();
		double get_NEGATIVE_INFINITY();
		double get_POSITIVE_INFINITY();
	};
	class ObjectConstructor: public Object {
	public:
		template<class _T0, class _T1>
		cheerp::EnableIf<cheerp::CanCast<_T0, Object*>, _T0> assign(_T0 target, _T1 source);
		template<class _T0, class _T1, class _T2>
		cheerp::EnableIf<cheerp::CanCast<_T0, Object*>, _T0> assign(_T0 target, _T1 source1, _T2 source2);
		template<class _T0, class _T1, class _T2, class _T3>
		cheerp::EnableIf<cheerp::CanCast<_T0, Object*>, _T0> assign(_T0 target, _T1 source1, _T2 source2, _T3 source3);
		template<class... _Args>
		[[gnu::always_inline]]
		Object* assign(Object* target, _Args... sources) {
			return _assign(cheerp::clientCast(target), cheerp::clientCast(sources)...)->template cast<Object*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("assign"))]]
		_Any* _assign(_Args... data);
	public:
		TArray<Symbol*>* getOwnPropertySymbols(const _Any& o);
		TArray<String*>* keys(Object* o);
		bool is(const _Any& value1, const _Any& value2);
		Object* setPrototypeOf(const _Any& o, Object* proto);
		template<class _T0>
		TArray<_T0>* values(ArrayLike<_T0>* o);
		template<class _T0>
		TArray<_T0>* values(const _Union<Object*, ArrayLike<_T0>*>& o);
		TArray<_Any*>* values(Object* o);
		template<class _T0>
		TArray<Object*>* entries(ArrayLike<_T0>* o);
		template<class _T0>
		TArray<Object*>* entries(const _Union<Object*, ArrayLike<_T0>*>& o);
		TArray<Object*>* entries(Object* o);
		Object* getOwnPropertyDescriptors(const _Any& o);
		Object* fromEntries(Iterable<Object*>* entries);
		Object* fromEntries(Iterable<ReadonlyArray<_Any*>*>* entries);
		Object* get_prototype();
		Object* getPrototypeOf(const _Any& o);
		PropertyDescriptor* getOwnPropertyDescriptor(const _Any& o, const String& p);
		PropertyDescriptor* getOwnPropertyDescriptor(const _Any& o, const _Union<double, Symbol*>& p);
		TArray<String*>* getOwnPropertyNames(const _Any& o);
		Object* create(Object* o);
		Object* create(Object* o, PropertyDescriptorMap* properties);
		template<class _T0>
		_T0 defineProperty(_T0 o, const String& p, PropertyDescriptor* attributes);
		template<class _T0>
		_T0 defineProperty(_T0 o, const _Union<double, Symbol*>& p, PropertyDescriptor* attributes);
		template<class _T0>
		_T0 defineProperties(_T0 o, PropertyDescriptorMap* properties);
		template<class _T0>
		_T0 seal(_T0 o);
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Function*>, _T0> freeze(_T0 f);
		Object* freeze(Object* o);
		Object* freeze(const _Any& o);
		template<class _T0>
		_T0 preventExtensions(_T0 o);
		bool isSealed(const _Any& o);
		bool isFrozen(const _Any& o);
		bool isExtensible(const _Any& o);
	};
	template<class _T0>
	class ReadonlyArray: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_T0 find(EventListener* predicate);
		_T0 find(const _Function<_Union<bool, Object*>*(_T0, double, ReadonlyArray<_T0>*)>& predicate);
		_T0 find(EventListener* predicate, const _Any& thisArg);
		_T0 find(const _Function<_Union<bool, Object*>*(_T0, double, ReadonlyArray<_T0>*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<Object*(_T0, double, ReadonlyArray<_T0>*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<Object*(_T0, double, ReadonlyArray<_T0>*)>& predicate, const _Any& thisArg);
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<_T0>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<_T0>* values();
		[[cheerp::interface_name(("get_[Symbol.unscopables]"))]]
		Object* get__91_Symbol_46_unscopables_93_();
		bool includes(_T0 searchElement);
		bool includes(_T0 searchElement, double fromIndex);
		template<class _T1>
		TArray<_T1>* flatMap(EventListener* callback);
		template<class _T1>
		TArray<_T1>* flatMap(const _Function<_Union<_T1, ReadonlyArray<_T1>*>*(_T0, double, TArray<_T0>*)>& callback);
		template<class _T1, class _T2 = _Any*>
		TArray<_T1>* flatMap(EventListener* callback, _T2 thisArg);
		template<class _T1, class _T2 = _Any*>
		TArray<_T1>* flatMap(const _Function<_Union<_T1, ReadonlyArray<_T1>*>*(_T0, double, TArray<_T0>*)>& callback, _T2 thisArg);
		TArray<Object*>* flat();
		TArray<Object*>* flat(double depth);
		int get_length() const;
		String* toString();
		String* toLocaleString();
		template<class... _Args>
		[[gnu::always_inline]]
		_Union<cheerp::EnableIf<(cheerp::CanCastArgs<_Args, ConcatArray<_T0>*> && ...), TArray<_T0>*>, TArray<_T0>*>* concat(_Args... items) const {
			return _concat(cheerp::clientCast(items)...)->template cast<client::TArray<_T0>*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("concat"))]]
		_Any* _concat(_Args... data) const;
	public:
		String* join();
		String* join(const String& separator);
		TArray<_T0>* slice();
		TArray<_T0>* slice(double start);
		TArray<_T0>* slice(double start, double end);
		int indexOf(_T0 searchElement) const;
		int indexOf(_T0 searchElement, double fromIndex) const;
		int lastIndexOf(_T0 searchElement) const;
		int lastIndexOf(_T0 searchElement, double fromIndex) const;
		bool every(EventListener* predicate);
		bool every(const _Function<_Union<bool, Object*>*(_T0, double, ReadonlyArray<_T0>*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<_Union<bool, Object*>*(_T0, double, ReadonlyArray<_T0>*)>& predicate, const _Any& thisArg);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(_T0, double, ReadonlyArray<_T0>*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(_T0, double, ReadonlyArray<_T0>*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(_T0, double, ReadonlyArray<_T0>*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(_T0, double, ReadonlyArray<_T0>*)>& callbackfn, const _Any& thisArg);
		template<class _T1>
		TArray<_T1>* map(EventListener* callbackfn);
		template<class _T1>
		TArray<_T1>* map(const _Function<_T1(_T0, double, ReadonlyArray<_T0>*)>& callbackfn);
		template<class _T1>
		TArray<_T1>* map(EventListener* callbackfn, const _Any& thisArg);
		template<class _T1>
		TArray<_T1>* map(const _Function<_T1(_T0, double, ReadonlyArray<_T0>*)>& callbackfn, const _Any& thisArg);
		TArray<_T0>* filter(EventListener* predicate);
		TArray<_T0>* filter(const _Function<_Union<bool, Object*>*(_T0, double, ReadonlyArray<_T0>*)>& predicate);
		TArray<_T0>* filter(EventListener* predicate, const _Any& thisArg);
		TArray<_T0>* filter(const _Function<_Union<bool, Object*>*(_T0, double, ReadonlyArray<_T0>*)>& predicate, const _Any& thisArg);
		_T0 reduce(EventListener* callbackfn);
		_T0 reduce(const _Function<_T0(_T0, _T0, double, ReadonlyArray<_T0>*)>& callbackfn);
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		_T0 reduce(const _Function<_T0(_T0, _T0, double, ReadonlyArray<_T0>*)>& callbackfn, _T0 initialValue);
		template<class _T1>
		_T1 reduce(EventListener* callbackfn, _T1 initialValue);
		template<class _T1>
		_T1 reduce(const _Function<_T1(_T1, _T0, double, ReadonlyArray<_T0>*)>& callbackfn, _T1 initialValue);
		_T0 reduceRight(EventListener* callbackfn);
		_T0 reduceRight(const _Function<_T0(_T0, _T0, double, ReadonlyArray<_T0>*)>& callbackfn);
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		_T0 reduceRight(const _Function<_T0(_T0, _T0, double, ReadonlyArray<_T0>*)>& callbackfn, _T0 initialValue);
		template<class _T1>
		_T1 reduceRight(EventListener* callbackfn, _T1 initialValue);
		template<class _T1>
		_T1 reduceRight(const _Function<_T1(_T1, _T0, double, ReadonlyArray<_T0>*)>& callbackfn, _T1 initialValue);
		_T0 operator[](double n) const;
#ifndef LEAN_CXX_LIB
		_T0& operator[](double n) {
			return __builtin_cheerp_make_regular<_T0>(this, 0)[static_cast<int>(n)];
		}
#endif
	public:
		using client::Object::operator[];
	};
	class RegExpExecArray;
	class RegExp: public Object {
	public:
		String* get_flags();
		bool get_sticky();
		bool get_unicode();
		[[cheerp::interface_name(("[Symbol.match]"))]]
		RegExpMatchArray* _91_Symbol_46_match_93_(const String& string);
		[[cheerp::interface_name(("[Symbol.replace]"))]]
		String* _91_Symbol_46_replace_93_(const String& string, const String& replaceValue);
		[[cheerp::interface_name(("[Symbol.replace]"))]]
		String* _91_Symbol_46_replace_93_(const String& string, EventListener* replacer);
		[[cheerp::interface_name(("[Symbol.replace]"))]]
		String* _91_Symbol_46_replace_93_(const String& string, const _Function<String*(String*, TArray<_Any*>*)>& replacer);
		[[cheerp::interface_name(("[Symbol.search]"))]]
		double _91_Symbol_46_search_93_(const String& string);
		[[cheerp::interface_name(("[Symbol.split]"))]]
		TArray<String*>* _91_Symbol_46_split_93_(const String& string);
		[[cheerp::interface_name(("[Symbol.split]"))]]
		TArray<String*>* _91_Symbol_46_split_93_(const String& string, double limit);
		bool get_dotAll();
		[[cheerp::interface_name(("[Symbol.matchAll]"))]]
		IterableIterator<RegExpMatchArray*>* _91_Symbol_46_matchAll_93_(const String& str);
		RegExpExecArray* exec(const String& string);
		bool test(const String& string);
		String* get_source();
		bool get_global();
		bool get_ignoreCase();
		bool get_multiline();
		double get_lastIndex();
		void set_lastIndex(double lastIndex);
		RegExp* compile(const String& pattern);
		RegExp* compile(const String& pattern, const String& flags);
		RegExp(const String& pattern);
		RegExp(RegExp* pattern);
		RegExp(const String& pattern, const String& flags);
		RegExp(RegExp* pattern, const String& flags);
		static _Any* _91_Symbol_46_species_93_;
		static RegExp* prototype;
		static String* _36_1;
		static String* _36_2;
		static String* _36_3;
		static String* _36_4;
		static String* _36_5;
		static String* _36_6;
		static String* _36_7;
		static String* _36_8;
		static String* _36_9;
		static String* input;
		static String* _36__;
		static String* lastMatch;
		static String* _34__36__38__34_;
		static String* lastParen;
		static String* _34__36__43__34_;
		static String* leftContext;
		static String* _34__36__96__34_;
		static String* rightContext;
		static String* _34__36__39__34_;
	};
	class RegExpConstructor: public Object {
	public:
		[[cheerp::interface_name(("get_[Symbol.species]"))]]
		_Union<_Function<RegExp*(_Union<String*, RegExp*>*, String*)>*, _Function<RegExp*(_Union<String*, RegExp*>*)>*, _Function<RegExp*(String*, String*)>*>* get__91_Symbol_46_species_93_();
		RegExp* get_prototype();
		[[cheerp::interface_name(("get_$1"))]]
		String* get__36_1();
		[[cheerp::interface_name(("set_$1"))]]
		void set__36_1(const String& _36_1);
		[[cheerp::interface_name(("get_$2"))]]
		String* get__36_2();
		[[cheerp::interface_name(("set_$2"))]]
		void set__36_2(const String& _36_2);
		[[cheerp::interface_name(("get_$3"))]]
		String* get__36_3();
		[[cheerp::interface_name(("set_$3"))]]
		void set__36_3(const String& _36_3);
		[[cheerp::interface_name(("get_$4"))]]
		String* get__36_4();
		[[cheerp::interface_name(("set_$4"))]]
		void set__36_4(const String& _36_4);
		[[cheerp::interface_name(("get_$5"))]]
		String* get__36_5();
		[[cheerp::interface_name(("set_$5"))]]
		void set__36_5(const String& _36_5);
		[[cheerp::interface_name(("get_$6"))]]
		String* get__36_6();
		[[cheerp::interface_name(("set_$6"))]]
		void set__36_6(const String& _36_6);
		[[cheerp::interface_name(("get_$7"))]]
		String* get__36_7();
		[[cheerp::interface_name(("set_$7"))]]
		void set__36_7(const String& _36_7);
		[[cheerp::interface_name(("get_$8"))]]
		String* get__36_8();
		[[cheerp::interface_name(("set_$8"))]]
		void set__36_8(const String& _36_8);
		[[cheerp::interface_name(("get_$9"))]]
		String* get__36_9();
		[[cheerp::interface_name(("set_$9"))]]
		void set__36_9(const String& _36_9);
		String* get_input();
		void set_input(const String& input);
		[[cheerp::interface_name(("get_$_"))]]
		String* get__36__();
		[[cheerp::interface_name(("set_$_"))]]
		void set__36__(const String& _36__);
		String* get_lastMatch();
		void set_lastMatch(const String& lastMatch);
		[[cheerp::interface_name(("get_\"$&\""))]]
		String* get__34__36__38__34_();
		[[cheerp::interface_name(("set_\"$&\""))]]
		void set__34__36__38__34_(const String& _34__36__38__34_);
		String* get_lastParen();
		void set_lastParen(const String& lastParen);
		[[cheerp::interface_name(("get_\"$+\""))]]
		String* get__34__36__43__34_();
		[[cheerp::interface_name(("set_\"$+\""))]]
		void set__34__36__43__34_(const String& _34__36__43__34_);
		String* get_leftContext();
		void set_leftContext(const String& leftContext);
		[[cheerp::interface_name(("get_\"$`\""))]]
		String* get__34__36__96__34_();
		[[cheerp::interface_name(("set_\"$`\""))]]
		void set__34__36__96__34_(const String& _34__36__96__34_);
		String* get_rightContext();
		void set_rightContext(const String& rightContext);
		[[cheerp::interface_name(("get_\"$'\""))]]
		String* get__34__36__39__34_();
		[[cheerp::interface_name(("set_\"$'\""))]]
		void set__34__36__39__34_(const String& _34__36__39__34_);
	};
	class StringConstructor: public Object {
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), String*> fromCodePoint(_Args... codePoints) {
			return _fromCodePoint(cheerp::clientCast(codePoints)...)->template cast<client::String*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("fromCodePoint"))]]
		_Any* _fromCodePoint(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		String* raw(Object* template_, _Args... substitutions) {
			return _raw(cheerp::clientCast(template_), cheerp::clientCast(substitutions)...)->template cast<client::String*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("raw"))]]
		_Any* _raw(_Args... data);
	public:
		String* get_prototype();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), String*> fromCharCode(_Args... codes) {
			return _fromCharCode(cheerp::clientCast(codes)...)->template cast<client::String*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("fromCharCode"))]]
		_Any* _fromCharCode(_Args... data);
	};
	class MapConstructor: public Object {
	public:
		Map<_Any*, _Any*>* get_prototype();
		[[cheerp::interface_name(("get_[Symbol.species]"))]]
		MapConstructor* get__91_Symbol_46_species_93_();
	};
	template<class _T0, class _T1>
	class ReadonlyMap: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(_T1, _T0, ReadonlyMap<_T0, _T1>*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(_T1, _T0, ReadonlyMap<_T0, _T1>*)>& callbackfn, const _Any& thisArg);
		_T1 get(_T0 key);
		bool has(_T0 key);
		int get_size() const;
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<Object*>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<_T0>* keys();
		IterableIterator<_T1>* values();
	};
	template<class _T0, class _T1>
	class WeakMap: public Object {
		static_assert(cheerp::CanCast<_T0, Object*>);
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		[[cheerp::interface_name(("delete"))]]
		bool delete_(_T0 key);
		_T1 get(_T0 key);
		bool has(_T0 key);
		WeakMap<_T0, _T1>* set(_T0 key, _T1 value);
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		WeakMap();
		WeakMap(ReadonlyArray<Object*>* entries);
		WeakMap(Iterable<Object*>* iterable);
		static WeakMap<Object*, _Any*>* prototype;
	};
	class WeakMapConstructor: public Object {
	public:
		WeakMap<Object*, _Any*>* get_prototype();
	};
	class SetConstructor;
	template<class _T0>
	class Set: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		Set<_T0>* add(_T0 value);
		void clear();
		[[cheerp::interface_name(("delete"))]]
		bool delete_(_T0 value);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(_T0, _T0, Set<_T0>*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(_T0, _T0, Set<_T0>*)>& callbackfn, const _Any& thisArg);
		bool has(_T0 value);
		int get_size() const;
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<_T0>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<_T0>* keys();
		IterableIterator<_T0>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		Set();
		template<class _T1 = _Any*>
		Set(ReadonlyArray<_T1>* values);
		template<class _T1>
		Set(Iterable<_T1>* iterable);
		static Set<_Any*>* prototype;
		static SetConstructor* _91_Symbol_46_species_93_;
	};
	class SetConstructor: public Object {
	public:
		Set<_Any*>* get_prototype();
		[[cheerp::interface_name(("get_[Symbol.species]"))]]
		SetConstructor* get__91_Symbol_46_species_93_();
	};
	template<class _T0>
	class ReadonlySet: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(_T0, _T0, ReadonlySet<_T0>*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(_T0, _T0, ReadonlySet<_T0>*)>& callbackfn, const _Any& thisArg);
		bool has(_T0 value);
		int get_size() const;
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<_T0>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<_T0>* keys();
		IterableIterator<_T0>* values();
	};
	template<class _T0>
	class WeakSet: public Object {
		static_assert(cheerp::CanCast<_T0, Object*>);
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		WeakSet<_T0>* add(_T0 value);
		[[cheerp::interface_name(("delete"))]]
		bool delete_(_T0 value);
		bool has(_T0 value);
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		WeakSet();
		template<class _T1 = Object*>
		WeakSet(ReadonlyArray<_T1>* values);
		template<class _T1 = Object*>
		WeakSet(Iterable<_T1>* iterable);
		static WeakSet<Object*>* prototype;
	};
	class WeakSetConstructor: public Object {
	public:
		WeakSet<Object*>* get_prototype();
	};
	template<class _T0>
	class IteratorYieldResult;
	template<class _T0>
	class IteratorReturnResult;
	template<class _T0, class _T1, class _T2>
	class Iterator: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1, _T2>);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>* next(_Args... args) {
			return _next(cheerp::clientCast(args)...)->template cast<_Union<client::IteratorYieldResult<_T0>*, client::IteratorReturnResult<_T1>*>*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("next"))]]
		_Any* _next(_Args... data);
	public:
		[[cheerp::interface_name(("return"))]]
		_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>* return_();
		[[cheerp::interface_name(("return"))]]
		_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>* return_(_T1 value);
		[[cheerp::interface_name(("throw"))]]
		_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>* throw_();
		[[cheerp::interface_name(("throw"))]]
		_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>* throw_(const _Any& e);
	};
	template<class _T0, class _T1, class _T2>
	class Generator: public Iterator<_T0, _T1, _T2> {
		static_assert(cheerp::CheckTemplate<_T0, _T1, _T2>);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>* next(_Args... args) {
			return _next(cheerp::clientCast(args)...)->template cast<_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("next"))]]
		_Any* _next(_Args... data);
	public:
		[[cheerp::interface_name(("return"))]]
		_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>* return_(_T1 value);
		[[cheerp::interface_name(("throw"))]]
		_Union<IteratorYieldResult<_T0>*, IteratorReturnResult<_T1>*>* throw_(const _Any& e);
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		Generator<_T0, _T1, _T2>* _91_Symbol_46_iterator_93_();
	};
	class GeneratorFunction: public Object {
	public:
		int get_length() const;
		String* get_name();
		Generator<Object*, _Any*, Object*>* get_prototype();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
	};
	class GeneratorFunctionConstructor: public Object {
	public:
		int get_length() const;
		String* get_name();
		_Function<Generator<Object*, _Any*, Object*>*(TArray<_Any*>*)>* get_prototype();
	};
	class SymbolConstructor: public Object {
	public:
		Symbol* get_iterator();
		Symbol* get_prototype();
		[[cheerp::interface_name(("for"))]]
		Symbol* for_(const String& key);
		String* keyFor(Symbol* sym);
		Symbol* get_hasInstance();
		Symbol* get_isConcatSpreadable();
		Symbol* get_match();
		Symbol* get_replace();
		Symbol* get_search();
		Symbol* get_species();
		Symbol* get_split();
		Symbol* get_toPrimitive();
		Symbol* get_toStringTag();
		Symbol* get_unscopables();
		Symbol* get_asyncIterator();
		Symbol* get_matchAll();
	};
	template<class _T0>
	class IteratorYieldResult: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool get_done();
		void set_done(bool done);
		_T0 get_value();
		void set_value(_T0 value);
	};
	template<class _T0>
	class IteratorReturnResult: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool get_done();
		void set_done(bool done);
		_T0 get_value();
		void set_value(_T0 value);
	};
	using IteratorResult = _Any;
	template<class _T0>
	class Iterable: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		Iterator<_T0, _Any*, _Any*>* _91_Symbol_46_iterator_93_();
	};
	template<class _T0>
	class IterableIterator: public Iterator<_T0, _Any*, _Any*> {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<_T0>* _91_Symbol_46_iterator_93_();
	};
	class IArguments: public Object {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<_Any*>* _91_Symbol_46_iterator_93_();
		Object* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Object*& operator[](double index) {
			return __builtin_cheerp_make_regular<Object*>(this, 0)[static_cast<int>(index)];
		}
#endif
		int get_length() const;
		void set_length(double length);
		Function* get_callee();
		void set_callee(const _Function<void()>& callee);
		void set_callee(Function* callee);
	public:
		using client::Object::operator[];
	};
	template<class _T0>
	class PromiseLike;
	class PromiseConstructor;
	template<class _T0>
	class Promise: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		Promise<_T0>* finally();
		Promise<_T0>* finally(EventListener* onfinally);
		Promise<_T0>* finally(const _Function<void()>& onfinally);
		Promise<_Any*>* then();
		Promise<_Any*>* then(EventListener* onfulfilled);
		template<class _T1 = _T0>
		Promise<_Any*>* then(const _Function<_Union<_T1, PromiseLike<_T1>*>*(_T0)>& onfulfilled);
		Promise<_Any*>* then(EventListener* onfulfilled, EventListener* onrejected);
		template<class _T1 = _T0>
		Promise<_Any*>* then(const _Function<_Union<_T1, PromiseLike<_T1>*>*(_T0)>& onfulfilled, EventListener* onrejected);
		template<class _T2 = Object*>
		Promise<_Any*>* then(EventListener* onfulfilled, const _Function<_Union<_T2, PromiseLike<_T2>*>*(_Any*)>& onrejected);
		template<class _T1 = _T0, class _T2 = Object*>
		Promise<_Any*>* then(const _Function<_Union<_T1, PromiseLike<_T1>*>*(_T0)>& onfulfilled, const _Function<_Union<_T2, PromiseLike<_T2>*>*(_Any*)>& onrejected);
		[[cheerp::interface_name(("catch"))]]
		Promise<_Any*>* catch_();
		[[cheerp::interface_name(("catch"))]]
		Promise<_Any*>* catch_(EventListener* onrejected);
		template<class _T1 = Object*>
		[[cheerp::interface_name(("catch"))]]
		Promise<_Any*>* catch_(const _Function<_Union<_T1, PromiseLike<_T1>*>*(_Any*)>& onrejected);
		static Promise<TArray<Object*>*>* all(Iterable<_Any*>* values);
		static Promise<Object*>* all(const _Union<ReadonlyArray<Object*>*, Object*>& values);
		static Promise<Object*>* race(Iterable<_Any*>* values);
		static Promise<Object*>* race(const _Union<ReadonlyArray<Object*>*, Object*>& values);
		static Promise<_Any*>* prototype;
		Promise(EventListener* executor);
		template<class _T1>
		Promise(const _Function<void(_Function<void(_Union<_T1, PromiseLike<_T1>*>*)>*, _Function<void(_Any*)>*)>& executor);
		static Promise<_Any*>* reject();
		static Promise<_Any*>* reject(const _Any& reason);
		static Promise<_Any*>* resolve();
		static Promise<Object*>* resolve(const _Any& value);
		template<class _T1>
		static Promise<Object*>* resolve(_T1 value);
		template<class _T1>
		static Promise<Object*>* resolve(PromiseLike<_T1>* value);
		template<class _T1>
		static Promise<Object*>* resolve(const _Union<_T1, PromiseLike<_T1>*>& value);
		static PromiseConstructor* _91_Symbol_46_species_93_;
		static Promise<Object*>* allSettled(const _Union<ReadonlyArray<Object*>*, Object*>& values);
		static Promise<TArray<_Any*>*>* allSettled(Iterable<_Any*>* values);
	};
	class PromiseConstructor: public Object {
	public:
		Promise<TArray<Object*>*>* all(Iterable<_Any*>* values);
		Promise<Object*>* all(const _Union<ReadonlyArray<Object*>*, Object*>& values);
		Promise<Object*>* race(Iterable<_Any*>* values);
		Promise<Object*>* race(const _Union<ReadonlyArray<Object*>*, Object*>& values);
		Promise<_Any*>* get_prototype();
		Promise<_Any*>* reject();
		Promise<_Any*>* reject(const _Any& reason);
		Promise<_Any*>* resolve();
		Promise<Object*>* resolve(const _Any& value);
		template<class _T0>
		Promise<Object*>* resolve(_T0 value);
		template<class _T0>
		Promise<Object*>* resolve(PromiseLike<_T0>* value);
		template<class _T0>
		Promise<Object*>* resolve(const _Union<_T0, PromiseLike<_T0>*>& value);
		[[cheerp::interface_name(("get_[Symbol.species]"))]]
		PromiseConstructor* get__91_Symbol_46_species_93_();
		Promise<Object*>* allSettled(const _Union<ReadonlyArray<Object*>*, Object*>& values);
		Promise<TArray<_Any*>*>* allSettled(Iterable<_Any*>* values);
	};
	class ArrayBuffer;
	class SharedArrayBuffer;
	class ArrayBufferView: public virtual Object {
	public:
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		void set_buffer(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer);
		double get_byteLength();
		void set_byteLength(double byteLength);
		double get_byteOffset();
		void set_byteOffset(double byteOffset);
	};
	class Int8Array: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Int8Array* copyWithin(double target, double start);
		Int8Array* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Int8Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Int8Array*)>& predicate, const _Any& thisArg);
		Int8Array* fill(double value);
		Int8Array* fill(double value, double start);
		Int8Array* fill(double value, double start, double end);
		Int8Array* filter(EventListener* predicate);
		Int8Array* filter(const _Function<_Any*(double, double, Int8Array*)>& predicate);
		Int8Array* filter(EventListener* predicate, const _Any& thisArg);
		Int8Array* filter(const _Function<_Any*(double, double, Int8Array*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Int8Array*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Int8Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Int8Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Int8Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Int8Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Int8Array*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Int8Array* map(EventListener* callbackfn);
		Int8Array* map(const _Function<double(double, double, Int8Array*)>& callbackfn);
		Int8Array* map(EventListener* callbackfn, const _Any& thisArg);
		Int8Array* map(const _Function<double(double, double, Int8Array*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Int8Array*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Int8Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Int8Array*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Int8Array*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Int8Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Int8Array*)>& callbackfn, _T0 initialValue);
		Int8Array* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Int8Array* slice();
		Int8Array* slice(double start);
		Int8Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Int8Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Int8Array*)>& predicate, const _Any& thisArg);
		Int8Array* sort();
		Int8Array* sort(EventListener* compareFn);
		Int8Array* sort(const _Function<double(double, double)>& compareFn);
		Int8Array* subarray();
		Int8Array* subarray(double begin);
		Int8Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Int8Array* valueOf();
		Int8Array(Iterable<double>* elements);
		Int8Array();
		Int8Array(double length);
		Int8Array(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Int8Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Int8Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Int8Array* from(Iterable<double>* arrayLike);
		static Int8Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Int8Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Int8Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Int8Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Int8Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Int8Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Int8Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Int8Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Int8Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Int8Array* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Int8Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Int8Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		char operator[](double index) const {
			return __builtin_cheerp_make_regular<char>(this, 0)[static_cast<int>(index)];
		}
		char& operator[](double index) {
			return __builtin_cheerp_make_regular<char>(this, 0)[static_cast<int>(index)];
		}
		Int8Array(const Int8Array* array);
	public:
		using client::Object::operator[];
	};
	class Int8ArrayConstructor: public Object {
	public:
		Int8Array* from(Iterable<double>* arrayLike);
		Int8Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Int8Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Int8Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Int8Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Int8Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Int8Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Int8Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Int8Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Int8Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Int8Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Int8Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Int8Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	class Uint8Array: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Uint8Array* copyWithin(double target, double start);
		Uint8Array* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Uint8Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Uint8Array*)>& predicate, const _Any& thisArg);
		Uint8Array* fill(double value);
		Uint8Array* fill(double value, double start);
		Uint8Array* fill(double value, double start, double end);
		Uint8Array* filter(EventListener* predicate);
		Uint8Array* filter(const _Function<_Any*(double, double, Uint8Array*)>& predicate);
		Uint8Array* filter(EventListener* predicate, const _Any& thisArg);
		Uint8Array* filter(const _Function<_Any*(double, double, Uint8Array*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Uint8Array*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Uint8Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Uint8Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Uint8Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Uint8Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Uint8Array*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Uint8Array* map(EventListener* callbackfn);
		Uint8Array* map(const _Function<double(double, double, Uint8Array*)>& callbackfn);
		Uint8Array* map(EventListener* callbackfn, const _Any& thisArg);
		Uint8Array* map(const _Function<double(double, double, Uint8Array*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Uint8Array*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Uint8Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Uint8Array*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Uint8Array*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Uint8Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Uint8Array*)>& callbackfn, _T0 initialValue);
		Uint8Array* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Uint8Array* slice();
		Uint8Array* slice(double start);
		Uint8Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Uint8Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Uint8Array*)>& predicate, const _Any& thisArg);
		Uint8Array* sort();
		Uint8Array* sort(EventListener* compareFn);
		Uint8Array* sort(const _Function<double(double, double)>& compareFn);
		Uint8Array* subarray();
		Uint8Array* subarray(double begin);
		Uint8Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Uint8Array* valueOf();
		Uint8Array(Iterable<double>* elements);
		Uint8Array();
		Uint8Array(double length);
		Uint8Array(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Uint8Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Uint8Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Uint8Array* from(Iterable<double>* arrayLike);
		static Uint8Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Uint8Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Uint8Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Uint8Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Uint8Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Uint8Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Uint8Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Uint8Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Uint8Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Uint8Array* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Uint8Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Uint8Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		unsigned char operator[](double index) const {
			return __builtin_cheerp_make_regular<unsigned char>(this, 0)[static_cast<int>(index)];
		}
		unsigned char& operator[](double index) {
			return __builtin_cheerp_make_regular<unsigned char>(this, 0)[static_cast<int>(index)];
		}
		Uint8Array(const Uint8Array* array);
	public:
		using client::Object::operator[];
	};
	class Uint8ArrayConstructor: public Object {
	public:
		Uint8Array* from(Iterable<double>* arrayLike);
		Uint8Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Uint8Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Uint8Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Uint8Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Uint8Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Uint8Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Uint8Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Uint8Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Uint8Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Uint8Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Uint8Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Uint8Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	class Uint8ClampedArray: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Uint8ClampedArray* copyWithin(double target, double start);
		Uint8ClampedArray* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Uint8ClampedArray*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Uint8ClampedArray*)>& predicate, const _Any& thisArg);
		Uint8ClampedArray* fill(double value);
		Uint8ClampedArray* fill(double value, double start);
		Uint8ClampedArray* fill(double value, double start, double end);
		Uint8ClampedArray* filter(EventListener* predicate);
		Uint8ClampedArray* filter(const _Function<_Any*(double, double, Uint8ClampedArray*)>& predicate);
		Uint8ClampedArray* filter(EventListener* predicate, const _Any& thisArg);
		Uint8ClampedArray* filter(const _Function<_Any*(double, double, Uint8ClampedArray*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Uint8ClampedArray*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Uint8ClampedArray*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Uint8ClampedArray*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Uint8ClampedArray*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Uint8ClampedArray*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Uint8ClampedArray*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Uint8ClampedArray* map(EventListener* callbackfn);
		Uint8ClampedArray* map(const _Function<double(double, double, Uint8ClampedArray*)>& callbackfn);
		Uint8ClampedArray* map(EventListener* callbackfn, const _Any& thisArg);
		Uint8ClampedArray* map(const _Function<double(double, double, Uint8ClampedArray*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Uint8ClampedArray*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Uint8ClampedArray*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Uint8ClampedArray*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Uint8ClampedArray*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Uint8ClampedArray*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Uint8ClampedArray*)>& callbackfn, _T0 initialValue);
		Uint8ClampedArray* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Uint8ClampedArray* slice();
		Uint8ClampedArray* slice(double start);
		Uint8ClampedArray* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Uint8ClampedArray*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Uint8ClampedArray*)>& predicate, const _Any& thisArg);
		Uint8ClampedArray* sort();
		Uint8ClampedArray* sort(EventListener* compareFn);
		Uint8ClampedArray* sort(const _Function<double(double, double)>& compareFn);
		Uint8ClampedArray* subarray();
		Uint8ClampedArray* subarray(double begin);
		Uint8ClampedArray* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Uint8ClampedArray* valueOf();
		Uint8ClampedArray(Iterable<double>* elements);
		Uint8ClampedArray();
		Uint8ClampedArray(double length);
		Uint8ClampedArray(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Uint8ClampedArray(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Uint8ClampedArray(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Uint8ClampedArray* from(Iterable<double>* arrayLike);
		static Uint8ClampedArray* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Uint8ClampedArray* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Uint8ClampedArray* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Uint8ClampedArray* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Uint8ClampedArray* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Uint8ClampedArray* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Uint8ClampedArray* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Uint8ClampedArray* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Uint8ClampedArray* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Uint8ClampedArray* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Uint8ClampedArray*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Uint8ClampedArray*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		double operator[](double index) const {
			return __builtin_cheerp_make_regular<double>(this, 0)[static_cast<int>(index)];
		}
		double& operator[](double index) {
			return __builtin_cheerp_make_regular<double>(this, 0)[static_cast<int>(index)];
		}
		Uint8ClampedArray(const Uint8ClampedArray* array);
	public:
		using client::Object::operator[];
	};
	class Uint8ClampedArrayConstructor: public Object {
	public:
		Uint8ClampedArray* from(Iterable<double>* arrayLike);
		Uint8ClampedArray* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Uint8ClampedArray* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Uint8ClampedArray* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Uint8ClampedArray* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Uint8ClampedArray* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Uint8ClampedArray* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Uint8ClampedArray* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Uint8ClampedArray* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Uint8ClampedArray* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Uint8ClampedArray* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Uint8ClampedArray*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Uint8ClampedArray*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	class Int16Array: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Int16Array* copyWithin(double target, double start);
		Int16Array* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Int16Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Int16Array*)>& predicate, const _Any& thisArg);
		Int16Array* fill(double value);
		Int16Array* fill(double value, double start);
		Int16Array* fill(double value, double start, double end);
		Int16Array* filter(EventListener* predicate);
		Int16Array* filter(const _Function<_Any*(double, double, Int16Array*)>& predicate);
		Int16Array* filter(EventListener* predicate, const _Any& thisArg);
		Int16Array* filter(const _Function<_Any*(double, double, Int16Array*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Int16Array*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Int16Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Int16Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Int16Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Int16Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Int16Array*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Int16Array* map(EventListener* callbackfn);
		Int16Array* map(const _Function<double(double, double, Int16Array*)>& callbackfn);
		Int16Array* map(EventListener* callbackfn, const _Any& thisArg);
		Int16Array* map(const _Function<double(double, double, Int16Array*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Int16Array*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Int16Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Int16Array*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Int16Array*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Int16Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Int16Array*)>& callbackfn, _T0 initialValue);
		Int16Array* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Int16Array* slice();
		Int16Array* slice(double start);
		Int16Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Int16Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Int16Array*)>& predicate, const _Any& thisArg);
		Int16Array* sort();
		Int16Array* sort(EventListener* compareFn);
		Int16Array* sort(const _Function<double(double, double)>& compareFn);
		Int16Array* subarray();
		Int16Array* subarray(double begin);
		Int16Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Int16Array* valueOf();
		Int16Array(Iterable<double>* elements);
		Int16Array();
		Int16Array(double length);
		Int16Array(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Int16Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Int16Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Int16Array* from(Iterable<double>* arrayLike);
		static Int16Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Int16Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Int16Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Int16Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Int16Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Int16Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Int16Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Int16Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Int16Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Int16Array* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Int16Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Int16Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		short operator[](double index) const {
			return __builtin_cheerp_make_regular<short>(this, 0)[static_cast<int>(index)];
		}
		short& operator[](double index) {
			return __builtin_cheerp_make_regular<short>(this, 0)[static_cast<int>(index)];
		}
		Int16Array(const Int16Array* array);
	public:
		using client::Object::operator[];
	};
	class Int16ArrayConstructor: public Object {
	public:
		Int16Array* from(Iterable<double>* arrayLike);
		Int16Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Int16Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Int16Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Int16Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Int16Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Int16Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Int16Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Int16Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Int16Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Int16Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Int16Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Int16Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	class Uint16Array: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Uint16Array* copyWithin(double target, double start);
		Uint16Array* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Uint16Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Uint16Array*)>& predicate, const _Any& thisArg);
		Uint16Array* fill(double value);
		Uint16Array* fill(double value, double start);
		Uint16Array* fill(double value, double start, double end);
		Uint16Array* filter(EventListener* predicate);
		Uint16Array* filter(const _Function<_Any*(double, double, Uint16Array*)>& predicate);
		Uint16Array* filter(EventListener* predicate, const _Any& thisArg);
		Uint16Array* filter(const _Function<_Any*(double, double, Uint16Array*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Uint16Array*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Uint16Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Uint16Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Uint16Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Uint16Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Uint16Array*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Uint16Array* map(EventListener* callbackfn);
		Uint16Array* map(const _Function<double(double, double, Uint16Array*)>& callbackfn);
		Uint16Array* map(EventListener* callbackfn, const _Any& thisArg);
		Uint16Array* map(const _Function<double(double, double, Uint16Array*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Uint16Array*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Uint16Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Uint16Array*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Uint16Array*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Uint16Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Uint16Array*)>& callbackfn, _T0 initialValue);
		Uint16Array* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Uint16Array* slice();
		Uint16Array* slice(double start);
		Uint16Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Uint16Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Uint16Array*)>& predicate, const _Any& thisArg);
		Uint16Array* sort();
		Uint16Array* sort(EventListener* compareFn);
		Uint16Array* sort(const _Function<double(double, double)>& compareFn);
		Uint16Array* subarray();
		Uint16Array* subarray(double begin);
		Uint16Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Uint16Array* valueOf();
		Uint16Array(Iterable<double>* elements);
		Uint16Array();
		Uint16Array(double length);
		Uint16Array(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Uint16Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Uint16Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Uint16Array* from(Iterable<double>* arrayLike);
		static Uint16Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Uint16Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Uint16Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Uint16Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Uint16Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Uint16Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Uint16Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Uint16Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Uint16Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Uint16Array* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Uint16Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Uint16Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		unsigned short operator[](double index) const {
			return __builtin_cheerp_make_regular<unsigned short>(this, 0)[static_cast<int>(index)];
		}
		unsigned short& operator[](double index) {
			return __builtin_cheerp_make_regular<unsigned short>(this, 0)[static_cast<int>(index)];
		}
		Uint16Array(const Uint16Array* array);
	public:
		using client::Object::operator[];
	};
	class Uint16ArrayConstructor: public Object {
	public:
		Uint16Array* from(Iterable<double>* arrayLike);
		Uint16Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Uint16Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Uint16Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Uint16Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Uint16Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Uint16Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Uint16Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Uint16Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Uint16Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Uint16Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Uint16Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Uint16Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	class Int32Array: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Int32Array* copyWithin(double target, double start);
		Int32Array* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Int32Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Int32Array*)>& predicate, const _Any& thisArg);
		Int32Array* fill(double value);
		Int32Array* fill(double value, double start);
		Int32Array* fill(double value, double start, double end);
		Int32Array* filter(EventListener* predicate);
		Int32Array* filter(const _Function<_Any*(double, double, Int32Array*)>& predicate);
		Int32Array* filter(EventListener* predicate, const _Any& thisArg);
		Int32Array* filter(const _Function<_Any*(double, double, Int32Array*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Int32Array*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Int32Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Int32Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Int32Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Int32Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Int32Array*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Int32Array* map(EventListener* callbackfn);
		Int32Array* map(const _Function<double(double, double, Int32Array*)>& callbackfn);
		Int32Array* map(EventListener* callbackfn, const _Any& thisArg);
		Int32Array* map(const _Function<double(double, double, Int32Array*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Int32Array*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Int32Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Int32Array*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Int32Array*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Int32Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Int32Array*)>& callbackfn, _T0 initialValue);
		Int32Array* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Int32Array* slice();
		Int32Array* slice(double start);
		Int32Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Int32Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Int32Array*)>& predicate, const _Any& thisArg);
		Int32Array* sort();
		Int32Array* sort(EventListener* compareFn);
		Int32Array* sort(const _Function<double(double, double)>& compareFn);
		Int32Array* subarray();
		Int32Array* subarray(double begin);
		Int32Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Int32Array* valueOf();
		Int32Array(Iterable<double>* elements);
		Int32Array();
		Int32Array(double length);
		Int32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Int32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Int32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Int32Array* from(Iterable<double>* arrayLike);
		static Int32Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Int32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Int32Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Int32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Int32Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Int32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Int32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Int32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Int32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Int32Array* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Int32Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Int32Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		int operator[](double index) const {
			return __builtin_cheerp_make_regular<int>(this, 0)[static_cast<int>(index)];
		}
		int& operator[](double index) {
			return __builtin_cheerp_make_regular<int>(this, 0)[static_cast<int>(index)];
		}
		Int32Array(const Int32Array* array);
	public:
		using client::Object::operator[];
	};
	class Int32ArrayConstructor: public Object {
	public:
		Int32Array* from(Iterable<double>* arrayLike);
		Int32Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Int32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Int32Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Int32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Int32Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Int32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Int32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Int32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Int32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Int32Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Int32Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Int32Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	class Uint32Array: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Uint32Array* copyWithin(double target, double start);
		Uint32Array* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Uint32Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Uint32Array*)>& predicate, const _Any& thisArg);
		Uint32Array* fill(double value);
		Uint32Array* fill(double value, double start);
		Uint32Array* fill(double value, double start, double end);
		Uint32Array* filter(EventListener* predicate);
		Uint32Array* filter(const _Function<_Any*(double, double, Uint32Array*)>& predicate);
		Uint32Array* filter(EventListener* predicate, const _Any& thisArg);
		Uint32Array* filter(const _Function<_Any*(double, double, Uint32Array*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Uint32Array*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Uint32Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Uint32Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Uint32Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Uint32Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Uint32Array*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Uint32Array* map(EventListener* callbackfn);
		Uint32Array* map(const _Function<double(double, double, Uint32Array*)>& callbackfn);
		Uint32Array* map(EventListener* callbackfn, const _Any& thisArg);
		Uint32Array* map(const _Function<double(double, double, Uint32Array*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Uint32Array*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Uint32Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Uint32Array*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Uint32Array*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Uint32Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Uint32Array*)>& callbackfn, _T0 initialValue);
		Uint32Array* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Uint32Array* slice();
		Uint32Array* slice(double start);
		Uint32Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Uint32Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Uint32Array*)>& predicate, const _Any& thisArg);
		Uint32Array* sort();
		Uint32Array* sort(EventListener* compareFn);
		Uint32Array* sort(const _Function<double(double, double)>& compareFn);
		Uint32Array* subarray();
		Uint32Array* subarray(double begin);
		Uint32Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Uint32Array* valueOf();
		Uint32Array(Iterable<double>* elements);
		Uint32Array();
		Uint32Array(double length);
		Uint32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Uint32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Uint32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Uint32Array* from(Iterable<double>* arrayLike);
		static Uint32Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Uint32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Uint32Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Uint32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Uint32Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Uint32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Uint32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Uint32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Uint32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Uint32Array* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Uint32Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Uint32Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		unsigned int operator[](double index) const {
			return __builtin_cheerp_make_regular<unsigned int>(this, 0)[static_cast<int>(index)];
		}
		unsigned int& operator[](double index) {
			return __builtin_cheerp_make_regular<unsigned int>(this, 0)[static_cast<int>(index)];
		}
		Uint32Array(const Uint32Array* array);
	public:
		using client::Object::operator[];
	};
	class Uint32ArrayConstructor: public Object {
	public:
		Uint32Array* from(Iterable<double>* arrayLike);
		Uint32Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Uint32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Uint32Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Uint32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Uint32Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Uint32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Uint32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Uint32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Uint32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Uint32Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Uint32Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Uint32Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	class Float32Array: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Float32Array* copyWithin(double target, double start);
		Float32Array* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Float32Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Float32Array*)>& predicate, const _Any& thisArg);
		Float32Array* fill(double value);
		Float32Array* fill(double value, double start);
		Float32Array* fill(double value, double start, double end);
		Float32Array* filter(EventListener* predicate);
		Float32Array* filter(const _Function<_Any*(double, double, Float32Array*)>& predicate);
		Float32Array* filter(EventListener* predicate, const _Any& thisArg);
		Float32Array* filter(const _Function<_Any*(double, double, Float32Array*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Float32Array*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Float32Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Float32Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Float32Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Float32Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Float32Array*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Float32Array* map(EventListener* callbackfn);
		Float32Array* map(const _Function<double(double, double, Float32Array*)>& callbackfn);
		Float32Array* map(EventListener* callbackfn, const _Any& thisArg);
		Float32Array* map(const _Function<double(double, double, Float32Array*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Float32Array*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Float32Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Float32Array*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Float32Array*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Float32Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Float32Array*)>& callbackfn, _T0 initialValue);
		Float32Array* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Float32Array* slice();
		Float32Array* slice(double start);
		Float32Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Float32Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Float32Array*)>& predicate, const _Any& thisArg);
		Float32Array* sort();
		Float32Array* sort(EventListener* compareFn);
		Float32Array* sort(const _Function<double(double, double)>& compareFn);
		Float32Array* subarray();
		Float32Array* subarray(double begin);
		Float32Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Float32Array* valueOf();
		Float32Array(Iterable<double>* elements);
		Float32Array();
		Float32Array(double length);
		Float32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Float32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Float32Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Float32Array* from(Iterable<double>* arrayLike);
		static Float32Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Float32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Float32Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Float32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Float32Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Float32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Float32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Float32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Float32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Float32Array* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Float32Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Float32Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		float operator[](double index) const {
			return __builtin_cheerp_make_regular<float>(this, 0)[static_cast<int>(index)];
		}
		float& operator[](double index) {
			return __builtin_cheerp_make_regular<float>(this, 0)[static_cast<int>(index)];
		}
		Float32Array(const Float32Array* array);
	public:
		using client::Object::operator[];
	};
	class Float32ArrayConstructor: public Object {
	public:
		Float32Array* from(Iterable<double>* arrayLike);
		Float32Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Float32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Float32Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Float32Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Float32Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Float32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Float32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Float32Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Float32Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Float32Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Float32Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Float32Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	class Float64Array: public virtual Object, public ArrayBufferView {
	public:
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<double>* _91_Symbol_46_iterator_93_();
		IterableIterator<Object*>* entries();
		IterableIterator<double>* keys();
		IterableIterator<double>* values();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		bool includes(double searchElement);
		bool includes(double searchElement, double fromIndex);
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		Float64Array* copyWithin(double target, double start);
		Float64Array* copyWithin(double target, double start, double end);
		bool every(EventListener* predicate);
		bool every(const _Function<Object*(double, double, Float64Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<Object*(double, double, Float64Array*)>& predicate, const _Any& thisArg);
		Float64Array* fill(double value);
		Float64Array* fill(double value, double start);
		Float64Array* fill(double value, double start, double end);
		Float64Array* filter(EventListener* predicate);
		Float64Array* filter(const _Function<_Any*(double, double, Float64Array*)>& predicate);
		Float64Array* filter(EventListener* predicate, const _Any& thisArg);
		Float64Array* filter(const _Function<_Any*(double, double, Float64Array*)>& predicate, const _Any& thisArg);
		double find(EventListener* predicate);
		double find(const _Function<bool(double, double, Float64Array*)>& predicate);
		double find(EventListener* predicate, const _Any& thisArg);
		double find(const _Function<bool(double, double, Float64Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(double, double, Float64Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(double, double, Float64Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, double, Float64Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, double, Float64Array*)>& callbackfn, const _Any& thisArg);
		int indexOf(double searchElement) const;
		int indexOf(double searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		int lastIndexOf(double searchElement) const;
		int lastIndexOf(double searchElement, double fromIndex) const;
		int get_length() const;
		Float64Array* map(EventListener* callbackfn);
		Float64Array* map(const _Function<double(double, double, Float64Array*)>& callbackfn);
		Float64Array* map(EventListener* callbackfn, const _Any& thisArg);
		Float64Array* map(const _Function<double(double, double, Float64Array*)>& callbackfn, const _Any& thisArg);
		double reduce(EventListener* callbackfn);
		double reduce(const _Function<double(double, double, double, Float64Array*)>& callbackfn);
		double reduce(EventListener* callbackfn, double initialValue);
		double reduce(const _Function<double(double, double, double, Float64Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, double, double, Float64Array*)>& callbackfn, _T0 initialValue);
		double reduceRight(EventListener* callbackfn);
		double reduceRight(const _Function<double(double, double, double, Float64Array*)>& callbackfn);
		double reduceRight(EventListener* callbackfn, double initialValue);
		double reduceRight(const _Function<double(double, double, double, Float64Array*)>& callbackfn, double initialValue);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, double, double, Float64Array*)>& callbackfn, _T0 initialValue);
		Float64Array* reverse();
		void set(ArrayLike<double>* array);
		void set(ArrayLike<double>* array, double offset);
		Float64Array* slice();
		Float64Array* slice(double start);
		Float64Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<Object*(double, double, Float64Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<Object*(double, double, Float64Array*)>& predicate, const _Any& thisArg);
		Float64Array* sort();
		Float64Array* sort(EventListener* compareFn);
		Float64Array* sort(const _Function<double(double, double)>& compareFn);
		Float64Array* subarray();
		Float64Array* subarray(double begin);
		Float64Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		Float64Array* valueOf();
		Float64Array(Iterable<double>* elements);
		Float64Array();
		Float64Array(double length);
		Float64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayLike<double>*>& array);
		Float64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		Float64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static Float64Array* from(Iterable<double>* arrayLike);
		static Float64Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		static Float64Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		static Float64Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		static Float64Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		static Float64Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		static Float64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static Float64Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		static Float64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static Float64Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		static Float64Array* prototype;
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Float64Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<Float64Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		double operator[](double index) const {
			return __builtin_cheerp_make_regular<double>(this, 0)[static_cast<int>(index)];
		}
		double& operator[](double index) {
			return __builtin_cheerp_make_regular<double>(this, 0)[static_cast<int>(index)];
		}
		Float64Array(const Float64Array* array);
	public:
		using client::Object::operator[];
	};
	class Float64ArrayConstructor: public Object {
	public:
		Float64Array* from(Iterable<double>* arrayLike);
		Float64Array* from(Iterable<double>* arrayLike, EventListener* mapfn);
		Float64Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn);
		Float64Array* from(Iterable<double>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		Float64Array* from(Iterable<double>* arrayLike, const _Function<double(double, double)>& mapfn, const _Any& thisArg);
		Float64Array* from(ArrayLike<double>* arrayLike);
		template<class _T0>
		Float64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		Float64Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn);
		template<class _T0>
		Float64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		Float64Array* from(ArrayLike<_T0>* arrayLike, const _Function<double(_T0, double)>& mapfn, const _Any& thisArg);
		Float64Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), Float64Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::Float64Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	};
	template<class _T0>
	class ProxyHandler: public Object {
		static_assert(cheerp::CanCast<_T0, Object*>);
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		Object* apply(_T0 target, const _Any& thisArg, Array* argArray);
		Object* construct(_T0 target, Array* argArray, const _Function<void()>& newTarget);
		Object* construct(_T0 target, Array* argArray, Function* newTarget);
		bool defineProperty(_T0 target, const String& property, PropertyDescriptor* attributes);
		bool defineProperty(_T0 target, Symbol* property, PropertyDescriptor* attributes);
		bool deleteProperty(_T0 target, const String& p);
		bool deleteProperty(_T0 target, Symbol* p);
		Object* get(_T0 target, const String& p, const _Any& receiver);
		Object* get(_T0 target, Symbol* p, const _Any& receiver);
		PropertyDescriptor* getOwnPropertyDescriptor(_T0 target, const String& p);
		PropertyDescriptor* getOwnPropertyDescriptor(_T0 target, Symbol* p);
		Object* getPrototypeOf(_T0 target);
		bool has(_T0 target, const String& p);
		bool has(_T0 target, Symbol* p);
		bool isExtensible(_T0 target);
		ArrayLike<_Any*>* ownKeys(_T0 target);
		bool preventExtensions(_T0 target);
		bool set(_T0 target, const String& p, const _Any& newValue, const _Any& receiver);
		bool set(_T0 target, Symbol* p, const _Any& newValue, const _Any& receiver);
		bool setPrototypeOf(_T0 target, Object* v);
	};
	class ProxyConstructor: public Object {
	public:
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Object*>, Object*> revocable(_T0 target, ProxyHandler<_T0>* handler);
	};
	extern ProxyConstructor Proxy;
	namespace Reflect {
		template<class _T0, class _T1>
		_T1 apply(EventListener* target, _T0 thisArgument, Object* argumentsList);
		template<class _T0, class _T1>
		_T1 apply(const _Function<_T1(ReadonlyArray<_Any*>*)>& target, _T0 thisArgument, Object* argumentsList);
		Object* apply(const _Function<void()>& target, const _Any& thisArgument, ArrayLike<_Any*>* argumentsList);
		Object* apply(Function* target, const _Any& thisArgument, ArrayLike<_Any*>* argumentsList);
		Object* construct(Object* target, Object* argumentsList);
		Object* construct(Object* target, Object* argumentsList, Object* newTarget);
		Object* construct(const _Function<void()>& target, ArrayLike<_Any*>* argumentsList);
		Object* construct(Function* target, ArrayLike<_Any*>* argumentsList);
		Object* construct(const _Function<void()>& target, ArrayLike<_Any*>* argumentsList, const _Function<void()>& newTarget);
		Object* construct(Function* target, ArrayLike<_Any*>* argumentsList, const _Function<void()>& newTarget);
		Object* construct(const _Function<void()>& target, ArrayLike<_Any*>* argumentsList, Function* newTarget);
		Object* construct(Function* target, ArrayLike<_Any*>* argumentsList, Function* newTarget);
		bool defineProperty(Object* target, const String& propertyKey, PropertyDescriptor* attributes);
		bool defineProperty(Object* target, const _Union<double, Symbol*>& propertyKey, PropertyDescriptor* attributes);
		bool deleteProperty(Object* target, const String& propertyKey);
		bool deleteProperty(Object* target, const _Union<double, Symbol*>& propertyKey);
		Object* get(Object* target, const String& propertyKey);
		Object* get(Object* target, const _Union<double, Symbol*>& propertyKey);
		Object* get(Object* target, const String& propertyKey, Object* receiver);
		Object* get(Object* target, const _Union<double, Symbol*>& propertyKey, Object* receiver);
	}
	template<class _T0>
	class TypedPropertyDescriptor;
	namespace Reflect {
		TypedPropertyDescriptor<Object*>* getOwnPropertyDescriptor(Object* target, const String& propertyKey);
		TypedPropertyDescriptor<Object*>* getOwnPropertyDescriptor(Object* target, const _Union<double, Symbol*>& propertyKey);
		Object* getPrototypeOf(Object* target);
		bool has(Object* target, const String& propertyKey);
		bool has(Object* target, const _Union<double, Symbol*>& propertyKey);
		bool isExtensible(Object* target);
		TArray<_Any*>* ownKeys(Object* target);
		bool preventExtensions(Object* target);
		bool set(Object* target, const String& propertyKey, Object* value);
		bool set(Object* target, const _Union<double, Symbol*>& propertyKey, Object* value);
		bool set(Object* target, const String& propertyKey, Object* value, const _Any& receiver);
		bool set(Object* target, const _Union<double, Symbol*>& propertyKey, Object* value, const _Any& receiver);
		bool set(Object* target, const String& propertyKey, const _Any& value);
		bool set(Object* target, const _Union<double, Symbol*>& propertyKey, const _Any& value);
		bool set(Object* target, const String& propertyKey, const _Any& value, const _Any& receiver);
		bool set(Object* target, const _Union<double, Symbol*>& propertyKey, const _Any& value, const _Any& receiver);
		bool setPrototypeOf(Object* target, Object* proto);
	}
	class Symbol: public Object {
	public:
		[[cheerp::interface_name(("[Symbol.toPrimitive]"))]]
		Symbol* _91_Symbol_46_toPrimitive_93_(const String& hint);
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		String* get_description();
		String* toString();
		Symbol* valueOf();
		static Symbol* iterator;
		static Symbol* prototype;
		[[cheerp::interface_name(("for"))]]
		static Symbol* for_(const String& key);
		static String* keyFor(Symbol* sym);
		static Symbol* hasInstance;
		static Symbol* isConcatSpreadable;
		static Symbol* match;
		static Symbol* replace;
		static Symbol* search;
		static Symbol* species;
		static Symbol* split;
		static Symbol* toPrimitive;
		static Symbol* toStringTag;
		static Symbol* unscopables;
		static Symbol* asyncIterator;
		static Symbol* matchAll;
	};
	namespace Intl {
		class DateTimeFormatOptions;
	}
	class VarDate;
	class Date: public Object {
	public:
		[[cheerp::interface_name(("[Symbol.toPrimitive]"))]]
		_Union<String*, double>* _91_Symbol_46_toPrimitive_93_(const String& hint);
		String* toLocaleString();
		String* toLocaleString(const String& locales);
		String* toLocaleString(const _Union<Intl::Locale*, ReadonlyArray<_Any*>*>& locales);
		String* toLocaleString(const String& locales, Intl::DateTimeFormatOptions* options);
		String* toLocaleString(const _Union<Intl::Locale*, ReadonlyArray<_Any*>*>& locales, Intl::DateTimeFormatOptions* options);
		String* toLocaleString(TArray<String*>* locales);
		String* toLocaleString(TArray<String*>* locales, Intl::DateTimeFormatOptions* options);
		String* toLocaleDateString();
		String* toLocaleDateString(const String& locales);
		String* toLocaleDateString(const _Union<Intl::Locale*, ReadonlyArray<_Any*>*>& locales);
		String* toLocaleDateString(const String& locales, Intl::DateTimeFormatOptions* options);
		String* toLocaleDateString(const _Union<Intl::Locale*, ReadonlyArray<_Any*>*>& locales, Intl::DateTimeFormatOptions* options);
		String* toLocaleDateString(TArray<String*>* locales);
		String* toLocaleDateString(TArray<String*>* locales, Intl::DateTimeFormatOptions* options);
		String* toLocaleTimeString();
		String* toLocaleTimeString(const String& locales);
		String* toLocaleTimeString(const _Union<Intl::Locale*, ReadonlyArray<_Any*>*>& locales);
		String* toLocaleTimeString(const String& locales, Intl::DateTimeFormatOptions* options);
		String* toLocaleTimeString(const _Union<Intl::Locale*, ReadonlyArray<_Any*>*>& locales, Intl::DateTimeFormatOptions* options);
		String* toLocaleTimeString(TArray<String*>* locales);
		String* toLocaleTimeString(TArray<String*>* locales, Intl::DateTimeFormatOptions* options);
		String* toString();
		String* toDateString();
		String* toTimeString();
		double valueOf();
		double getTime();
		double getFullYear();
		double getUTCFullYear();
		double getMonth();
		double getUTCMonth();
		double getDate();
		double getUTCDate();
		double getDay();
		double getUTCDay();
		double getHours();
		double getUTCHours();
		double getMinutes();
		double getUTCMinutes();
		double getSeconds();
		double getUTCSeconds();
		double getMilliseconds();
		double getUTCMilliseconds();
		double getTimezoneOffset();
		double setTime(double time);
		double setMilliseconds(double ms);
		double setUTCMilliseconds(double ms);
		double setSeconds(double sec);
		double setSeconds(double sec, double ms);
		double setUTCSeconds(double sec);
		double setUTCSeconds(double sec, double ms);
		double setMinutes(double min);
		double setMinutes(double min, double sec);
		double setMinutes(double min, double sec, double ms);
		double setUTCMinutes(double min);
		double setUTCMinutes(double min, double sec);
		double setUTCMinutes(double min, double sec, double ms);
		double setHours(double hours);
		double setHours(double hours, double min);
		double setHours(double hours, double min, double sec);
		double setHours(double hours, double min, double sec, double ms);
		double setUTCHours(double hours);
		double setUTCHours(double hours, double min);
		double setUTCHours(double hours, double min, double sec);
		double setUTCHours(double hours, double min, double sec, double ms);
		double setDate(double date);
		double setUTCDate(double date);
		double setMonth(double month);
		double setMonth(double month, double date);
		double setUTCMonth(double month);
		double setUTCMonth(double month, double date);
		double setFullYear(double year);
		double setFullYear(double year, double month);
		double setFullYear(double year, double month, double date);
		double setUTCFullYear(double year);
		double setUTCFullYear(double year, double month);
		double setUTCFullYear(double year, double month, double date);
		String* toUTCString();
		String* toISOString();
		String* toJSON();
		String* toJSON(const _Any& key);
		_Function<VarDate*()>* get_getVarDate();
		void set_getVarDate(EventListener* getVarDate);
		void set_getVarDate(const _Function<VarDate*()>& getVarDate);
		Date(const String& value);
		Date(const _Union<double, Date*>& value);
		Date();
		Date(double value);
		Date(double year, double monthIndex);
		Date(double year, double monthIndex, double date);
		Date(double year, double monthIndex, double date, double hours);
		Date(double year, double monthIndex, double date, double hours, double minutes);
		Date(double year, double monthIndex, double date, double hours, double minutes, double seconds);
		Date(double year, double monthIndex, double date, double hours, double minutes, double seconds, double ms);
		Date(VarDate* vd);
		static double UTC(double year);
		static double UTC(double year, double monthIndex);
		static double UTC(double year, double monthIndex, double date);
		static double UTC(double year, double monthIndex, double date, double hours);
		static double UTC(double year, double monthIndex, double date, double hours, double minutes);
		static double UTC(double year, double monthIndex, double date, double hours, double minutes, double seconds);
		static double UTC(double year, double monthIndex, double date, double hours, double minutes, double seconds, double ms);
		static Date* prototype;
		static double parse(const String& s);
		static double now();
	};
	class JSONClass;
	extern JSONClass JSON;
	class JSONClass: public Object {
	public:
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		Object* parse(const String& text);
		Object* parse(const String& text, EventListener* reviver);
		Object* parse(const String& text, const _Function<_Any*(String*, _Any*)>& reviver);
		String* stringify(const _Any& value);
		String* stringify(const _Any& value, EventListener* replacer);
		String* stringify(const _Any& value, const _Function<_Any*(String*, _Any*)>& replacer);
		String* stringify(const _Any& value, EventListener* replacer, const String& space);
		String* stringify(const _Any& value, const _Function<_Any*(String*, _Any*)>& replacer, const String& space);
		String* stringify(const _Any& value, EventListener* replacer, double space);
		String* stringify(const _Any& value, const _Function<_Any*(String*, _Any*)>& replacer, double space);
		String* stringify(const _Any& value, Array* replacer);
		String* stringify(const _Any& value, Array* replacer, const String& space);
		String* stringify(const _Any& value, Array* replacer, double space);
	};
	class ArrayBufferConstructor;
	class ArrayBuffer: public Object {
	public:
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		double get_byteLength();
		ArrayBuffer* slice(double begin);
		ArrayBuffer* slice(double begin, double end);
		static ArrayBufferConstructor* _91_Symbol_46_species_93_;
		static ArrayBuffer* prototype;
		ArrayBuffer(double byteLength);
		static bool isView(const _Any& arg);
	};
	class BigInt;
	class DataView: public Object {
	public:
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		BigInt* getBigInt64(double byteOffset);
		BigInt* getBigInt64(double byteOffset, bool littleEndian);
		BigInt* getBigUint64(double byteOffset);
		BigInt* getBigUint64(double byteOffset, bool littleEndian);
		void setBigInt64(double byteOffset, BigInt* value);
		void setBigInt64(double byteOffset, BigInt* value, bool littleEndian);
		void setBigUint64(double byteOffset, BigInt* value);
		void setBigUint64(double byteOffset, BigInt* value, bool littleEndian);
		ArrayBuffer* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		double getFloat32(double byteOffset);
		double getFloat32(double byteOffset, bool littleEndian);
		double getFloat64(double byteOffset);
		double getFloat64(double byteOffset, bool littleEndian);
		double getInt8(double byteOffset);
		double getInt16(double byteOffset);
		double getInt16(double byteOffset, bool littleEndian);
		double getInt32(double byteOffset);
		double getInt32(double byteOffset, bool littleEndian);
		double getUint8(double byteOffset);
		double getUint16(double byteOffset);
		double getUint16(double byteOffset, bool littleEndian);
		double getUint32(double byteOffset);
		double getUint32(double byteOffset, bool littleEndian);
		void setFloat32(double byteOffset, double value);
		void setFloat32(double byteOffset, double value, bool littleEndian);
		void setFloat64(double byteOffset, double value);
		void setFloat64(double byteOffset, double value, bool littleEndian);
		void setInt8(double byteOffset, double value);
		void setInt16(double byteOffset, double value);
		void setInt16(double byteOffset, double value, bool littleEndian);
		void setInt32(double byteOffset, double value);
		void setInt32(double byteOffset, double value, bool littleEndian);
		void setUint8(double byteOffset, double value);
		void setUint16(double byteOffset, double value);
		void setUint16(double byteOffset, double value, bool littleEndian);
		void setUint32(double byteOffset, double value);
		void setUint32(double byteOffset, double value, bool littleEndian);
		static DataView* prototype;
		DataView(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer);
		DataView(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		DataView(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double byteLength);
	};
	class ArrayBufferConstructor: public Object {
	public:
		[[cheerp::interface_name(("get_[Symbol.species]"))]]
		ArrayBufferConstructor* get__91_Symbol_46_species_93_();
		ArrayBuffer* get_prototype();
		bool isView(const _Any& arg);
	};
	class SharedArrayBuffer: public Object {
	public:
		double get_byteLength();
		SharedArrayBuffer* slice(double begin);
		SharedArrayBuffer* slice(double begin, double end);
		[[cheerp::interface_name(("get_[Symbol.species]"))]]
		SharedArrayBuffer* get__91_Symbol_46_species_93_();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		static SharedArrayBuffer* prototype;
		SharedArrayBuffer(double byteLength);
	};
	class SharedArrayBufferConstructor: public Object {
	public:
		SharedArrayBuffer* get_prototype();
	};
	class ArrayBufferTypes: public Object {
	public:
		SharedArrayBuffer* get_SharedArrayBuffer();
		void set_SharedArrayBuffer(SharedArrayBuffer* SharedArrayBuffer);
		ArrayBuffer* get_ArrayBuffer();
		void set_ArrayBuffer(ArrayBuffer* ArrayBuffer);
	};
	class AtomicsClass;
	extern AtomicsClass Atomics;
	class BigInt64Array;
	class BigUint64Array;
	class AtomicsClass: public Object {
	public:
		double add(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*>& typedArray, double index, double value);
		BigInt* add(const _Union<BigInt64Array*, BigUint64Array*>& typedArray, double index, BigInt* value);
		[[cheerp::interface_name(("and"))]]
		double and_(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*>& typedArray, double index, double value);
		[[cheerp::interface_name(("and"))]]
		BigInt* and_(const _Union<BigInt64Array*, BigUint64Array*>& typedArray, double index, BigInt* value);
		double compareExchange(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*>& typedArray, double index, double expectedValue, double replacementValue);
		BigInt* compareExchange(const _Union<BigInt64Array*, BigUint64Array*>& typedArray, double index, BigInt* expectedValue, BigInt* replacementValue);
		double exchange(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*>& typedArray, double index, double value);
		BigInt* exchange(const _Union<BigInt64Array*, BigUint64Array*>& typedArray, double index, BigInt* value);
		bool isLockFree(double size);
		_Union<double, BigInt*>* load(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*, BigInt64Array*, BigUint64Array*>& typedArray, double index);
		[[cheerp::interface_name(("or"))]]
		double or_(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*>& typedArray, double index, double value);
		[[cheerp::interface_name(("or"))]]
		BigInt* or_(const _Union<BigInt64Array*, BigUint64Array*>& typedArray, double index, BigInt* value);
		double store(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*>& typedArray, double index, double value);
		BigInt* store(const _Union<BigInt64Array*, BigUint64Array*>& typedArray, double index, BigInt* value);
		double sub(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*>& typedArray, double index, double value);
		BigInt* sub(const _Union<BigInt64Array*, BigUint64Array*>& typedArray, double index, BigInt* value);
		String* wait(Int32Array* typedArray, double index, double value);
		String* wait(Int32Array* typedArray, double index, double value, double timeout);
		String* wait(BigInt64Array* typedArray, double index, BigInt* value);
		String* wait(BigInt64Array* typedArray, double index, BigInt* value, double timeout);
		double notify(Int32Array* typedArray, double index);
		double notify(Int32Array* typedArray, double index, double count);
		double notify(BigInt64Array* typedArray, double index);
		double notify(BigInt64Array* typedArray, double index, double count);
		[[cheerp::interface_name(("xor"))]]
		double xor_(const _Union<Int8Array*, Uint8Array*, Int16Array*, Uint16Array*, Int32Array*, Uint32Array*>& typedArray, double index, double value);
		[[cheerp::interface_name(("xor"))]]
		BigInt* xor_(const _Union<BigInt64Array*, BigUint64Array*>& typedArray, double index, BigInt* value);
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
	};
	namespace Intl {
		class DateTimeFormatPartTypesRegistry: public Object {
		public:
			Object* get_day();
			void set_day(const _Any& day);
			Object* get_dayPeriod();
			void set_dayPeriod(const _Any& dayPeriod);
			Object* get_era();
			void set_era(const _Any& era);
			Object* get_hour();
			void set_hour(const _Any& hour);
			Object* get_literal();
			void set_literal(const _Any& literal);
			Object* get_minute();
			void set_minute(const _Any& minute);
			Object* get_month();
			void set_month(const _Any& month);
			Object* get_second();
			void set_second(const _Any& second);
			Object* get_timeZoneName();
			void set_timeZoneName(const _Any& timeZoneName);
			Object* get_weekday();
			void set_weekday(const _Any& weekday);
			Object* get_year();
			void set_year(const _Any& year);
			Object* get_unknown();
			void set_unknown(const _Any& unknown);
		};
		using DateTimeFormatPartTypes = String;
		class DateTimeFormatPart: public Object {
		public:
			String* get_type();
			void set_type(const String& type);
			String* get_value();
			void set_value(const String& value);
		};
		class ResolvedDateTimeFormatOptions;
		class DateTimeFormat: public Object {
		public:
			TArray<DateTimeFormatPart*>* formatToParts();
			TArray<DateTimeFormatPart*>* formatToParts(const _Union<double, Date*>& date);
			String* format();
			String* format(const _Union<double, Date*>& date);
			ResolvedDateTimeFormatOptions* resolvedOptions();
			DateTimeFormat();
			DateTimeFormat(const String& locales);
			DateTimeFormat(TArray<String*>* locales);
			DateTimeFormat(const String& locales, DateTimeFormatOptions* options);
			DateTimeFormat(TArray<String*>* locales, DateTimeFormatOptions* options);
			static TArray<String*>* supportedLocalesOf(const String& locales);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales);
			static TArray<String*>* supportedLocalesOf(const String& locales, DateTimeFormatOptions* options);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales, DateTimeFormatOptions* options);
			static DateTimeFormat* prototype;
		};
		using LDMLPluralRule = String;
		using PluralRuleType = String;
		class PluralRulesOptions: public Object {
		public:
			String* get_localeMatcher();
			void set_localeMatcher(const String& localeMatcher);
			String* get_type();
			void set_type(const String& type);
			double get_minimumIntegerDigits();
			void set_minimumIntegerDigits(double minimumIntegerDigits);
			double get_minimumFractionDigits();
			void set_minimumFractionDigits(double minimumFractionDigits);
			double get_maximumFractionDigits();
			void set_maximumFractionDigits(double maximumFractionDigits);
			double get_minimumSignificantDigits();
			void set_minimumSignificantDigits(double minimumSignificantDigits);
			double get_maximumSignificantDigits();
			void set_maximumSignificantDigits(double maximumSignificantDigits);
		};
		class ResolvedPluralRulesOptions: public Object {
		public:
			String* get_locale();
			void set_locale(const String& locale);
			TArray<String*>* get_pluralCategories();
			void set_pluralCategories(TArray<String*>* pluralCategories);
			String* get_type();
			void set_type(const String& type);
			double get_minimumIntegerDigits();
			void set_minimumIntegerDigits(double minimumIntegerDigits);
			double get_minimumFractionDigits();
			void set_minimumFractionDigits(double minimumFractionDigits);
			double get_maximumFractionDigits();
			void set_maximumFractionDigits(double maximumFractionDigits);
			double get_minimumSignificantDigits();
			void set_minimumSignificantDigits(double minimumSignificantDigits);
			double get_maximumSignificantDigits();
			void set_maximumSignificantDigits(double maximumSignificantDigits);
		};
		class PluralRules: public Object {
		public:
			ResolvedPluralRulesOptions* resolvedOptions();
			String* select(double n);
			PluralRules();
			PluralRules(const String& locales);
			PluralRules(TArray<String*>* locales);
			PluralRules(const String& locales, PluralRulesOptions* options);
			PluralRules(TArray<String*>* locales, PluralRulesOptions* options);
			static TArray<String*>* supportedLocalesOf(const String& locales);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales);
			static TArray<String*>* supportedLocalesOf(const String& locales, Object* options);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales, Object* options);
		};
		using ES2018NumberFormatPartType = String;
		using ES2020NumberFormatPartType = String;
		using NumberFormatPartTypes = String;
		class NumberFormatPart: public Object {
		public:
			String* get_type();
			void set_type(const String& type);
			String* get_value();
			void set_value(const String& value);
		};
		class ResolvedNumberFormatOptions;
		class NumberRangeFormatPart;
		class NumberFormat: public Object {
		public:
			TArray<NumberFormatPart*>* formatToParts();
			TArray<NumberFormatPart*>* formatToParts(const _Union<double, BigInt*>& number);
			String* format(const _Union<double, BigInt*>& value);
			String* format(double value);
			ResolvedNumberFormatOptions* resolvedOptions();
			String* formatRange(const _Union<double, BigInt*>& start, const _Union<double, BigInt*>& end);
			TArray<NumberRangeFormatPart*>* formatRangeToParts(const _Union<double, BigInt*>& start, const _Union<double, BigInt*>& end);
			NumberFormat();
			NumberFormat(const String& locales);
			NumberFormat(TArray<String*>* locales);
			NumberFormat(const String& locales, NumberFormatOptions* options);
			NumberFormat(TArray<String*>* locales, NumberFormatOptions* options);
			static TArray<String*>* supportedLocalesOf(const String& locales);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales);
			static TArray<String*>* supportedLocalesOf(const String& locales, NumberFormatOptions* options);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales, NumberFormatOptions* options);
			static NumberFormat* prototype;
		};
		using UnicodeBCP47LocaleIdentifier = String;
		using RelativeTimeFormatUnit = String;
		using RelativeTimeFormatUnitSingular = String;
		using RelativeTimeFormatLocaleMatcher = String;
		using RelativeTimeFormatNumeric = String;
		using RelativeTimeFormatStyle = String;
		using BCP47LanguageTag = String;
		using LocalesArgument = _Any;
		class RelativeTimeFormatOptions: public Object {
		public:
			String* get_localeMatcher();
			void set_localeMatcher(const String& localeMatcher);
			String* get_numeric();
			void set_numeric(const String& numeric);
			String* get_style();
			void set_style(const String& style);
		};
		class ResolvedRelativeTimeFormatOptions: public Object {
		public:
			String* get_locale();
			void set_locale(const String& locale);
			String* get_style();
			void set_style(const String& style);
			String* get_numeric();
			void set_numeric(const String& numeric);
			String* get_numberingSystem();
			void set_numberingSystem(const String& numberingSystem);
		};
		using RelativeTimeFormatPart = Object;
		class RelativeTimeFormat: public Object {
		public:
			String* format(double value, const String& unit);
			TArray<Object*>* formatToParts(double value, const String& unit);
			ResolvedRelativeTimeFormatOptions* resolvedOptions();
			RelativeTimeFormat();
			RelativeTimeFormat(const String& locales);
			RelativeTimeFormat(TArray<String*>* locales);
			RelativeTimeFormat(const String& locales, RelativeTimeFormatOptions* options);
			RelativeTimeFormat(TArray<String*>* locales, RelativeTimeFormatOptions* options);
			static TArray<String*>* supportedLocalesOf();
			static TArray<String*>* supportedLocalesOf(const String& locales);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales);
			static TArray<String*>* supportedLocalesOf(const String& locales, RelativeTimeFormatOptions* options);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales, RelativeTimeFormatOptions* options);
		};
		class NumberFormatOptions: public Object {
		public:
			String* get_compactDisplay();
			void set_compactDisplay(const String& compactDisplay);
			String* get_notation();
			void set_notation(const String& notation);
			String* get_signDisplay();
			void set_signDisplay(const String& signDisplay);
			String* get_unit();
			void set_unit(const String& unit);
			String* get_unitDisplay();
			void set_unitDisplay(const String& unitDisplay);
			String* get_currencyDisplay();
			void set_currencyDisplay(const String& currencyDisplay);
			String* get_currencySign();
			void set_currencySign(const String& currencySign);
			String* get_localeMatcher();
			void set_localeMatcher(const String& localeMatcher);
			String* get_style();
			void set_style(const String& style);
			String* get_currency();
			void set_currency(const String& currency);
			bool get_useGrouping();
			void set_useGrouping(bool useGrouping);
			double get_minimumIntegerDigits();
			void set_minimumIntegerDigits(double minimumIntegerDigits);
			double get_minimumFractionDigits();
			void set_minimumFractionDigits(double minimumFractionDigits);
			double get_maximumFractionDigits();
			void set_maximumFractionDigits(double maximumFractionDigits);
			double get_minimumSignificantDigits();
			void set_minimumSignificantDigits(double minimumSignificantDigits);
			double get_maximumSignificantDigits();
			void set_maximumSignificantDigits(double maximumSignificantDigits);
		};
		class ResolvedNumberFormatOptions: public Object {
		public:
			String* get_compactDisplay();
			void set_compactDisplay(const String& compactDisplay);
			String* get_notation();
			void set_notation(const String& notation);
			String* get_signDisplay();
			void set_signDisplay(const String& signDisplay);
			String* get_unit();
			void set_unit(const String& unit);
			String* get_unitDisplay();
			void set_unitDisplay(const String& unitDisplay);
			String* get_currencyDisplay();
			void set_currencyDisplay(const String& currencyDisplay);
			String* get_currencySign();
			void set_currencySign(const String& currencySign);
			String* get_locale();
			void set_locale(const String& locale);
			String* get_numberingSystem();
			void set_numberingSystem(const String& numberingSystem);
			String* get_style();
			void set_style(const String& style);
			String* get_currency();
			void set_currency(const String& currency);
			double get_minimumIntegerDigits();
			void set_minimumIntegerDigits(double minimumIntegerDigits);
			double get_minimumFractionDigits();
			void set_minimumFractionDigits(double minimumFractionDigits);
			double get_maximumFractionDigits();
			void set_maximumFractionDigits(double maximumFractionDigits);
			double get_minimumSignificantDigits();
			void set_minimumSignificantDigits(double minimumSignificantDigits);
			double get_maximumSignificantDigits();
			void set_maximumSignificantDigits(double maximumSignificantDigits);
			bool get_useGrouping();
			void set_useGrouping(bool useGrouping);
		};
		class DateTimeFormatOptions: public Object {
		public:
			String* get_calendar();
			void set_calendar(const String& calendar);
			String* get_dayPeriod();
			void set_dayPeriod(const String& dayPeriod);
			String* get_numberingSystem();
			void set_numberingSystem(const String& numberingSystem);
			String* get_dateStyle();
			void set_dateStyle(const String& dateStyle);
			String* get_timeStyle();
			void set_timeStyle(const String& timeStyle);
			String* get_hourCycle();
			void set_hourCycle(const String& hourCycle);
			String* get_localeMatcher();
			void set_localeMatcher(const String& localeMatcher);
			String* get_weekday();
			void set_weekday(const String& weekday);
			String* get_era();
			void set_era(const String& era);
			String* get_year();
			void set_year(const String& year);
			String* get_month();
			void set_month(const String& month);
			String* get_day();
			void set_day(const String& day);
			String* get_hour();
			void set_hour(const String& hour);
			String* get_minute();
			void set_minute(const String& minute);
			String* get_second();
			void set_second(const String& second);
			String* get_timeZoneName();
			void set_timeZoneName(const String& timeZoneName);
			String* get_formatMatcher();
			void set_formatMatcher(const String& formatMatcher);
			bool get_hour12();
			void set_hour12(bool hour12);
			String* get_timeZone();
			void set_timeZone(const String& timeZone);
		};
		using LocaleHourCycleKey = String;
		using LocaleCollationCaseFirst = String;
		class LocaleOptions: public Object {
		public:
			String* get_baseName();
			void set_baseName(const String& baseName);
			String* get_calendar();
			void set_calendar(const String& calendar);
			String* get_caseFirst();
			void set_caseFirst(const String& caseFirst);
			String* get_collation();
			void set_collation(const String& collation);
			String* get_hourCycle();
			void set_hourCycle(const String& hourCycle);
			String* get_language();
			void set_language(const String& language);
			String* get_numberingSystem();
			void set_numberingSystem(const String& numberingSystem);
			bool get_numeric();
			void set_numeric(bool numeric);
			String* get_region();
			void set_region(const String& region);
			String* get_script();
			void set_script(const String& script);
		};
		class Locale: public LocaleOptions {
		public:
			String* get_baseName();
			void set_baseName(const String& baseName);
			String* get_language();
			void set_language(const String& language);
			Locale* maximize();
			Locale* minimize();
			String* toString();
			Locale(const String& tag);
			Locale(Locale* tag);
			Locale(const String& tag, LocaleOptions* options);
			Locale(Locale* tag, LocaleOptions* options);
		};
		using DisplayNamesFallback = String;
		using DisplayNamesType = String;
		using DisplayNamesLanguageDisplay = String;
		class DisplayNamesOptions: public Object {
		public:
			String* get_localeMatcher();
			void set_localeMatcher(const String& localeMatcher);
			String* get_style();
			void set_style(const String& style);
			String* get_type();
			void set_type(const String& type);
			String* get_languageDisplay();
			void set_languageDisplay(const String& languageDisplay);
			String* get_fallback();
			void set_fallback(const String& fallback);
		};
		class ResolvedDisplayNamesOptions: public Object {
		public:
			String* get_locale();
			void set_locale(const String& locale);
			String* get_style();
			void set_style(const String& style);
			String* get_type();
			void set_type(const String& type);
			String* get_fallback();
			void set_fallback(const String& fallback);
			String* get_languageDisplay();
			void set_languageDisplay(const String& languageDisplay);
		};
		class DisplayNames: public Object {
		public:
			String* of(const String& code);
			ResolvedDisplayNamesOptions* resolvedOptions();
			static DisplayNames* prototype;
			DisplayNames(const String& locales, DisplayNamesOptions* options);
			DisplayNames(const _Union<Locale*, ReadonlyArray<_Any*>*>& locales, DisplayNamesOptions* options);
			static TArray<String*>* supportedLocalesOf();
			static TArray<String*>* supportedLocalesOf(const String& locales);
			static TArray<String*>* supportedLocalesOf(const _Union<Locale*, ReadonlyArray<_Any*>*>& locales);
			static TArray<String*>* supportedLocalesOf(const String& locales, Object* options);
			static TArray<String*>* supportedLocalesOf(const _Union<Locale*, ReadonlyArray<_Any*>*>& locales, Object* options);
		};
		class CollatorOptions: public Object {
		public:
			String* get_usage();
			void set_usage(const String& usage);
			String* get_localeMatcher();
			void set_localeMatcher(const String& localeMatcher);
			bool get_numeric();
			void set_numeric(bool numeric);
			String* get_caseFirst();
			void set_caseFirst(const String& caseFirst);
			String* get_sensitivity();
			void set_sensitivity(const String& sensitivity);
			String* get_collation();
			void set_collation(const String& collation);
			bool get_ignorePunctuation();
			void set_ignorePunctuation(bool ignorePunctuation);
		};
		class ResolvedCollatorOptions: public Object {
		public:
			String* get_locale();
			void set_locale(const String& locale);
			String* get_usage();
			void set_usage(const String& usage);
			String* get_sensitivity();
			void set_sensitivity(const String& sensitivity);
			bool get_ignorePunctuation();
			void set_ignorePunctuation(bool ignorePunctuation);
			String* get_collation();
			void set_collation(const String& collation);
			String* get_caseFirst();
			void set_caseFirst(const String& caseFirst);
			bool get_numeric();
			void set_numeric(bool numeric);
		};
		class Collator: public Object {
		public:
			double compare(const String& x, const String& y);
			ResolvedCollatorOptions* resolvedOptions();
			Collator();
			Collator(const String& locales);
			Collator(TArray<String*>* locales);
			Collator(const String& locales, CollatorOptions* options);
			Collator(TArray<String*>* locales, CollatorOptions* options);
			static TArray<String*>* supportedLocalesOf(const String& locales);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales);
			static TArray<String*>* supportedLocalesOf(const String& locales, CollatorOptions* options);
			static TArray<String*>* supportedLocalesOf(TArray<String*>* locales, CollatorOptions* options);
		};
		class ResolvedDateTimeFormatOptions: public Object {
		public:
			String* get_locale();
			void set_locale(const String& locale);
			String* get_calendar();
			void set_calendar(const String& calendar);
			String* get_numberingSystem();
			void set_numberingSystem(const String& numberingSystem);
			String* get_timeZone();
			void set_timeZone(const String& timeZone);
			bool get_hour12();
			void set_hour12(bool hour12);
			String* get_weekday();
			void set_weekday(const String& weekday);
			String* get_era();
			void set_era(const String& era);
			String* get_year();
			void set_year(const String& year);
			String* get_month();
			void set_month(const String& month);
			String* get_day();
			void set_day(const String& day);
			String* get_hour();
			void set_hour(const String& hour);
			String* get_minute();
			void set_minute(const String& minute);
			String* get_second();
			void set_second(const String& second);
			String* get_timeZoneName();
			void set_timeZoneName(const String& timeZoneName);
		};
		class NumberRangeFormatPart: public NumberFormatPart {
		public:
			String* get_source();
			void set_source(const String& source);
		};
	}
	template<class _T0, class _T1, class _T2>
	class AsyncIterator: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1, _T2>);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		Promise<_Any*>* next(_Args... args) {
			return _next(cheerp::clientCast(args)...)->template cast<client::Promise<_Any*>*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("next"))]]
		_Any* _next(_Args... data);
	public:
		[[cheerp::interface_name(("return"))]]
		Promise<_Any*>* return_();
		[[cheerp::interface_name(("return"))]]
		Promise<_Any*>* return_(_T1 value);
		[[cheerp::interface_name(("return"))]]
		Promise<_Any*>* return_(PromiseLike<_T1>* value);
		[[cheerp::interface_name(("return"))]]
		Promise<_Any*>* return_(const _Union<_T1, PromiseLike<_T1>*>& value);
		[[cheerp::interface_name(("throw"))]]
		Promise<_Any*>* throw_();
		[[cheerp::interface_name(("throw"))]]
		Promise<_Any*>* throw_(const _Any& e);
	};
	template<class _T0, class _T1, class _T2>
	class AsyncGenerator: public AsyncIterator<_T0, _T1, _T2> {
		static_assert(cheerp::CheckTemplate<_T0, _T1, _T2>);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		Promise<_Any*>* next(_Args... args) {
			return _next(cheerp::clientCast(args)...)->template cast<client::Promise<_Any*>*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("next"))]]
		_Any* _next(_Args... data);
	public:
		[[cheerp::interface_name(("return"))]]
		Promise<_Any*>* return_(_T1 value);
		[[cheerp::interface_name(("return"))]]
		Promise<_Any*>* return_(PromiseLike<_T1>* value);
		[[cheerp::interface_name(("return"))]]
		Promise<_Any*>* return_(const _Union<_T1, PromiseLike<_T1>*>& value);
		[[cheerp::interface_name(("throw"))]]
		Promise<_Any*>* throw_(const _Any& e);
		[[cheerp::interface_name(("[Symbol.asyncIterator]"))]]
		AsyncGenerator<_T0, _T1, _T2>* _91_Symbol_46_asyncIterator_93_();
	};
	class AsyncGeneratorFunction: public Object {
	public:
		int get_length() const;
		String* get_name();
		AsyncGenerator<Object*, _Any*, Object*>* get_prototype();
	};
	class AsyncGeneratorFunctionConstructor: public Object {
	public:
		int get_length() const;
		String* get_name();
		_Function<AsyncGenerator<Object*, _Any*, Object*>*(TArray<_Any*>*)>* get_prototype();
	};
	template<class _T0>
	class AsyncIterable: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		[[cheerp::interface_name(("[Symbol.asyncIterator]"))]]
		AsyncIterator<_T0, _Any*, _Any*>* _91_Symbol_46_asyncIterator_93_();
	};
	template<class _T0>
	class AsyncIterableIterator: public AsyncIterator<_T0, _Any*, _Any*> {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		[[cheerp::interface_name(("[Symbol.asyncIterator]"))]]
		AsyncIterableIterator<_T0>* _91_Symbol_46_asyncIterator_93_();
	};
	class RegExpExecArray: public TArray<String*> {
	public:
		Object* get_groups();
		void set_groups(Object* groups);
		double get_index();
		void set_index(double index);
		String* get_input();
		void set_input(const String& input);
		[[cheerp::interface_name(("get_0"))]]
		String* get__48_();
		[[cheerp::interface_name(("set_0"))]]
		void set__48_(const String& _48_);
	};
	using FlatArray = Object;
	class BigIntToLocaleStringOptions: public Object {
	public:
		String* get_localeMatcher();
		void set_localeMatcher(const String& localeMatcher);
		String* get_style();
		void set_style(const String& style);
		String* get_numberingSystem();
		void set_numberingSystem(const String& numberingSystem);
		String* get_unit();
		void set_unit(const String& unit);
		String* get_unitDisplay();
		void set_unitDisplay(const String& unitDisplay);
		String* get_currency();
		void set_currency(const String& currency);
		String* get_currencyDisplay();
		void set_currencyDisplay(const String& currencyDisplay);
		bool get_useGrouping();
		void set_useGrouping(bool useGrouping);
		double get_minimumIntegerDigits();
		void set_minimumIntegerDigits(double minimumIntegerDigits);
		double get_minimumFractionDigits();
		void set_minimumFractionDigits(double minimumFractionDigits);
		double get_maximumFractionDigits();
		void set_maximumFractionDigits(double maximumFractionDigits);
		double get_minimumSignificantDigits();
		void set_minimumSignificantDigits(double minimumSignificantDigits);
		double get_maximumSignificantDigits();
		void set_maximumSignificantDigits(double maximumSignificantDigits);
		String* get_notation();
		void set_notation(const String& notation);
		String* get_compactDisplay();
		void set_compactDisplay(const String& compactDisplay);
	};
	class BigInt: public Object {
	public:
		String* toString();
		String* toString(double radix);
		String* toLocaleString();
		String* toLocaleString(const String& locales);
		String* toLocaleString(const _Union<Intl::Locale*, ReadonlyArray<_Any*>*>& locales);
		String* toLocaleString(const String& locales, BigIntToLocaleStringOptions* options);
		String* toLocaleString(const _Union<Intl::Locale*, ReadonlyArray<_Any*>*>& locales, BigIntToLocaleStringOptions* options);
		BigInt* valueOf();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		static BigInt* prototype;
		static BigInt* asIntN(double bits, BigInt* int_);
		static BigInt* asUintN(double bits, BigInt* int_);
	};
	class BigIntConstructor: public Object {
	public:
		BigInt* get_prototype();
		BigInt* asIntN(double bits, BigInt* int_);
		BigInt* asUintN(double bits, BigInt* int_);
	};
	class BigInt64Array: public Object {
	public:
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		BigInt64Array* copyWithin(double target, double start);
		BigInt64Array* copyWithin(double target, double start, double end);
		IterableIterator<Object*>* entries();
		bool every(EventListener* predicate);
		bool every(const _Function<bool(BigInt*, double, BigInt64Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<bool(BigInt*, double, BigInt64Array*)>& predicate, const _Any& thisArg);
		BigInt64Array* fill(BigInt* value);
		BigInt64Array* fill(BigInt* value, double start);
		BigInt64Array* fill(BigInt* value, double start, double end);
		BigInt64Array* filter(EventListener* predicate);
		BigInt64Array* filter(const _Function<_Any*(BigInt*, double, BigInt64Array*)>& predicate);
		BigInt64Array* filter(EventListener* predicate, const _Any& thisArg);
		BigInt64Array* filter(const _Function<_Any*(BigInt*, double, BigInt64Array*)>& predicate, const _Any& thisArg);
		BigInt* find(EventListener* predicate);
		BigInt* find(const _Function<bool(BigInt*, double, BigInt64Array*)>& predicate);
		BigInt* find(EventListener* predicate, const _Any& thisArg);
		BigInt* find(const _Function<bool(BigInt*, double, BigInt64Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(BigInt*, double, BigInt64Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(BigInt*, double, BigInt64Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(BigInt*, double, BigInt64Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(BigInt*, double, BigInt64Array*)>& callbackfn, const _Any& thisArg);
		bool includes(BigInt* searchElement);
		bool includes(BigInt* searchElement, double fromIndex);
		int indexOf(BigInt* searchElement) const;
		int indexOf(BigInt* searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		IterableIterator<double>* keys();
		int lastIndexOf(BigInt* searchElement) const;
		int lastIndexOf(BigInt* searchElement, double fromIndex) const;
		int get_length() const;
		BigInt64Array* map(EventListener* callbackfn);
		BigInt64Array* map(const _Function<BigInt*(BigInt*, double, BigInt64Array*)>& callbackfn);
		BigInt64Array* map(EventListener* callbackfn, const _Any& thisArg);
		BigInt64Array* map(const _Function<BigInt*(BigInt*, double, BigInt64Array*)>& callbackfn, const _Any& thisArg);
		BigInt* reduce(EventListener* callbackfn);
		BigInt* reduce(const _Function<BigInt*(BigInt*, BigInt*, double, BigInt64Array*)>& callbackfn);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, BigInt*, double, BigInt64Array*)>& callbackfn, _T0 initialValue);
		BigInt* reduceRight(EventListener* callbackfn);
		BigInt* reduceRight(const _Function<BigInt*(BigInt*, BigInt*, double, BigInt64Array*)>& callbackfn);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, BigInt*, double, BigInt64Array*)>& callbackfn, _T0 initialValue);
		BigInt64Array* reverse();
		void set(ArrayLike<BigInt*>* array);
		void set(ArrayLike<BigInt*>* array, double offset);
		BigInt64Array* slice();
		BigInt64Array* slice(double start);
		BigInt64Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<bool(BigInt*, double, BigInt64Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<bool(BigInt*, double, BigInt64Array*)>& predicate, const _Any& thisArg);
		BigInt64Array* sort();
		BigInt64Array* sort(EventListener* compareFn);
		BigInt64Array* sort(const _Function<_Union<double, BigInt*>*(BigInt*, BigInt*)>& compareFn);
		BigInt64Array* subarray();
		BigInt64Array* subarray(double begin);
		BigInt64Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		BigInt64Array* valueOf();
		IterableIterator<BigInt*>* values();
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<BigInt*>* _91_Symbol_46_iterator_93_();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		BigInt* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		BigInt*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::BigInt*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static BigInt64Array* prototype;
		BigInt64Array();
		BigInt64Array(double length);
		BigInt64Array(Iterable<BigInt*>* array);
		BigInt64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer);
		BigInt64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		BigInt64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, BigInt*> && ...), BigInt64Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<BigInt64Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		static BigInt64Array* from(ArrayLike<BigInt*>* arrayLike);
		template<class _T0>
		static BigInt64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static BigInt64Array* from(ArrayLike<_T0>* arrayLike, const _Function<BigInt*(_T0, double)>& mapfn);
		template<class _T0>
		static BigInt64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static BigInt64Array* from(ArrayLike<_T0>* arrayLike, const _Function<BigInt*(_T0, double)>& mapfn, const _Any& thisArg);
	public:
		using client::Object::operator[];
	};
	class BigInt64ArrayConstructor: public Object {
	public:
		BigInt64Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, BigInt*> && ...), BigInt64Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::BigInt64Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	public:
		BigInt64Array* from(ArrayLike<BigInt*>* arrayLike);
		template<class _T0>
		BigInt64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		BigInt64Array* from(ArrayLike<_T0>* arrayLike, const _Function<BigInt*(_T0, double)>& mapfn);
		template<class _T0>
		BigInt64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		BigInt64Array* from(ArrayLike<_T0>* arrayLike, const _Function<BigInt*(_T0, double)>& mapfn, const _Any& thisArg);
	};
	class BigUint64Array: public Object {
	public:
		double get_BYTES_PER_ELEMENT();
		_Union<ArrayBuffer*, SharedArrayBuffer*>* get_buffer();
		double get_byteLength();
		double get_byteOffset();
		BigUint64Array* copyWithin(double target, double start);
		BigUint64Array* copyWithin(double target, double start, double end);
		IterableIterator<Object*>* entries();
		bool every(EventListener* predicate);
		bool every(const _Function<bool(BigInt*, double, BigUint64Array*)>& predicate);
		bool every(EventListener* predicate, const _Any& thisArg);
		bool every(const _Function<bool(BigInt*, double, BigUint64Array*)>& predicate, const _Any& thisArg);
		BigUint64Array* fill(BigInt* value);
		BigUint64Array* fill(BigInt* value, double start);
		BigUint64Array* fill(BigInt* value, double start, double end);
		BigUint64Array* filter(EventListener* predicate);
		BigUint64Array* filter(const _Function<_Any*(BigInt*, double, BigUint64Array*)>& predicate);
		BigUint64Array* filter(EventListener* predicate, const _Any& thisArg);
		BigUint64Array* filter(const _Function<_Any*(BigInt*, double, BigUint64Array*)>& predicate, const _Any& thisArg);
		BigInt* find(EventListener* predicate);
		BigInt* find(const _Function<bool(BigInt*, double, BigUint64Array*)>& predicate);
		BigInt* find(EventListener* predicate, const _Any& thisArg);
		BigInt* find(const _Function<bool(BigInt*, double, BigUint64Array*)>& predicate, const _Any& thisArg);
		double findIndex(EventListener* predicate);
		double findIndex(const _Function<bool(BigInt*, double, BigUint64Array*)>& predicate);
		double findIndex(EventListener* predicate, const _Any& thisArg);
		double findIndex(const _Function<bool(BigInt*, double, BigUint64Array*)>& predicate, const _Any& thisArg);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(BigInt*, double, BigUint64Array*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(BigInt*, double, BigUint64Array*)>& callbackfn, const _Any& thisArg);
		bool includes(BigInt* searchElement);
		bool includes(BigInt* searchElement, double fromIndex);
		int indexOf(BigInt* searchElement) const;
		int indexOf(BigInt* searchElement, double fromIndex) const;
		String* join();
		String* join(const String& separator);
		IterableIterator<double>* keys();
		int lastIndexOf(BigInt* searchElement) const;
		int lastIndexOf(BigInt* searchElement, double fromIndex) const;
		int get_length() const;
		BigUint64Array* map(EventListener* callbackfn);
		BigUint64Array* map(const _Function<BigInt*(BigInt*, double, BigUint64Array*)>& callbackfn);
		BigUint64Array* map(EventListener* callbackfn, const _Any& thisArg);
		BigUint64Array* map(const _Function<BigInt*(BigInt*, double, BigUint64Array*)>& callbackfn, const _Any& thisArg);
		BigInt* reduce(EventListener* callbackfn);
		BigInt* reduce(const _Function<BigInt*(BigInt*, BigInt*, double, BigUint64Array*)>& callbackfn);
		template<class _T0>
		_T0 reduce(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduce(const _Function<_T0(_T0, BigInt*, double, BigUint64Array*)>& callbackfn, _T0 initialValue);
		BigInt* reduceRight(EventListener* callbackfn);
		BigInt* reduceRight(const _Function<BigInt*(BigInt*, BigInt*, double, BigUint64Array*)>& callbackfn);
		template<class _T0>
		_T0 reduceRight(EventListener* callbackfn, _T0 initialValue);
		template<class _T0>
		_T0 reduceRight(const _Function<_T0(_T0, BigInt*, double, BigUint64Array*)>& callbackfn, _T0 initialValue);
		BigUint64Array* reverse();
		void set(ArrayLike<BigInt*>* array);
		void set(ArrayLike<BigInt*>* array, double offset);
		BigUint64Array* slice();
		BigUint64Array* slice(double start);
		BigUint64Array* slice(double start, double end);
		bool some(EventListener* predicate);
		bool some(const _Function<bool(BigInt*, double, BigUint64Array*)>& predicate);
		bool some(EventListener* predicate, const _Any& thisArg);
		bool some(const _Function<bool(BigInt*, double, BigUint64Array*)>& predicate, const _Any& thisArg);
		BigUint64Array* sort();
		BigUint64Array* sort(EventListener* compareFn);
		BigUint64Array* sort(const _Function<_Union<double, BigInt*>*(BigInt*, BigInt*)>& compareFn);
		BigUint64Array* subarray();
		BigUint64Array* subarray(double begin);
		BigUint64Array* subarray(double begin, double end);
		String* toLocaleString();
		String* toString();
		BigUint64Array* valueOf();
		IterableIterator<BigInt*>* values();
		[[cheerp::interface_name(("[Symbol.iterator]"))]]
		IterableIterator<BigInt*>* _91_Symbol_46_iterator_93_();
		[[cheerp::interface_name(("get_[Symbol.toStringTag]"))]]
		String* get__91_Symbol_46_toStringTag_93_();
		BigInt* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		BigInt*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::BigInt*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static BigUint64Array* prototype;
		BigUint64Array();
		BigUint64Array(double length);
		BigUint64Array(Iterable<BigInt*>* array);
		BigUint64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer);
		BigUint64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset);
		BigUint64Array(const _Union<ArrayBuffer*, SharedArrayBuffer*>& buffer, double byteOffset, double length);
		static double BYTES_PER_ELEMENT;
		template<class... _Args>
		[[gnu::always_inline]]
		static cheerp::EnableIf<(cheerp::CanCastArgs<_Args, BigInt*> && ...), BigUint64Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<BigUint64Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		static _Any* _of(_Args... data);
	public:
		static BigUint64Array* from(ArrayLike<BigInt*>* arrayLike);
		template<class _T0>
		static BigUint64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		static BigUint64Array* from(ArrayLike<_T0>* arrayLike, const _Function<BigInt*(_T0, double)>& mapfn);
		template<class _T0>
		static BigUint64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		static BigUint64Array* from(ArrayLike<_T0>* arrayLike, const _Function<BigInt*(_T0, double)>& mapfn, const _Any& thisArg);
	public:
		using client::Object::operator[];
	};
	class BigUint64ArrayConstructor: public Object {
	public:
		BigUint64Array* get_prototype();
		double get_BYTES_PER_ELEMENT();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, BigInt*> && ...), BigUint64Array*> of(_Args... items) {
			return _of(cheerp::clientCast(items)...)->template cast<client::BigUint64Array*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("of"))]]
		_Any* _of(_Args... data);
	public:
		BigUint64Array* from(ArrayLike<BigInt*>* arrayLike);
		template<class _T0>
		BigUint64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn);
		template<class _T0>
		BigUint64Array* from(ArrayLike<_T0>* arrayLike, const _Function<BigInt*(_T0, double)>& mapfn);
		template<class _T0>
		BigUint64Array* from(ArrayLike<_T0>* arrayLike, EventListener* mapfn, const _Any& thisArg);
		template<class _T0>
		BigUint64Array* from(ArrayLike<_T0>* arrayLike, const _Function<BigInt*(_T0, double)>& mapfn, const _Any& thisArg);
	};
	template<class _T0>
	class PromiseFulfilledResult: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		String* get_status();
		void set_status(const String& status);
		_T0 get_value();
		void set_value(_T0 value);
	};
	class PromiseRejectedResult: public Object {
	public:
		String* get_status();
		void set_status(const String& status);
		Object* get_reason();
		void set_reason(const _Any& reason);
	};
	using PromiseSettledResult = _Any;
	using ClassMemberDecoratorContext = _Any;
	using DecoratorContext = _Any;
	using DecoratorMetadataObject = Object;
	using DecoratorMetadata = Object;
	template<class _T0>
	class ClassDecoratorContext: public Object {
		static_assert(cheerp::CanCast<_T0, Object*>);
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		String* get_kind();
		String* get_name();
		void addInitializer(EventListener* initializer);
		void addInitializer(const _Function<void()>& initializer);
		Object* get_metadata();
	};
	template<class _T0, class _T1>
	class ClassMethodDecoratorContext: public Object {
		static_assert(cheerp::CanCast<_T1, _Function<_Any*(_Any*)>*>);
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		String* get_kind();
		_Union<String*, Symbol*>* get_name();
		[[cheerp::interface_name(("get_static"))]]
		bool get_static_();
		[[cheerp::interface_name(("get_private"))]]
		bool get_private_();
		Object* get_access();
		void addInitializer(EventListener* initializer);
		void addInitializer(const _Function<void()>& initializer);
		Object* get_metadata();
	};
	template<class _T0, class _T1>
	class ClassGetterDecoratorContext: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		String* get_kind();
		_Union<String*, Symbol*>* get_name();
		[[cheerp::interface_name(("get_static"))]]
		bool get_static_();
		[[cheerp::interface_name(("get_private"))]]
		bool get_private_();
		Object* get_access();
		void addInitializer(EventListener* initializer);
		void addInitializer(const _Function<void()>& initializer);
		Object* get_metadata();
	};
	template<class _T0, class _T1>
	class ClassSetterDecoratorContext: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		String* get_kind();
		_Union<String*, Symbol*>* get_name();
		[[cheerp::interface_name(("get_static"))]]
		bool get_static_();
		[[cheerp::interface_name(("get_private"))]]
		bool get_private_();
		Object* get_access();
		void addInitializer(EventListener* initializer);
		void addInitializer(const _Function<void()>& initializer);
		Object* get_metadata();
	};
	template<class _T0, class _T1>
	class ClassAccessorDecoratorContext: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		String* get_kind();
		_Union<String*, Symbol*>* get_name();
		[[cheerp::interface_name(("get_static"))]]
		bool get_static_();
		[[cheerp::interface_name(("get_private"))]]
		bool get_private_();
		Object* get_access();
		void addInitializer(EventListener* initializer);
		void addInitializer(const _Function<void()>& initializer);
		Object* get_metadata();
	};
	template<class _T0, class _T1>
	class ClassAccessorDecoratorTarget: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		_T1 get();
		void set(_T1 value);
	};
	template<class _T0, class _T1>
	class ClassAccessorDecoratorResult: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		_T1 get();
		void set(_T1 value);
		_T1 init(_T1 value);
	};
	template<class _T0, class _T1>
	class ClassFieldDecoratorContext: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		String* get_kind();
		_Union<String*, Symbol*>* get_name();
		[[cheerp::interface_name(("get_static"))]]
		bool get_static_();
		[[cheerp::interface_name(("get_private"))]]
		bool get_private_();
		Object* get_access();
		void addInitializer(EventListener* initializer);
		void addInitializer(const _Function<void()>& initializer);
		Object* get_metadata();
	};
	using ClassDecorator = _Function<_Any*(_Any*)>;
	using PropertyDecorator = _Function<void(Object*, _Union<String*, Symbol*>*)>;
	using MethodDecorator = _Function<_Union<void, TypedPropertyDescriptor<_Any*>*>*(Object*, _Union<String*, Symbol*>*, TypedPropertyDescriptor<_Any*>*)>;
	using ParameterDecorator = _Function<void(Object*, _Union<String*, Symbol*>*, double)>;
	extern double NaN;
	extern double Infinity;
	Object* eval(const String& x);
	double parseInt(const String& string);
	double parseInt(const String& string, double radix);
	double parseFloat(const String& string);
	bool isNaN(double number);
	bool isFinite(double number);
	String* decodeURI(const String& encodedURI);
	String* decodeURIComponent(const String& encodedURIComponent);
	String* encodeURI(const String& uri);
	String* encodeURIComponent(const String& uriComponent);
	String* encodeURIComponent(const _Union<double, bool>& uriComponent);
	String* escape(const String& string);
	String* unescape(const String& string);
	using PropertyKey = _Any;
	class PropertyDescriptor: public Object {
	public:
		bool get_configurable();
		void set_configurable(bool configurable);
		bool get_enumerable();
		void set_enumerable(bool enumerable);
		Object* get_value();
		void set_value(const _Any& value);
		bool get_writable();
		void set_writable(bool writable);
		Object* get();
		void set(const _Any& v);
	};
	class PropertyDescriptorMap: public Object {
	public:
		PropertyDescriptor* operator[](const String& key) const;
		PropertyDescriptor* operator[](const _Union<double, Symbol*>& key) const;
	public:
		using client::Object::operator[];
	};
	class FunctionConstructor: public Object {
	public:
		Function* get_prototype();
	};
	using ThisParameterType = Object;
	using OmitThisParameter = Object;
	class CallableFunction: public Function {
	public:
		template<class _T0, class _T1>
		_T1 apply(_T0 thisArg);
		template<class _T0, class _T1, class _T2>
		cheerp::EnableIf<cheerp::CanCast<_T1, TArray<_Any*>*>, _T2> apply(_T0 thisArg, _T1 args);
		template<class _T0, class _T1, class _T2, class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<((cheerp::CanCastArgs<_Args, cheerp::ArrayElementType<_T1>> && ...) && cheerp::CanCast<_T1, TArray<_Any*>*>), _T2> call(_T0 thisArg, _Args... args) {
			return _call(cheerp::clientCast(thisArg), cheerp::clientCast(args)...)->template cast<cheerp::EnableIf<cheerp::CanCast<_T1, client::TArray<_Any*>*>, _T2>>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("call"))]]
		_Any* _call(_Args... data);
	public:
		Object* bind(Object* thisArg);
		template<class _T0, class _T1, class _T2, class _T3, class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<((cheerp::CanCastArgs<_Args, cheerp::ArrayElementType<_T1>> && ...) && cheerp::CanCast<_T1, TArray<_Any*>*> && cheerp::CanCast<_T2, TArray<_Any*>*>), _Function<_T3(_T2)>*> bind(_T0 thisArg, _Args... args) {
			return _bind(cheerp::clientCast(thisArg), cheerp::clientCast(args)...)->template cast<cheerp::EnableIf<(cheerp::CanCast<_T1, client::TArray<_Any*>*> && cheerp::CanCast<_T2, client::TArray<_Any*>*>), _Function<_T3(_T2)>*>>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("bind"))]]
		_Any* _bind(_Args... data);
	};
	class NewableFunction: public Function {
	public:
		void apply(const _Any& thisArg);
		void apply(const _Any& thisArg, Array* args);
		template<class... _Args>
		[[gnu::always_inline]]
		void call(const _Any& thisArg, _Args... args) {
			_call(cheerp::clientCast(thisArg), cheerp::clientCast(args)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("call"))]]
		_Any* _call(_Args... data);
	public:
		template<class _T0>
		_T0 bind(const _Any& thisArg);
		template<class... _Args>
		[[gnu::always_inline]]
		Object* bind(const _Any& thisArg, _Args... args) {
			return _bind(cheerp::clientCast(thisArg), cheerp::clientCast(args)...)->template cast<client::Object*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("bind"))]]
		_Any* _bind(_Args... data);
	};
	class Boolean: public Object {
	public:
		bool valueOf();
		Boolean();
		Boolean(const _Any& value);
		static Boolean* prototype;
	};
	class BooleanConstructor: public Object {
	public:
		Boolean* get_prototype();
	};
	class TemplateStringsArray: public ReadonlyArray<String*> {
	public:
		ReadonlyArray<String*>* get_raw();
	};
	class ImportMeta: public Object {
	public:
		String* get_url();
		void set_url(const String& url);
	};
	class ImportAssertions;
	class ImportCallOptions: public Object {
	public:
		[[cheerp::interface_name(("get_assert"))]]
		ImportAssertions* get_assert_();
		[[cheerp::interface_name(("set_assert"))]]
		void set_assert_(ImportAssertions* assert_);
	};
	class ImportAssertions: public Object {
	public:
		String* operator[](const String& key) const;
	public:
		using client::Object::operator[];
	};
	class Error: public Object {
	public:
		String* get_name();
		void set_name(const String& name);
		String* get_message();
		void set_message(const String& message);
		String* get_stack();
		void set_stack(const String& stack);
		Error();
		Error(const String& message);
		static Error* prototype;
	};
	class ErrorConstructor: public Object {
	public:
		Error* get_prototype();
	};
	class EvalError: public Error {
	public:
		EvalError();
		EvalError(const String& message);
		static EvalError* prototype;
	};
	class EvalErrorConstructor: public _Function<Error*(String*)> {
	public:
		EvalError* get_prototype();
	};
	class RangeError: public Error {
	public:
		RangeError();
		RangeError(const String& message);
		static RangeError* prototype;
	};
	class RangeErrorConstructor: public _Function<Error*(String*)> {
	public:
		RangeError* get_prototype();
	};
	class ReferenceError: public Error {
	public:
		ReferenceError();
		ReferenceError(const String& message);
		static ReferenceError* prototype;
	};
	class ReferenceErrorConstructor: public _Function<Error*(String*)> {
	public:
		ReferenceError* get_prototype();
	};
	class SyntaxError: public Error {
	public:
		SyntaxError();
		SyntaxError(const String& message);
		static SyntaxError* prototype;
	};
	class SyntaxErrorConstructor: public _Function<Error*(String*)> {
	public:
		SyntaxError* get_prototype();
	};
	class TypeError: public Error {
	public:
		TypeError();
		TypeError(const String& message);
		static TypeError* prototype;
	};
	class TypeErrorConstructor: public _Function<Error*(String*)> {
	public:
		TypeError* get_prototype();
	};
	class URIError: public Error {
	public:
		URIError();
		URIError(const String& message);
		static URIError* prototype;
	};
	class URIErrorConstructor: public _Function<Error*(String*)> {
	public:
		URIError* get_prototype();
	};
	template<class _T0>
	class ConcatArray: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		int get_length() const;
		_T0 operator[](double n) const;
#ifndef LEAN_CXX_LIB
		_T0& operator[](double n) {
			return __builtin_cheerp_make_regular<_T0>(this, 0)[static_cast<int>(n)];
		}
#endif
		String* join();
		String* join(const String& separator);
		TArray<_T0>* slice();
		TArray<_T0>* slice(double start);
		TArray<_T0>* slice(double start, double end);
	public:
		using client::Object::operator[];
	};
	template<class _T0>
	class TypedPropertyDescriptor: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool get_enumerable();
		void set_enumerable(bool enumerable);
		bool get_configurable();
		void set_configurable(bool configurable);
		bool get_writable();
		void set_writable(bool writable);
		_T0 get_value();
		void set_value(_T0 value);
		_Function<_T0()>* get_get();
		void set_get(EventListener* get);
		void set_get(const _Function<_T0()>& get);
		_Function<void(_T0)>* get_set();
		void set_set(EventListener* set);
		void set_set(const _Function<void(_T0)>& set);
	};
	using PromiseConstructorLike = Object;
	template<class _T0>
	class PromiseLike: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		PromiseLike<_Any*>* then();
		PromiseLike<_Any*>* then(EventListener* onfulfilled);
		template<class _T1 = _T0>
		PromiseLike<_Any*>* then(const _Function<_Union<_T1, PromiseLike<_T1>*>*(_T0)>& onfulfilled);
		PromiseLike<_Any*>* then(EventListener* onfulfilled, EventListener* onrejected);
		template<class _T1 = _T0>
		PromiseLike<_Any*>* then(const _Function<_Union<_T1, PromiseLike<_T1>*>*(_T0)>& onfulfilled, EventListener* onrejected);
		template<class _T2 = Object*>
		PromiseLike<_Any*>* then(EventListener* onfulfilled, const _Function<_Union<_T2, PromiseLike<_T2>*>*(_Any*)>& onrejected);
		template<class _T1 = _T0, class _T2 = Object*>
		PromiseLike<_Any*>* then(const _Function<_Union<_T1, PromiseLike<_T1>*>*(_T0)>& onfulfilled, const _Function<_Union<_T2, PromiseLike<_T2>*>*(_Any*)>& onrejected);
	};
	using Awaited = Object;
	template<class _T0>
	class ArrayLike: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		int get_length() const;
		_T0 operator[](double n) const;
#ifndef LEAN_CXX_LIB
		_T0& operator[](double n) {
			return __builtin_cheerp_make_regular<_T0>(this, 0)[static_cast<int>(n)];
		}
#endif
	public:
		using client::Object::operator[];
	};
	using Partial = Object;
	using Required = Object;
	using Readonly = Object;
	using Pick = Object;
	using Record = Object;
	using Exclude = Object;
	using Extract = Object;
	using Omit = Object;
	template<class _T0>
	using NonNullable = _T0;
	using Parameters = Object;
	using ConstructorParameters = Object;
	using ReturnType = Object;
	using InstanceType = Object;
	using Uppercase = _Any;
	using Lowercase = _Any;
	using Capitalize = _Any;
	using Uncapitalize = _Any;
	template<class _T0>
	class ThisType: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	};
	class WeakKeyTypes: public Object {
	public:
		Object* get_object();
		void set_object(Object* object);
	};
	using WeakKey = Object;
	using ArrayBufferLike = _Any;
	class DataViewConstructor: public Object {
	public:
		DataView* get_prototype();
	};
	class AbortSignal;
	class EventListenerOptions: public Object {
	public:
		bool get_capture();
		void set_capture(bool capture);
	};
	class AddEventListenerOptions: public EventListenerOptions {
	public:
		bool get_once();
		void set_once(bool once);
		bool get_passive();
		void set_passive(bool passive);
		AbortSignal* get_signal();
		void set_signal(AbortSignal* signal);
	};
	class Algorithm: public Object {
	public:
		String* get_name();
		void set_name(const String& name);
	};
	class AesCbcParams: public Algorithm {
	public:
		_Union<ArrayBuffer*, ArrayBufferView*>* get_iv();
		void set_iv(const _Union<ArrayBuffer*, ArrayBufferView*>& iv);
	};
	class AesCtrParams: public Algorithm {
	public:
		_Union<ArrayBuffer*, ArrayBufferView*>* get_counter();
		void set_counter(const _Union<ArrayBuffer*, ArrayBufferView*>& counter);
		int get_length() const;
		void set_length(double length);
	};
	class AesDerivedKeyParams: public Algorithm {
	public:
		int get_length() const;
		void set_length(double length);
	};
	class AesGcmParams: public Algorithm {
	public:
		_Union<ArrayBuffer*, ArrayBufferView*>* get_additionalData();
		void set_additionalData(const _Union<ArrayBuffer*, ArrayBufferView*>& additionalData);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_iv();
		void set_iv(const _Union<ArrayBuffer*, ArrayBufferView*>& iv);
		double get_tagLength();
		void set_tagLength(double tagLength);
	};
	class KeyAlgorithm: public Object {
	public:
		String* get_name();
		void set_name(const String& name);
	};
	class AesKeyAlgorithm: public KeyAlgorithm {
	public:
		int get_length() const;
		void set_length(double length);
	};
	class AesKeyGenParams: public Algorithm {
	public:
		int get_length() const;
		void set_length(double length);
	};
	class AudioNodeOptions: public Object {
	public:
		double get_channelCount();
		void set_channelCount(double channelCount);
		String* get_channelCountMode();
		void set_channelCountMode(const String& channelCountMode);
		String* get_channelInterpretation();
		void set_channelInterpretation(const String& channelInterpretation);
	};
	class AnalyserOptions: public AudioNodeOptions {
	public:
		double get_fftSize();
		void set_fftSize(double fftSize);
		double get_maxDecibels();
		void set_maxDecibels(double maxDecibels);
		double get_minDecibels();
		void set_minDecibels(double minDecibels);
		double get_smoothingTimeConstant();
		void set_smoothingTimeConstant(double smoothingTimeConstant);
	};
	class EventInit: public Object {
	public:
		bool get_bubbles();
		void set_bubbles(bool bubbles);
		bool get_cancelable();
		void set_cancelable(bool cancelable);
		bool get_composed();
		void set_composed(bool composed);
	};
	class AnimationEventInit: public EventInit {
	public:
		String* get_animationName();
		void set_animationName(const String& animationName);
		double get_elapsedTime();
		void set_elapsedTime(double elapsedTime);
		String* get_pseudoElement();
		void set_pseudoElement(const String& pseudoElement);
	};
	class CSSNumericValue;
	class AnimationPlaybackEventInit: public EventInit {
	public:
		_Union<double, CSSNumericValue*>* get_currentTime();
		void set_currentTime(const _Union<double, CSSNumericValue*>& currentTime);
		_Union<double, CSSNumericValue*>* get_timelineTime();
		void set_timelineTime(const _Union<double, CSSNumericValue*>& timelineTime);
	};
	class AssignedNodesOptions: public Object {
	public:
		bool get_flatten();
		void set_flatten(bool flatten);
	};
	class AudioBufferOptions: public Object {
	public:
		int get_length() const;
		void set_length(double length);
		double get_numberOfChannels();
		void set_numberOfChannels(double numberOfChannels);
		double get_sampleRate();
		void set_sampleRate(double sampleRate);
	};
	class AudioBuffer;
	class AudioBufferSourceOptions: public Object {
	public:
		AudioBuffer* get_buffer();
		void set_buffer(AudioBuffer* buffer);
		double get_detune();
		void set_detune(double detune);
		bool get_loop();
		void set_loop(bool loop);
		double get_loopEnd();
		void set_loopEnd(double loopEnd);
		double get_loopStart();
		void set_loopStart(double loopStart);
		double get_playbackRate();
		void set_playbackRate(double playbackRate);
	};
	class AudioConfiguration: public Object {
	public:
		double get_bitrate();
		void set_bitrate(double bitrate);
		String* get_channels();
		void set_channels(const String& channels);
		String* get_contentType();
		void set_contentType(const String& contentType);
		double get_samplerate();
		void set_samplerate(double samplerate);
		bool get_spatialRendering();
		void set_spatialRendering(bool spatialRendering);
	};
	class AudioContextOptions: public Object {
	public:
		_Union<double, String*>* get_latencyHint();
		void set_latencyHint(const String& latencyHint);
		void set_latencyHint(double latencyHint);
		double get_sampleRate();
		void set_sampleRate(double sampleRate);
	};
	class AudioProcessingEventInit: public EventInit {
	public:
		AudioBuffer* get_inputBuffer();
		void set_inputBuffer(AudioBuffer* inputBuffer);
		AudioBuffer* get_outputBuffer();
		void set_outputBuffer(AudioBuffer* outputBuffer);
		double get_playbackTime();
		void set_playbackTime(double playbackTime);
	};
	class AudioTimestamp: public Object {
	public:
		double get_contextTime();
		void set_contextTime(double contextTime);
		double get_performanceTime();
		void set_performanceTime(double performanceTime);
	};
	class AudioWorkletNodeOptions: public AudioNodeOptions {
	public:
		double get_numberOfInputs();
		void set_numberOfInputs(double numberOfInputs);
		double get_numberOfOutputs();
		void set_numberOfOutputs(double numberOfOutputs);
		TArray<double>* get_outputChannelCount();
		void set_outputChannelCount(TArray<double>* outputChannelCount);
		Object* get_parameterData();
		void set_parameterData(Object* parameterData);
		Object* get_processorOptions();
		void set_processorOptions(const _Any& processorOptions);
	};
	class AuthenticationExtensionsClientInputs: public Object {
	public:
		String* get_appid();
		void set_appid(const String& appid);
		bool get_credProps();
		void set_credProps(bool credProps);
		bool get_hmacCreateSecret();
		void set_hmacCreateSecret(bool hmacCreateSecret);
	};
	class CredentialPropertiesOutput;
	class AuthenticationExtensionsClientOutputs: public Object {
	public:
		bool get_appid();
		void set_appid(bool appid);
		CredentialPropertiesOutput* get_credProps();
		void set_credProps(CredentialPropertiesOutput* credProps);
		bool get_hmacCreateSecret();
		void set_hmacCreateSecret(bool hmacCreateSecret);
	};
	class AuthenticatorSelectionCriteria: public Object {
	public:
		String* get_authenticatorAttachment();
		void set_authenticatorAttachment(const String& authenticatorAttachment);
		bool get_requireResidentKey();
		void set_requireResidentKey(bool requireResidentKey);
		String* get_residentKey();
		void set_residentKey(const String& residentKey);
		String* get_userVerification();
		void set_userVerification(const String& userVerification);
	};
	class AvcEncoderConfig: public Object {
	public:
		String* get_format();
		void set_format(const String& format);
	};
	class BiquadFilterOptions: public AudioNodeOptions {
	public:
		double get_Q();
		void set_Q(double Q);
		double get_detune();
		void set_detune(double detune);
		double get_frequency();
		void set_frequency(double frequency);
		double get_gain();
		void set_gain(double gain);
		String* get_type();
		void set_type(const String& type);
	};
	class Blob;
	class BlobEventInit: public Object {
	public:
		Blob* get_data();
		void set_data(Blob* data);
		double get_timecode();
		void set_timecode(double timecode);
	};
	class BlobPropertyBag: public Object {
	public:
		String* get_endings();
		void set_endings(const String& endings);
		String* get_type();
		void set_type(const String& type);
	};
	class CSSMatrixComponentOptions: public Object {
	public:
		bool get_is2D();
		void set_is2D(bool is2D);
	};
	class CSSNumericType: public Object {
	public:
		double get_angle();
		void set_angle(double angle);
		double get_flex();
		void set_flex(double flex);
		double get_frequency();
		void set_frequency(double frequency);
		int get_length() const;
		void set_length(double length);
		double get_percent();
		void set_percent(double percent);
		String* get_percentHint();
		void set_percentHint(const String& percentHint);
		double get_resolution();
		void set_resolution(double resolution);
		double get_time();
		void set_time(double time);
	};
	class MediaList;
	class CSSStyleSheetInit: public Object {
	public:
		String* get_baseURL();
		void set_baseURL(const String& baseURL);
		bool get_disabled();
		void set_disabled(bool disabled);
		_Union<String*, MediaList*>* get_media();
		void set_media(const String& media);
		void set_media(MediaList* media);
	};
	class CacheQueryOptions: public Object {
	public:
		bool get_ignoreMethod();
		void set_ignoreMethod(bool ignoreMethod);
		bool get_ignoreSearch();
		void set_ignoreSearch(bool ignoreSearch);
		bool get_ignoreVary();
		void set_ignoreVary(bool ignoreVary);
	};
	class CanvasRenderingContext2DSettings: public Object {
	public:
		bool get_alpha();
		void set_alpha(bool alpha);
		String* get_colorSpace();
		void set_colorSpace(const String& colorSpace);
		bool get_desynchronized();
		void set_desynchronized(bool desynchronized);
		bool get_willReadFrequently();
		void set_willReadFrequently(bool willReadFrequently);
	};
	class ChannelMergerOptions: public AudioNodeOptions {
	public:
		double get_numberOfInputs();
		void set_numberOfInputs(double numberOfInputs);
	};
	class ChannelSplitterOptions: public AudioNodeOptions {
	public:
		double get_numberOfOutputs();
		void set_numberOfOutputs(double numberOfOutputs);
	};
	class CheckVisibilityOptions: public Object {
	public:
		bool get_checkOpacity();
		void set_checkOpacity(bool checkOpacity);
		bool get_checkVisibilityCSS();
		void set_checkVisibilityCSS(bool checkVisibilityCSS);
	};
	class ClientQueryOptions: public Object {
	public:
		bool get_includeUncontrolled();
		void set_includeUncontrolled(bool includeUncontrolled);
		String* get_type();
		void set_type(const String& type);
	};
	class DataTransfer;
	class ClipboardEventInit: public EventInit {
	public:
		DataTransfer* get_clipboardData();
		void set_clipboardData(DataTransfer* clipboardData);
	};
	class ClipboardItemOptions: public Object {
	public:
		String* get_presentationStyle();
		void set_presentationStyle(const String& presentationStyle);
	};
	class CloseEventInit: public EventInit {
	public:
		double get_code();
		void set_code(double code);
		String* get_reason();
		void set_reason(const String& reason);
		bool get_wasClean();
		void set_wasClean(bool wasClean);
	};
	class Window;
	class UIEventInit: public EventInit {
	public:
		double get_detail();
		void set_detail(double detail);
		Window* get_view();
		void set_view(Window* view);
		double get_which();
		void set_which(double which);
	};
	class CompositionEventInit: public UIEventInit {
	public:
		String* get_data();
		void set_data(const String& data);
	};
	class EffectTiming: public Object {
	public:
		double get_delay();
		void set_delay(double delay);
		String* get_direction();
		void set_direction(const String& direction);
		_Union<String*, double, CSSNumericValue*>* get_duration();
		void set_duration(const String& duration);
		void set_duration(const _Union<double, CSSNumericValue*>& duration);
		String* get_easing();
		void set_easing(const String& easing);
		double get_endDelay();
		void set_endDelay(double endDelay);
		String* get_fill();
		void set_fill(const String& fill);
		double get_iterationStart();
		void set_iterationStart(double iterationStart);
		double get_iterations();
		void set_iterations(double iterations);
		double get_playbackRate();
		void set_playbackRate(double playbackRate);
	};
	class ComputedEffectTiming: public EffectTiming {
	public:
		_Union<double, CSSNumericValue*>* get_activeDuration();
		void set_activeDuration(const _Union<double, CSSNumericValue*>& activeDuration);
		double get_currentIteration();
		void set_currentIteration(double currentIteration);
		_Union<double, CSSNumericValue*>* get_endTime();
		void set_endTime(const _Union<double, CSSNumericValue*>& endTime);
		_Union<double, CSSNumericValue*>* get_localTime();
		void set_localTime(const _Union<double, CSSNumericValue*>& localTime);
		double get_progress();
		void set_progress(double progress);
		_Union<double, CSSNumericValue*>* get_startTime();
		void set_startTime(const _Union<double, CSSNumericValue*>& startTime);
	};
	class ComputedKeyframe: public Object {
	public:
		String* get_composite();
		void set_composite(const String& composite);
		double get_computedOffset();
		void set_computedOffset(double computedOffset);
		String* get_easing();
		void set_easing(const String& easing);
		double get_offset();
		void set_offset(double offset);
		_Union<String*, double>* operator[](const String& property) const;
	public:
		using client::Object::operator[];
	};
	class ConstantSourceOptions: public Object {
	public:
		double get_offset();
		void set_offset(double offset);
	};
	class ConstrainBooleanParameters: public Object {
	public:
		bool get_exact();
		void set_exact(bool exact);
		bool get_ideal();
		void set_ideal(bool ideal);
	};
	class ConstrainDOMStringParameters: public Object {
	public:
		_Union<String*, TArray<String*>*>* get_exact();
		void set_exact(const String& exact);
		void set_exact(TArray<String*>* exact);
		_Union<String*, TArray<String*>*>* get_ideal();
		void set_ideal(const String& ideal);
		void set_ideal(TArray<String*>* ideal);
	};
	class DoubleRange: public Object {
	public:
		double get_max();
		void set_max(double max);
		double get_min();
		void set_min(double min);
	};
	class ConstrainDoubleRange: public DoubleRange {
	public:
		double get_exact();
		void set_exact(double exact);
		double get_ideal();
		void set_ideal(double ideal);
	};
	class ULongRange: public Object {
	public:
		double get_max();
		void set_max(double max);
		double get_min();
		void set_min(double min);
	};
	class ConstrainULongRange: public ULongRange {
	public:
		double get_exact();
		void set_exact(double exact);
		double get_ideal();
		void set_ideal(double ideal);
	};
	class ConvolverOptions: public AudioNodeOptions {
	public:
		AudioBuffer* get_buffer();
		void set_buffer(AudioBuffer* buffer);
		bool get_disableNormalization();
		void set_disableNormalization(bool disableNormalization);
	};
	class PublicKeyCredentialCreationOptions;
	class CredentialCreationOptions: public Object {
	public:
		PublicKeyCredentialCreationOptions* get_publicKey();
		void set_publicKey(PublicKeyCredentialCreationOptions* publicKey);
		AbortSignal* get_signal();
		void set_signal(AbortSignal* signal);
	};
	class CredentialPropertiesOutput: public Object {
	public:
		bool get_rk();
		void set_rk(bool rk);
	};
	class PublicKeyCredentialRequestOptions;
	class CredentialRequestOptions: public Object {
	public:
		String* get_mediation();
		void set_mediation(const String& mediation);
		PublicKeyCredentialRequestOptions* get_publicKey();
		void set_publicKey(PublicKeyCredentialRequestOptions* publicKey);
		AbortSignal* get_signal();
		void set_signal(AbortSignal* signal);
	};
	class CryptoKey;
	class CryptoKeyPair: public Object {
	public:
		CryptoKey* get_privateKey();
		void set_privateKey(CryptoKey* privateKey);
		CryptoKey* get_publicKey();
		void set_publicKey(CryptoKey* publicKey);
	};
	template<class _T0>
	class CustomEventInit: public EventInit {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_T0 get_detail();
		void set_detail(_T0 detail);
	};
	class DOMMatrix2DInit: public Object {
	public:
		double get_a();
		void set_a(double a);
		double get_b();
		void set_b(double b);
		double get_c();
		void set_c(double c);
		double get_d();
		void set_d(double d);
		double get_e();
		void set_e(double e);
		double get_f();
		void set_f(double f);
		double get_m11();
		void set_m11(double m11);
		double get_m12();
		void set_m12(double m12);
		double get_m21();
		void set_m21(double m21);
		double get_m22();
		void set_m22(double m22);
		double get_m41();
		void set_m41(double m41);
		double get_m42();
		void set_m42(double m42);
	};
	class DOMMatrixInit: public DOMMatrix2DInit {
	public:
		bool get_is2D();
		void set_is2D(bool is2D);
		double get_m13();
		void set_m13(double m13);
		double get_m14();
		void set_m14(double m14);
		double get_m23();
		void set_m23(double m23);
		double get_m24();
		void set_m24(double m24);
		double get_m31();
		void set_m31(double m31);
		double get_m32();
		void set_m32(double m32);
		double get_m33();
		void set_m33(double m33);
		double get_m34();
		void set_m34(double m34);
		double get_m43();
		void set_m43(double m43);
		double get_m44();
		void set_m44(double m44);
	};
	class DOMPointInit: public Object {
	public:
		double get_w();
		void set_w(double w);
		double get_x();
		void set_x(double x);
		double get_y();
		void set_y(double y);
		double get_z();
		void set_z(double z);
	};
	class DOMQuadInit: public Object {
	public:
		DOMPointInit* get_p1();
		void set_p1(DOMPointInit* p1);
		DOMPointInit* get_p2();
		void set_p2(DOMPointInit* p2);
		DOMPointInit* get_p3();
		void set_p3(DOMPointInit* p3);
		DOMPointInit* get_p4();
		void set_p4(DOMPointInit* p4);
	};
	class DOMRectInit: public Object {
	public:
		double get_height();
		void set_height(double height);
		double get_width();
		void set_width(double width);
		double get_x();
		void set_x(double x);
		double get_y();
		void set_y(double y);
	};
	class DelayOptions: public AudioNodeOptions {
	public:
		double get_delayTime();
		void set_delayTime(double delayTime);
		double get_maxDelayTime();
		void set_maxDelayTime(double maxDelayTime);
	};
	class DeviceMotionEventAccelerationInit: public Object {
	public:
		double get_x();
		void set_x(double x);
		double get_y();
		void set_y(double y);
		double get_z();
		void set_z(double z);
	};
	class DeviceMotionEventRotationRateInit;
	class DeviceMotionEventInit: public EventInit {
	public:
		DeviceMotionEventAccelerationInit* get_acceleration();
		void set_acceleration(DeviceMotionEventAccelerationInit* acceleration);
		DeviceMotionEventAccelerationInit* get_accelerationIncludingGravity();
		void set_accelerationIncludingGravity(DeviceMotionEventAccelerationInit* accelerationIncludingGravity);
		double get_interval();
		void set_interval(double interval);
		DeviceMotionEventRotationRateInit* get_rotationRate();
		void set_rotationRate(DeviceMotionEventRotationRateInit* rotationRate);
	};
	class DeviceMotionEventRotationRateInit: public Object {
	public:
		double get_alpha();
		void set_alpha(double alpha);
		double get_beta();
		void set_beta(double beta);
		double get_gamma();
		void set_gamma(double gamma);
	};
	class DeviceOrientationEventInit: public EventInit {
	public:
		bool get_absolute();
		void set_absolute(bool absolute);
		double get_alpha();
		void set_alpha(double alpha);
		double get_beta();
		void set_beta(double beta);
		double get_gamma();
		void set_gamma(double gamma);
	};
	class MediaTrackConstraints;
	class DisplayMediaStreamOptions: public Object {
	public:
		_Union<bool, MediaTrackConstraints*>* get_audio();
		void set_audio(const _Union<bool, MediaTrackConstraints*>& audio);
		_Union<bool, MediaTrackConstraints*>* get_video();
		void set_video(const _Union<bool, MediaTrackConstraints*>& video);
	};
	class DocumentTimelineOptions: public Object {
	public:
		double get_originTime();
		void set_originTime(double originTime);
	};
	class EventTarget;
	class EventModifierInit: public UIEventInit {
	public:
		bool get_altKey();
		void set_altKey(bool altKey);
		bool get_ctrlKey();
		void set_ctrlKey(bool ctrlKey);
		bool get_metaKey();
		void set_metaKey(bool metaKey);
		bool get_modifierAltGraph();
		void set_modifierAltGraph(bool modifierAltGraph);
		bool get_modifierCapsLock();
		void set_modifierCapsLock(bool modifierCapsLock);
		bool get_modifierFn();
		void set_modifierFn(bool modifierFn);
		bool get_modifierFnLock();
		void set_modifierFnLock(bool modifierFnLock);
		bool get_modifierHyper();
		void set_modifierHyper(bool modifierHyper);
		bool get_modifierNumLock();
		void set_modifierNumLock(bool modifierNumLock);
		bool get_modifierScrollLock();
		void set_modifierScrollLock(bool modifierScrollLock);
		bool get_modifierSuper();
		void set_modifierSuper(bool modifierSuper);
		bool get_modifierSymbol();
		void set_modifierSymbol(bool modifierSymbol);
		bool get_modifierSymbolLock();
		void set_modifierSymbolLock(bool modifierSymbolLock);
		bool get_shiftKey();
		void set_shiftKey(bool shiftKey);
	};
	class MouseEventInit: public EventModifierInit {
	public:
		double get_button();
		void set_button(double button);
		double get_buttons();
		void set_buttons(double buttons);
		double get_clientX();
		void set_clientX(double clientX);
		double get_clientY();
		void set_clientY(double clientY);
		double get_movementX();
		void set_movementX(double movementX);
		double get_movementY();
		void set_movementY(double movementY);
		EventTarget* get_relatedTarget();
		void set_relatedTarget(EventTarget* relatedTarget);
		double get_screenX();
		void set_screenX(double screenX);
		double get_screenY();
		void set_screenY(double screenY);
	};
	class DragEventInit: public MouseEventInit {
	public:
		DataTransfer* get_dataTransfer();
		void set_dataTransfer(DataTransfer* dataTransfer);
	};
	class DynamicsCompressorOptions: public AudioNodeOptions {
	public:
		double get_attack();
		void set_attack(double attack);
		double get_knee();
		void set_knee(double knee);
		double get_ratio();
		void set_ratio(double ratio);
		double get_release();
		void set_release(double release);
		double get_threshold();
		void set_threshold(double threshold);
	};
	class EcKeyAlgorithm: public KeyAlgorithm {
	public:
		String* get_namedCurve();
		void set_namedCurve(const String& namedCurve);
	};
	class EcKeyGenParams: public Algorithm {
	public:
		String* get_namedCurve();
		void set_namedCurve(const String& namedCurve);
	};
	class EcKeyImportParams: public Algorithm {
	public:
		String* get_namedCurve();
		void set_namedCurve(const String& namedCurve);
	};
	class EcdhKeyDeriveParams: public Algorithm {
	public:
		[[cheerp::interface_name(("get_public"))]]
		CryptoKey* get_public_();
		[[cheerp::interface_name(("set_public"))]]
		void set_public_(CryptoKey* public_);
	};
	class EcdsaParams: public Algorithm {
	public:
		_Union<String*, Algorithm*>* get_hash();
		void set_hash(const String& hash);
		void set_hash(Algorithm* hash);
	};
	class ElementCreationOptions: public Object {
	public:
		String* get_is();
		void set_is(const String& is);
	};
	class ElementDefinitionOptions: public Object {
	public:
		String* get_extends();
		void set_extends(const String& extends);
	};
	class EncodedVideoChunkInit: public Object {
	public:
		_Union<ArrayBuffer*, ArrayBufferView*>* get_data();
		void set_data(const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		double get_duration();
		void set_duration(double duration);
		double get_timestamp();
		void set_timestamp(double timestamp);
		String* get_type();
		void set_type(const String& type);
	};
	class VideoDecoderConfig;
	class EncodedVideoChunkMetadata: public Object {
	public:
		VideoDecoderConfig* get_decoderConfig();
		void set_decoderConfig(VideoDecoderConfig* decoderConfig);
	};
	class ErrorEventInit: public EventInit {
	public:
		double get_colno();
		void set_colno(double colno);
		Object* get_error();
		void set_error(const _Any& error);
		String* get_filename();
		void set_filename(const String& filename);
		double get_lineno();
		void set_lineno(double lineno);
		String* get_message();
		void set_message(const String& message);
	};
	class EventSourceInit: public Object {
	public:
		bool get_withCredentials();
		void set_withCredentials(bool withCredentials);
	};
	class FilePropertyBag: public BlobPropertyBag {
	public:
		double get_lastModified();
		void set_lastModified(double lastModified);
	};
	class FileSystemCreateWritableOptions: public Object {
	public:
		bool get_keepExistingData();
		void set_keepExistingData(bool keepExistingData);
	};
	class FileSystemFlags: public Object {
	public:
		bool get_create();
		void set_create(bool create);
		bool get_exclusive();
		void set_exclusive(bool exclusive);
	};
	class FileSystemGetDirectoryOptions: public Object {
	public:
		bool get_create();
		void set_create(bool create);
	};
	class FileSystemGetFileOptions: public Object {
	public:
		bool get_create();
		void set_create(bool create);
	};
	class FileSystemRemoveOptions: public Object {
	public:
		bool get_recursive();
		void set_recursive(bool recursive);
	};
	class FocusEventInit: public UIEventInit {
	public:
		EventTarget* get_relatedTarget();
		void set_relatedTarget(EventTarget* relatedTarget);
	};
	class FocusOptions: public Object {
	public:
		bool get_preventScroll();
		void set_preventScroll(bool preventScroll);
	};
	class FontFaceDescriptors: public Object {
	public:
		String* get_ascentOverride();
		void set_ascentOverride(const String& ascentOverride);
		String* get_descentOverride();
		void set_descentOverride(const String& descentOverride);
		String* get_display();
		void set_display(const String& display);
		String* get_featureSettings();
		void set_featureSettings(const String& featureSettings);
		String* get_lineGapOverride();
		void set_lineGapOverride(const String& lineGapOverride);
		String* get_stretch();
		void set_stretch(const String& stretch);
		String* get_style();
		void set_style(const String& style);
		String* get_unicodeRange();
		void set_unicodeRange(const String& unicodeRange);
		String* get_variant();
		void set_variant(const String& variant);
		String* get_weight();
		void set_weight(const String& weight);
	};
	class FontFace;
	class FontFaceSetLoadEventInit: public EventInit {
	public:
		TArray<FontFace*>* get_fontfaces();
		void set_fontfaces(TArray<FontFace*>* fontfaces);
	};
	class FormData;
	class FormDataEventInit: public EventInit {
	public:
		FormData* get_formData();
		void set_formData(FormData* formData);
	};
	class FullscreenOptions: public Object {
	public:
		String* get_navigationUI();
		void set_navigationUI(const String& navigationUI);
	};
	class GainOptions: public AudioNodeOptions {
	public:
		double get_gain();
		void set_gain(double gain);
	};
	class GamepadEffectParameters: public Object {
	public:
		double get_duration();
		void set_duration(double duration);
		double get_startDelay();
		void set_startDelay(double startDelay);
		double get_strongMagnitude();
		void set_strongMagnitude(double strongMagnitude);
		double get_weakMagnitude();
		void set_weakMagnitude(double weakMagnitude);
	};
	class Gamepad;
	class GamepadEventInit: public EventInit {
	public:
		Gamepad* get_gamepad();
		void set_gamepad(Gamepad* gamepad);
	};
	class GetAnimationsOptions: public Object {
	public:
		bool get_subtree();
		void set_subtree(bool subtree);
	};
	class GetNotificationOptions: public Object {
	public:
		String* get_tag();
		void set_tag(const String& tag);
	};
	class GetRootNodeOptions: public Object {
	public:
		bool get_composed();
		void set_composed(bool composed);
	};
	class HashChangeEventInit: public EventInit {
	public:
		String* get_newURL();
		void set_newURL(const String& newURL);
		String* get_oldURL();
		void set_oldURL(const String& oldURL);
	};
	class HkdfParams: public Algorithm {
	public:
		_Union<String*, Algorithm*>* get_hash();
		void set_hash(const String& hash);
		void set_hash(Algorithm* hash);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_info();
		void set_info(const _Union<ArrayBuffer*, ArrayBufferView*>& info);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_salt();
		void set_salt(const _Union<ArrayBuffer*, ArrayBufferView*>& salt);
	};
	class HmacImportParams: public Algorithm {
	public:
		_Union<String*, Algorithm*>* get_hash();
		void set_hash(const String& hash);
		void set_hash(Algorithm* hash);
		int get_length() const;
		void set_length(double length);
	};
	class HmacKeyAlgorithm: public KeyAlgorithm {
	public:
		KeyAlgorithm* get_hash();
		void set_hash(KeyAlgorithm* hash);
		int get_length() const;
		void set_length(double length);
	};
	class HmacKeyGenParams: public Algorithm {
	public:
		_Union<String*, Algorithm*>* get_hash();
		void set_hash(const String& hash);
		void set_hash(Algorithm* hash);
		int get_length() const;
		void set_length(double length);
	};
	class IDBDatabaseInfo: public Object {
	public:
		String* get_name();
		void set_name(const String& name);
		double get_version();
		void set_version(double version);
	};
	class IDBIndexParameters: public Object {
	public:
		bool get_multiEntry();
		void set_multiEntry(bool multiEntry);
		bool get_unique();
		void set_unique(bool unique);
	};
	class IDBObjectStoreParameters: public Object {
	public:
		bool get_autoIncrement();
		void set_autoIncrement(bool autoIncrement);
		_Union<String*, TArray<String*>*>* get_keyPath();
		void set_keyPath(const String& keyPath);
		void set_keyPath(TArray<String*>* keyPath);
	};
	class IDBTransactionOptions: public Object {
	public:
		String* get_durability();
		void set_durability(const String& durability);
	};
	class IDBVersionChangeEventInit: public EventInit {
	public:
		double get_newVersion();
		void set_newVersion(double newVersion);
		double get_oldVersion();
		void set_oldVersion(double oldVersion);
	};
	class IIRFilterOptions: public AudioNodeOptions {
	public:
		TArray<double>* get_feedback();
		void set_feedback(TArray<double>* feedback);
		TArray<double>* get_feedforward();
		void set_feedforward(TArray<double>* feedforward);
	};
	class IdleRequestOptions: public Object {
	public:
		double get_timeout();
		void set_timeout(double timeout);
	};
	class ImageBitmapOptions: public Object {
	public:
		String* get_colorSpaceConversion();
		void set_colorSpaceConversion(const String& colorSpaceConversion);
		String* get_imageOrientation();
		void set_imageOrientation(const String& imageOrientation);
		String* get_premultiplyAlpha();
		void set_premultiplyAlpha(const String& premultiplyAlpha);
		double get_resizeHeight();
		void set_resizeHeight(double resizeHeight);
		String* get_resizeQuality();
		void set_resizeQuality(const String& resizeQuality);
		double get_resizeWidth();
		void set_resizeWidth(double resizeWidth);
	};
	class ImageBitmapRenderingContextSettings: public Object {
	public:
		bool get_alpha();
		void set_alpha(bool alpha);
	};
	class ImageDataSettings: public Object {
	public:
		String* get_colorSpace();
		void set_colorSpace(const String& colorSpace);
	};
	class ImageEncodeOptions: public Object {
	public:
		double get_quality();
		void set_quality(double quality);
		String* get_type();
		void set_type(const String& type);
	};
	class StaticRange;
	class InputEventInit: public UIEventInit {
	public:
		String* get_data();
		void set_data(const String& data);
		DataTransfer* get_dataTransfer();
		void set_dataTransfer(DataTransfer* dataTransfer);
		String* get_inputType();
		void set_inputType(const String& inputType);
		bool get_isComposing();
		void set_isComposing(bool isComposing);
		TArray<StaticRange*>* get_targetRanges();
		void set_targetRanges(TArray<StaticRange*>* targetRanges);
	};
	class Element;
	class IntersectionObserverEntryInit: public Object {
	public:
		DOMRectInit* get_boundingClientRect();
		void set_boundingClientRect(DOMRectInit* boundingClientRect);
		double get_intersectionRatio();
		void set_intersectionRatio(double intersectionRatio);
		DOMRectInit* get_intersectionRect();
		void set_intersectionRect(DOMRectInit* intersectionRect);
		bool get_isIntersecting();
		void set_isIntersecting(bool isIntersecting);
		DOMRectInit* get_rootBounds();
		void set_rootBounds(DOMRectInit* rootBounds);
		Element* get_target();
		void set_target(Element* target);
		double get_time();
		void set_time(double time);
	};
	class Document;
	class IntersectionObserverInit: public Object {
	public:
		_Union<Document*, Element*>* get_root();
		void set_root(const _Union<Document*, Element*>& root);
		String* get_rootMargin();
		void set_rootMargin(const String& rootMargin);
		_Union<double, TArray<double>*>* get_threshold();
		void set_threshold(const _Union<double, TArray<double>*>& threshold);
	};
	class RsaOtherPrimesInfo;
	class JsonWebKey: public Object {
	public:
		String* get_alg();
		void set_alg(const String& alg);
		String* get_crv();
		void set_crv(const String& crv);
		String* get_d();
		void set_d(const String& d);
		String* get_dp();
		void set_dp(const String& dp);
		String* get_dq();
		void set_dq(const String& dq);
		String* get_e();
		void set_e(const String& e);
		bool get_ext();
		void set_ext(bool ext);
		String* get_k();
		void set_k(const String& k);
		TArray<String*>* get_key_ops();
		void set_key_ops(TArray<String*>* key_ops);
		String* get_kty();
		void set_kty(const String& kty);
		String* get_n();
		void set_n(const String& n);
		TArray<RsaOtherPrimesInfo*>* get_oth();
		void set_oth(TArray<RsaOtherPrimesInfo*>* oth);
		String* get_p();
		void set_p(const String& p);
		String* get_q();
		void set_q(const String& q);
		String* get_qi();
		void set_qi(const String& qi);
		String* get_use();
		void set_use(const String& use);
		String* get_x();
		void set_x(const String& x);
		String* get_y();
		void set_y(const String& y);
	};
	class KeyboardEventInit: public EventModifierInit {
	public:
		double get_charCode();
		void set_charCode(double charCode);
		String* get_code();
		void set_code(const String& code);
		bool get_isComposing();
		void set_isComposing(bool isComposing);
		String* get_key();
		void set_key(const String& key);
		double get_keyCode();
		void set_keyCode(double keyCode);
		double get_location();
		void set_location(double location);
		bool get_repeat();
		void set_repeat(bool repeat);
	};
	class Keyframe: public Object {
	public:
		String* get_composite();
		void set_composite(const String& composite);
		String* get_easing();
		void set_easing(const String& easing);
		double get_offset();
		void set_offset(double offset);
		_Union<String*, double>* operator[](const String& property) const;
	public:
		using client::Object::operator[];
	};
	class AnimationTimeline;
	class KeyframeEffectOptions: public EffectTiming {
	public:
		String* get_composite();
		void set_composite(const String& composite);
		String* get_iterationComposite();
		void set_iterationComposite(const String& iterationComposite);
		String* get_pseudoElement();
		void set_pseudoElement(const String& pseudoElement);
	};
	class KeyframeAnimationOptions: public KeyframeEffectOptions {
	public:
		String* get_id();
		void set_id(const String& id);
		AnimationTimeline* get_timeline();
		void set_timeline(AnimationTimeline* timeline);
	};
	class LockInfo: public Object {
	public:
		String* get_clientId();
		void set_clientId(const String& clientId);
		String* get_mode();
		void set_mode(const String& mode);
		String* get_name();
		void set_name(const String& name);
	};
	class LockManagerSnapshot: public Object {
	public:
		TArray<LockInfo*>* get_held();
		void set_held(TArray<LockInfo*>* held);
		TArray<LockInfo*>* get_pending();
		void set_pending(TArray<LockInfo*>* pending);
	};
	class LockOptions: public Object {
	public:
		bool get_ifAvailable();
		void set_ifAvailable(bool ifAvailable);
		String* get_mode();
		void set_mode(const String& mode);
		AbortSignal* get_signal();
		void set_signal(AbortSignal* signal);
		bool get_steal();
		void set_steal(bool steal);
	};
	class MIDIPort;
	class MIDIConnectionEventInit: public EventInit {
	public:
		MIDIPort* get_port();
		void set_port(MIDIPort* port);
	};
	class MIDIMessageEventInit: public EventInit {
	public:
		Uint8Array* get_data();
		void set_data(Uint8Array* data);
	};
	class MIDIOptions: public Object {
	public:
		bool get_software();
		void set_software(bool software);
		bool get_sysex();
		void set_sysex(bool sysex);
	};
	class MediaDecodingConfiguration;
	class MediaCapabilitiesInfo: public Object {
	public:
		bool get_powerEfficient();
		void set_powerEfficient(bool powerEfficient);
		bool get_smooth();
		void set_smooth(bool smooth);
		bool get_supported();
		void set_supported(bool supported);
	};
	class MediaCapabilitiesDecodingInfo: public MediaCapabilitiesInfo {
	public:
		MediaDecodingConfiguration* get_configuration();
		void set_configuration(MediaDecodingConfiguration* configuration);
	};
	class MediaEncodingConfiguration;
	class MediaCapabilitiesEncodingInfo: public MediaCapabilitiesInfo {
	public:
		MediaEncodingConfiguration* get_configuration();
		void set_configuration(MediaEncodingConfiguration* configuration);
	};
	class VideoConfiguration;
	class MediaConfiguration: public Object {
	public:
		AudioConfiguration* get_audio();
		void set_audio(AudioConfiguration* audio);
		VideoConfiguration* get_video();
		void set_video(VideoConfiguration* video);
	};
	class MediaDecodingConfiguration: public MediaConfiguration {
	public:
		String* get_type();
		void set_type(const String& type);
	};
	class HTMLMediaElement;
	class MediaElementAudioSourceOptions: public Object {
	public:
		HTMLMediaElement* get_mediaElement();
		void set_mediaElement(HTMLMediaElement* mediaElement);
	};
	class MediaEncodingConfiguration: public MediaConfiguration {
	public:
		String* get_type();
		void set_type(const String& type);
	};
	class MediaEncryptedEventInit: public EventInit {
	public:
		ArrayBuffer* get_initData();
		void set_initData(ArrayBuffer* initData);
		String* get_initDataType();
		void set_initDataType(const String& initDataType);
	};
	class MediaImage: public Object {
	public:
		String* get_sizes();
		void set_sizes(const String& sizes);
		String* get_src();
		void set_src(const String& src);
		String* get_type();
		void set_type(const String& type);
	};
	class MediaKeyMessageEventInit: public EventInit {
	public:
		ArrayBuffer* get_message();
		void set_message(ArrayBuffer* message);
		String* get_messageType();
		void set_messageType(const String& messageType);
	};
	class MediaKeySystemMediaCapability;
	class MediaKeySystemConfiguration: public Object {
	public:
		TArray<MediaKeySystemMediaCapability*>* get_audioCapabilities();
		void set_audioCapabilities(TArray<MediaKeySystemMediaCapability*>* audioCapabilities);
		String* get_distinctiveIdentifier();
		void set_distinctiveIdentifier(const String& distinctiveIdentifier);
		TArray<String*>* get_initDataTypes();
		void set_initDataTypes(TArray<String*>* initDataTypes);
		String* get_label();
		void set_label(const String& label);
		String* get_persistentState();
		void set_persistentState(const String& persistentState);
		TArray<String*>* get_sessionTypes();
		void set_sessionTypes(TArray<String*>* sessionTypes);
		TArray<MediaKeySystemMediaCapability*>* get_videoCapabilities();
		void set_videoCapabilities(TArray<MediaKeySystemMediaCapability*>* videoCapabilities);
	};
	class MediaKeySystemMediaCapability: public Object {
	public:
		String* get_contentType();
		void set_contentType(const String& contentType);
		String* get_encryptionScheme();
		void set_encryptionScheme(const String& encryptionScheme);
		String* get_robustness();
		void set_robustness(const String& robustness);
	};
	class MediaMetadataInit: public Object {
	public:
		String* get_album();
		void set_album(const String& album);
		String* get_artist();
		void set_artist(const String& artist);
		TArray<MediaImage*>* get_artwork();
		void set_artwork(TArray<MediaImage*>* artwork);
		String* get_title();
		void set_title(const String& title);
	};
	class MediaPositionState: public Object {
	public:
		double get_duration();
		void set_duration(double duration);
		double get_playbackRate();
		void set_playbackRate(double playbackRate);
		double get_position();
		void set_position(double position);
	};
	class MediaQueryListEventInit: public EventInit {
	public:
		bool get_matches();
		void set_matches(bool matches);
		String* get_media();
		void set_media(const String& media);
	};
	class MediaRecorderOptions: public Object {
	public:
		double get_audioBitsPerSecond();
		void set_audioBitsPerSecond(double audioBitsPerSecond);
		double get_bitsPerSecond();
		void set_bitsPerSecond(double bitsPerSecond);
		String* get_mimeType();
		void set_mimeType(const String& mimeType);
		double get_videoBitsPerSecond();
		void set_videoBitsPerSecond(double videoBitsPerSecond);
	};
	class MediaSessionActionDetails: public Object {
	public:
		String* get_action();
		void set_action(const String& action);
		bool get_fastSeek();
		void set_fastSeek(bool fastSeek);
		double get_seekOffset();
		void set_seekOffset(double seekOffset);
		double get_seekTime();
		void set_seekTime(double seekTime);
	};
	class MediaStream;
	class MediaStreamAudioSourceOptions: public Object {
	public:
		MediaStream* get_mediaStream();
		void set_mediaStream(MediaStream* mediaStream);
	};
	class MediaStreamConstraints: public Object {
	public:
		_Union<bool, MediaTrackConstraints*>* get_audio();
		void set_audio(const _Union<bool, MediaTrackConstraints*>& audio);
		String* get_peerIdentity();
		void set_peerIdentity(const String& peerIdentity);
		bool get_preferCurrentTab();
		void set_preferCurrentTab(bool preferCurrentTab);
		_Union<bool, MediaTrackConstraints*>* get_video();
		void set_video(const _Union<bool, MediaTrackConstraints*>& video);
	};
	class MediaStreamTrack;
	class MediaStreamTrackEventInit: public EventInit {
	public:
		MediaStreamTrack* get_track();
		void set_track(MediaStreamTrack* track);
	};
	class MediaTrackCapabilities: public Object {
	public:
		DoubleRange* get_aspectRatio();
		void set_aspectRatio(DoubleRange* aspectRatio);
		TArray<bool>* get_autoGainControl();
		void set_autoGainControl(TArray<bool>* autoGainControl);
		ULongRange* get_channelCount();
		void set_channelCount(ULongRange* channelCount);
		String* get_deviceId();
		void set_deviceId(const String& deviceId);
		String* get_displaySurface();
		void set_displaySurface(const String& displaySurface);
		TArray<bool>* get_echoCancellation();
		void set_echoCancellation(TArray<bool>* echoCancellation);
		TArray<String*>* get_facingMode();
		void set_facingMode(TArray<String*>* facingMode);
		DoubleRange* get_frameRate();
		void set_frameRate(DoubleRange* frameRate);
		String* get_groupId();
		void set_groupId(const String& groupId);
		ULongRange* get_height();
		void set_height(ULongRange* height);
		TArray<bool>* get_noiseSuppression();
		void set_noiseSuppression(TArray<bool>* noiseSuppression);
		ULongRange* get_sampleRate();
		void set_sampleRate(ULongRange* sampleRate);
		ULongRange* get_sampleSize();
		void set_sampleSize(ULongRange* sampleSize);
		ULongRange* get_width();
		void set_width(ULongRange* width);
	};
	class MediaTrackConstraintSet: public Object {
	public:
		_Union<double, ConstrainDoubleRange*>* get_aspectRatio();
		void set_aspectRatio(const _Union<double, ConstrainDoubleRange*>& aspectRatio);
		_Union<bool, ConstrainBooleanParameters*>* get_autoGainControl();
		void set_autoGainControl(const _Union<bool, ConstrainBooleanParameters*>& autoGainControl);
		_Union<double, ConstrainULongRange*>* get_channelCount();
		void set_channelCount(const _Union<double, ConstrainULongRange*>& channelCount);
		_Union<String*, ConstrainDOMStringParameters*, TArray<String*>*>* get_deviceId();
		void set_deviceId(const String& deviceId);
		void set_deviceId(const _Union<ConstrainDOMStringParameters*, TArray<String*>*>& deviceId);
		_Union<String*, ConstrainDOMStringParameters*, TArray<String*>*>* get_displaySurface();
		void set_displaySurface(const String& displaySurface);
		void set_displaySurface(const _Union<ConstrainDOMStringParameters*, TArray<String*>*>& displaySurface);
		_Union<bool, ConstrainBooleanParameters*>* get_echoCancellation();
		void set_echoCancellation(const _Union<bool, ConstrainBooleanParameters*>& echoCancellation);
		_Union<String*, ConstrainDOMStringParameters*, TArray<String*>*>* get_facingMode();
		void set_facingMode(const String& facingMode);
		void set_facingMode(const _Union<ConstrainDOMStringParameters*, TArray<String*>*>& facingMode);
		_Union<double, ConstrainDoubleRange*>* get_frameRate();
		void set_frameRate(const _Union<double, ConstrainDoubleRange*>& frameRate);
		_Union<String*, ConstrainDOMStringParameters*, TArray<String*>*>* get_groupId();
		void set_groupId(const String& groupId);
		void set_groupId(const _Union<ConstrainDOMStringParameters*, TArray<String*>*>& groupId);
		_Union<double, ConstrainULongRange*>* get_height();
		void set_height(const _Union<double, ConstrainULongRange*>& height);
		_Union<bool, ConstrainBooleanParameters*>* get_noiseSuppression();
		void set_noiseSuppression(const _Union<bool, ConstrainBooleanParameters*>& noiseSuppression);
		_Union<double, ConstrainULongRange*>* get_sampleRate();
		void set_sampleRate(const _Union<double, ConstrainULongRange*>& sampleRate);
		_Union<double, ConstrainULongRange*>* get_sampleSize();
		void set_sampleSize(const _Union<double, ConstrainULongRange*>& sampleSize);
		_Union<double, ConstrainULongRange*>* get_width();
		void set_width(const _Union<double, ConstrainULongRange*>& width);
	};
	class MediaTrackConstraints: public MediaTrackConstraintSet {
	public:
		TArray<MediaTrackConstraintSet*>* get_advanced();
		void set_advanced(TArray<MediaTrackConstraintSet*>* advanced);
	};
	class MediaTrackSettings: public Object {
	public:
		double get_aspectRatio();
		void set_aspectRatio(double aspectRatio);
		bool get_autoGainControl();
		void set_autoGainControl(bool autoGainControl);
		double get_channelCount();
		void set_channelCount(double channelCount);
		String* get_deviceId();
		void set_deviceId(const String& deviceId);
		String* get_displaySurface();
		void set_displaySurface(const String& displaySurface);
		bool get_echoCancellation();
		void set_echoCancellation(bool echoCancellation);
		String* get_facingMode();
		void set_facingMode(const String& facingMode);
		double get_frameRate();
		void set_frameRate(double frameRate);
		String* get_groupId();
		void set_groupId(const String& groupId);
		double get_height();
		void set_height(double height);
		bool get_noiseSuppression();
		void set_noiseSuppression(bool noiseSuppression);
		double get_sampleRate();
		void set_sampleRate(double sampleRate);
		double get_sampleSize();
		void set_sampleSize(double sampleSize);
		double get_width();
		void set_width(double width);
	};
	class MediaTrackSupportedConstraints: public Object {
	public:
		bool get_aspectRatio();
		void set_aspectRatio(bool aspectRatio);
		bool get_autoGainControl();
		void set_autoGainControl(bool autoGainControl);
		bool get_channelCount();
		void set_channelCount(bool channelCount);
		bool get_deviceId();
		void set_deviceId(bool deviceId);
		bool get_displaySurface();
		void set_displaySurface(bool displaySurface);
		bool get_echoCancellation();
		void set_echoCancellation(bool echoCancellation);
		bool get_facingMode();
		void set_facingMode(bool facingMode);
		bool get_frameRate();
		void set_frameRate(bool frameRate);
		bool get_groupId();
		void set_groupId(bool groupId);
		bool get_height();
		void set_height(bool height);
		bool get_noiseSuppression();
		void set_noiseSuppression(bool noiseSuppression);
		bool get_sampleRate();
		void set_sampleRate(bool sampleRate);
		bool get_sampleSize();
		void set_sampleSize(bool sampleSize);
		bool get_width();
		void set_width(bool width);
	};
	class MessagePort;
	class ServiceWorker;
	template<class _T0>
	class MessageEventInit: public EventInit {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_T0 get_data();
		void set_data(_T0 data);
		String* get_lastEventId();
		void set_lastEventId(const String& lastEventId);
		String* get_origin();
		void set_origin(const String& origin);
		TArray<MessagePort*>* get_ports();
		void set_ports(TArray<MessagePort*>* ports);
		_Union<MessagePort*, ServiceWorker*, Window*>* get_source();
		void set_source(const _Union<MessagePort*, ServiceWorker*, Window*>& source);
	};
	class MultiCacheQueryOptions: public CacheQueryOptions {
	public:
		String* get_cacheName();
		void set_cacheName(const String& cacheName);
	};
	class MutationObserverInit: public Object {
	public:
		TArray<String*>* get_attributeFilter();
		void set_attributeFilter(TArray<String*>* attributeFilter);
		bool get_attributeOldValue();
		void set_attributeOldValue(bool attributeOldValue);
		bool get_attributes();
		void set_attributes(bool attributes);
		bool get_characterData();
		void set_characterData(bool characterData);
		bool get_characterDataOldValue();
		void set_characterDataOldValue(bool characterDataOldValue);
		bool get_childList();
		void set_childList(bool childList);
		bool get_subtree();
		void set_subtree(bool subtree);
	};
	class NavigationPreloadState: public Object {
	public:
		bool get_enabled();
		void set_enabled(bool enabled);
		String* get_headerValue();
		void set_headerValue(const String& headerValue);
	};
	class NotificationAction: public Object {
	public:
		String* get_action();
		void set_action(const String& action);
		String* get_icon();
		void set_icon(const String& icon);
		String* get_title();
		void set_title(const String& title);
	};
	class NotificationOptions: public Object {
	public:
		TArray<NotificationAction*>* get_actions();
		void set_actions(TArray<NotificationAction*>* actions);
		String* get_badge();
		void set_badge(const String& badge);
		String* get_body();
		void set_body(const String& body);
		Object* get_data();
		void set_data(const _Any& data);
		String* get_dir();
		void set_dir(const String& dir);
		String* get_icon();
		void set_icon(const String& icon);
		String* get_image();
		void set_image(const String& image);
		String* get_lang();
		void set_lang(const String& lang);
		bool get_renotify();
		void set_renotify(bool renotify);
		bool get_requireInteraction();
		void set_requireInteraction(bool requireInteraction);
		bool get_silent();
		void set_silent(bool silent);
		String* get_tag();
		void set_tag(const String& tag);
		double get_timestamp();
		void set_timestamp(double timestamp);
		_Union<double, TArray<double>*>* get_vibrate();
		void set_vibrate(const _Union<double, TArray<double>*>& vibrate);
	};
	class OfflineAudioCompletionEventInit: public EventInit {
	public:
		AudioBuffer* get_renderedBuffer();
		void set_renderedBuffer(AudioBuffer* renderedBuffer);
	};
	class OfflineAudioContextOptions: public Object {
	public:
		int get_length() const;
		void set_length(double length);
		double get_numberOfChannels();
		void set_numberOfChannels(double numberOfChannels);
		double get_sampleRate();
		void set_sampleRate(double sampleRate);
	};
	class OptionalEffectTiming: public Object {
	public:
		double get_delay();
		void set_delay(double delay);
		String* get_direction();
		void set_direction(const String& direction);
		_Union<String*, double>* get_duration();
		void set_duration(const String& duration);
		void set_duration(double duration);
		String* get_easing();
		void set_easing(const String& easing);
		double get_endDelay();
		void set_endDelay(double endDelay);
		String* get_fill();
		void set_fill(const String& fill);
		double get_iterationStart();
		void set_iterationStart(double iterationStart);
		double get_iterations();
		void set_iterations(double iterations);
		double get_playbackRate();
		void set_playbackRate(double playbackRate);
	};
	class PeriodicWave;
	class OscillatorOptions: public AudioNodeOptions {
	public:
		double get_detune();
		void set_detune(double detune);
		double get_frequency();
		void set_frequency(double frequency);
		PeriodicWave* get_periodicWave();
		void set_periodicWave(PeriodicWave* periodicWave);
		String* get_type();
		void set_type(const String& type);
	};
	class PageTransitionEventInit: public EventInit {
	public:
		bool get_persisted();
		void set_persisted(bool persisted);
	};
	class PannerOptions: public AudioNodeOptions {
	public:
		double get_coneInnerAngle();
		void set_coneInnerAngle(double coneInnerAngle);
		double get_coneOuterAngle();
		void set_coneOuterAngle(double coneOuterAngle);
		double get_coneOuterGain();
		void set_coneOuterGain(double coneOuterGain);
		String* get_distanceModel();
		void set_distanceModel(const String& distanceModel);
		double get_maxDistance();
		void set_maxDistance(double maxDistance);
		double get_orientationX();
		void set_orientationX(double orientationX);
		double get_orientationY();
		void set_orientationY(double orientationY);
		double get_orientationZ();
		void set_orientationZ(double orientationZ);
		String* get_panningModel();
		void set_panningModel(const String& panningModel);
		double get_positionX();
		void set_positionX(double positionX);
		double get_positionY();
		void set_positionY(double positionY);
		double get_positionZ();
		void set_positionZ(double positionZ);
		double get_refDistance();
		void set_refDistance(double refDistance);
		double get_rolloffFactor();
		void set_rolloffFactor(double rolloffFactor);
	};
	class PaymentCurrencyAmount: public Object {
	public:
		String* get_currency();
		void set_currency(const String& currency);
		String* get_value();
		void set_value(const String& value);
	};
	class PaymentItem;
	class PaymentDetailsModifier;
	class PaymentDetailsBase: public Object {
	public:
		TArray<PaymentItem*>* get_displayItems();
		void set_displayItems(TArray<PaymentItem*>* displayItems);
		TArray<PaymentDetailsModifier*>* get_modifiers();
		void set_modifiers(TArray<PaymentDetailsModifier*>* modifiers);
	};
	class PaymentDetailsInit: public PaymentDetailsBase {
	public:
		String* get_id();
		void set_id(const String& id);
		PaymentItem* get_total();
		void set_total(PaymentItem* total);
	};
	class PaymentDetailsModifier: public Object {
	public:
		TArray<PaymentItem*>* get_additionalDisplayItems();
		void set_additionalDisplayItems(TArray<PaymentItem*>* additionalDisplayItems);
		Object* get_data();
		void set_data(const _Any& data);
		String* get_supportedMethods();
		void set_supportedMethods(const String& supportedMethods);
		PaymentItem* get_total();
		void set_total(PaymentItem* total);
	};
	class PaymentDetailsUpdate: public PaymentDetailsBase {
	public:
		Object* get_paymentMethodErrors();
		void set_paymentMethodErrors(const _Any& paymentMethodErrors);
		PaymentItem* get_total();
		void set_total(PaymentItem* total);
	};
	class PaymentItem: public Object {
	public:
		PaymentCurrencyAmount* get_amount();
		void set_amount(PaymentCurrencyAmount* amount);
		String* get_label();
		void set_label(const String& label);
		bool get_pending();
		void set_pending(bool pending);
	};
	class PaymentRequestUpdateEventInit: public EventInit {
	};
	class PaymentMethodChangeEventInit: public PaymentRequestUpdateEventInit {
	public:
		Object* get_methodDetails();
		void set_methodDetails(const _Any& methodDetails);
		String* get_methodName();
		void set_methodName(const String& methodName);
	};
	class PaymentMethodData: public Object {
	public:
		Object* get_data();
		void set_data(const _Any& data);
		String* get_supportedMethods();
		void set_supportedMethods(const String& supportedMethods);
	};
	class PaymentValidationErrors: public Object {
	public:
		String* get_error();
		void set_error(const String& error);
		Object* get_paymentMethod();
		void set_paymentMethod(const _Any& paymentMethod);
	};
	class Pbkdf2Params: public Algorithm {
	public:
		_Union<String*, Algorithm*>* get_hash();
		void set_hash(const String& hash);
		void set_hash(Algorithm* hash);
		double get_iterations();
		void set_iterations(double iterations);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_salt();
		void set_salt(const _Union<ArrayBuffer*, ArrayBufferView*>& salt);
	};
	class PerformanceMarkOptions: public Object {
	public:
		Object* get_detail();
		void set_detail(const _Any& detail);
		double get_startTime();
		void set_startTime(double startTime);
	};
	class PerformanceMeasureOptions: public Object {
	public:
		Object* get_detail();
		void set_detail(const _Any& detail);
		double get_duration();
		void set_duration(double duration);
		_Union<String*, double>* get_end();
		void set_end(const String& end);
		void set_end(double end);
		_Union<String*, double>* get_start();
		void set_start(const String& start);
		void set_start(double start);
	};
	class PerformanceObserverInit: public Object {
	public:
		bool get_buffered();
		void set_buffered(bool buffered);
		TArray<String*>* get_entryTypes();
		void set_entryTypes(TArray<String*>* entryTypes);
		String* get_type();
		void set_type(const String& type);
	};
	class PeriodicWaveConstraints: public Object {
	public:
		bool get_disableNormalization();
		void set_disableNormalization(bool disableNormalization);
	};
	class PeriodicWaveOptions: public PeriodicWaveConstraints {
	public:
		_Union<Float32Array*, TArray<double>*>* get_imag();
		void set_imag(const _Union<Float32Array*, TArray<double>*>& imag);
		_Union<Float32Array*, TArray<double>*>* get_real();
		void set_real(const _Union<Float32Array*, TArray<double>*>& real);
	};
	class PermissionDescriptor: public Object {
	public:
		String* get_name();
		void set_name(const String& name);
	};
	class PictureInPictureWindow;
	class PictureInPictureEventInit: public EventInit {
	public:
		PictureInPictureWindow* get_pictureInPictureWindow();
		void set_pictureInPictureWindow(PictureInPictureWindow* pictureInPictureWindow);
	};
	class PlaneLayout: public Object {
	public:
		double get_offset();
		void set_offset(double offset);
		double get_stride();
		void set_stride(double stride);
	};
	class PointerEvent;
	class PointerEventInit: public MouseEventInit {
	public:
		TArray<PointerEvent*>* get_coalescedEvents();
		void set_coalescedEvents(TArray<PointerEvent*>* coalescedEvents);
		double get_height();
		void set_height(double height);
		bool get_isPrimary();
		void set_isPrimary(bool isPrimary);
		double get_pointerId();
		void set_pointerId(double pointerId);
		String* get_pointerType();
		void set_pointerType(const String& pointerType);
		TArray<PointerEvent*>* get_predictedEvents();
		void set_predictedEvents(TArray<PointerEvent*>* predictedEvents);
		double get_pressure();
		void set_pressure(double pressure);
		double get_tangentialPressure();
		void set_tangentialPressure(double tangentialPressure);
		double get_tiltX();
		void set_tiltX(double tiltX);
		double get_tiltY();
		void set_tiltY(double tiltY);
		double get_twist();
		void set_twist(double twist);
		double get_width();
		void set_width(double width);
	};
	class PopStateEventInit: public EventInit {
	public:
		Object* get_state();
		void set_state(const _Any& state);
	};
	class PositionOptions: public Object {
	public:
		bool get_enableHighAccuracy();
		void set_enableHighAccuracy(bool enableHighAccuracy);
		double get_maximumAge();
		void set_maximumAge(double maximumAge);
		double get_timeout();
		void set_timeout(double timeout);
	};
	class ProgressEventInit: public EventInit {
	public:
		bool get_lengthComputable();
		void set_lengthComputable(bool lengthComputable);
		double get_loaded();
		void set_loaded(double loaded);
		double get_total();
		void set_total(double total);
	};
	class PromiseRejectionEventInit: public EventInit {
	public:
		Promise<_Any*>* get_promise();
		void set_promise(Promise<_Any*>* promise);
		Object* get_reason();
		void set_reason(const _Any& reason);
	};
	class PropertyDefinition: public Object {
	public:
		bool get_inherits();
		void set_inherits(bool inherits);
		String* get_initialValue();
		void set_initialValue(const String& initialValue);
		String* get_name();
		void set_name(const String& name);
		String* get_syntax();
		void set_syntax(const String& syntax);
	};
	class PropertyIndexedKeyframes: public Object {
	public:
		_Union<String*, TArray<String*>*>* get_composite();
		void set_composite(const String& composite);
		void set_composite(TArray<String*>* composite);
		_Union<String*, TArray<String*>*>* get_easing();
		void set_easing(const String& easing);
		void set_easing(TArray<String*>* easing);
		_Union<double, TArray<double>*>* get_offset();
		void set_offset(const _Union<double, TArray<double>*>& offset);
		_Union<String*, double, TArray<String*>*, TArray<double>*>* operator[](const String& property) const;
	public:
		using client::Object::operator[];
	};
	class PublicKeyCredentialDescriptor;
	class PublicKeyCredentialParameters;
	class PublicKeyCredentialRpEntity;
	class PublicKeyCredentialUserEntity;
	class PublicKeyCredentialCreationOptions: public Object {
	public:
		String* get_attestation();
		void set_attestation(const String& attestation);
		AuthenticatorSelectionCriteria* get_authenticatorSelection();
		void set_authenticatorSelection(AuthenticatorSelectionCriteria* authenticatorSelection);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_challenge();
		void set_challenge(const _Union<ArrayBuffer*, ArrayBufferView*>& challenge);
		TArray<PublicKeyCredentialDescriptor*>* get_excludeCredentials();
		void set_excludeCredentials(TArray<PublicKeyCredentialDescriptor*>* excludeCredentials);
		AuthenticationExtensionsClientInputs* get_extensions();
		void set_extensions(AuthenticationExtensionsClientInputs* extensions);
		TArray<PublicKeyCredentialParameters*>* get_pubKeyCredParams();
		void set_pubKeyCredParams(TArray<PublicKeyCredentialParameters*>* pubKeyCredParams);
		PublicKeyCredentialRpEntity* get_rp();
		void set_rp(PublicKeyCredentialRpEntity* rp);
		double get_timeout();
		void set_timeout(double timeout);
		PublicKeyCredentialUserEntity* get_user();
		void set_user(PublicKeyCredentialUserEntity* user);
	};
	class PublicKeyCredentialDescriptor: public Object {
	public:
		_Union<ArrayBuffer*, ArrayBufferView*>* get_id();
		void set_id(const _Union<ArrayBuffer*, ArrayBufferView*>& id);
		TArray<String*>* get_transports();
		void set_transports(TArray<String*>* transports);
		String* get_type();
		void set_type(const String& type);
	};
	class PublicKeyCredentialEntity: public Object {
	public:
		String* get_name();
		void set_name(const String& name);
	};
	class PublicKeyCredentialParameters: public Object {
	public:
		double get_alg();
		void set_alg(double alg);
		String* get_type();
		void set_type(const String& type);
	};
	class PublicKeyCredentialRequestOptions: public Object {
	public:
		TArray<PublicKeyCredentialDescriptor*>* get_allowCredentials();
		void set_allowCredentials(TArray<PublicKeyCredentialDescriptor*>* allowCredentials);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_challenge();
		void set_challenge(const _Union<ArrayBuffer*, ArrayBufferView*>& challenge);
		AuthenticationExtensionsClientInputs* get_extensions();
		void set_extensions(AuthenticationExtensionsClientInputs* extensions);
		String* get_rpId();
		void set_rpId(const String& rpId);
		double get_timeout();
		void set_timeout(double timeout);
		String* get_userVerification();
		void set_userVerification(const String& userVerification);
	};
	class PublicKeyCredentialRpEntity: public PublicKeyCredentialEntity {
	public:
		String* get_id();
		void set_id(const String& id);
	};
	class PublicKeyCredentialUserEntity: public PublicKeyCredentialEntity {
	public:
		String* get_displayName();
		void set_displayName(const String& displayName);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_id();
		void set_id(const _Union<ArrayBuffer*, ArrayBufferView*>& id);
	};
	class PushSubscriptionJSON: public Object {
	public:
		String* get_endpoint();
		void set_endpoint(const String& endpoint);
		double get_expirationTime();
		void set_expirationTime(double expirationTime);
		Object* get_keys();
		void set_keys(Object* keys);
	};
	class PushSubscriptionOptionsInit: public Object {
	public:
		_Union<String*, ArrayBuffer*, ArrayBufferView*>* get_applicationServerKey();
		void set_applicationServerKey(const String& applicationServerKey);
		void set_applicationServerKey(const _Union<ArrayBuffer*, ArrayBufferView*>& applicationServerKey);
		bool get_userVisibleOnly();
		void set_userVisibleOnly(bool userVisibleOnly);
	};
	template<class _T0>
	class QueuingStrategy: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		double get_highWaterMark();
		void set_highWaterMark(double highWaterMark);
		int get_size() const;
		void set_size(EventListener* size);
		void set_size(const _Function<double(_Any*)>& size);
	};
	class QueuingStrategyInit: public Object {
	public:
		double get_highWaterMark();
		void set_highWaterMark(double highWaterMark);
	};
	class RTCOfferAnswerOptions: public Object {
	};
	class RTCAnswerOptions: public RTCOfferAnswerOptions {
	};
	class RTCCertificateExpiration: public Object {
	public:
		double get_expires();
		void set_expires(double expires);
	};
	class RTCCertificate;
	class RTCIceServer;
	class RTCConfiguration: public Object {
	public:
		String* get_bundlePolicy();
		void set_bundlePolicy(const String& bundlePolicy);
		TArray<RTCCertificate*>* get_certificates();
		void set_certificates(TArray<RTCCertificate*>* certificates);
		double get_iceCandidatePoolSize();
		void set_iceCandidatePoolSize(double iceCandidatePoolSize);
		TArray<RTCIceServer*>* get_iceServers();
		void set_iceServers(TArray<RTCIceServer*>* iceServers);
		String* get_iceTransportPolicy();
		void set_iceTransportPolicy(const String& iceTransportPolicy);
		String* get_rtcpMuxPolicy();
		void set_rtcpMuxPolicy(const String& rtcpMuxPolicy);
	};
	class RTCDTMFToneChangeEventInit: public EventInit {
	public:
		String* get_tone();
		void set_tone(const String& tone);
	};
	class RTCDataChannel;
	class RTCDataChannelEventInit: public EventInit {
	public:
		RTCDataChannel* get_channel();
		void set_channel(RTCDataChannel* channel);
	};
	class RTCDataChannelInit: public Object {
	public:
		double get_id();
		void set_id(double id);
		double get_maxPacketLifeTime();
		void set_maxPacketLifeTime(double maxPacketLifeTime);
		double get_maxRetransmits();
		void set_maxRetransmits(double maxRetransmits);
		bool get_negotiated();
		void set_negotiated(bool negotiated);
		bool get_ordered();
		void set_ordered(bool ordered);
		String* get_protocol();
		void set_protocol(const String& protocol);
	};
	class RTCDtlsFingerprint: public Object {
	public:
		String* get_algorithm();
		void set_algorithm(const String& algorithm);
		String* get_value();
		void set_value(const String& value);
	};
	class RTCEncodedAudioFrameMetadata: public Object {
	public:
		TArray<double>* get_contributingSources();
		void set_contributingSources(TArray<double>* contributingSources);
		double get_synchronizationSource();
		void set_synchronizationSource(double synchronizationSource);
	};
	class RTCEncodedVideoFrameMetadata: public Object {
	public:
		TArray<double>* get_dependencies();
		void set_dependencies(TArray<double>* dependencies);
		double get_frameId();
		void set_frameId(double frameId);
		double get_height();
		void set_height(double height);
		double get_spatialIndex();
		void set_spatialIndex(double spatialIndex);
		double get_synchronizationSource();
		void set_synchronizationSource(double synchronizationSource);
		double get_temporalIndex();
		void set_temporalIndex(double temporalIndex);
		double get_width();
		void set_width(double width);
	};
	class RTCError;
	class RTCErrorEventInit: public EventInit {
	public:
		RTCError* get_error();
		void set_error(RTCError* error);
	};
	class RTCErrorInit: public Object {
	public:
		String* get_errorDetail();
		void set_errorDetail(const String& errorDetail);
		double get_httpRequestStatusCode();
		void set_httpRequestStatusCode(double httpRequestStatusCode);
		double get_receivedAlert();
		void set_receivedAlert(double receivedAlert);
		double get_sctpCauseCode();
		void set_sctpCauseCode(double sctpCauseCode);
		double get_sdpLineNumber();
		void set_sdpLineNumber(double sdpLineNumber);
		double get_sentAlert();
		void set_sentAlert(double sentAlert);
	};
	class RTCIceCandidateInit: public Object {
	public:
		String* get_candidate();
		void set_candidate(const String& candidate);
		double get_sdpMLineIndex();
		void set_sdpMLineIndex(double sdpMLineIndex);
		String* get_sdpMid();
		void set_sdpMid(const String& sdpMid);
		String* get_usernameFragment();
		void set_usernameFragment(const String& usernameFragment);
	};
	class RTCIceCandidate;
	class RTCIceCandidatePair: public Object {
	public:
		RTCIceCandidate* get_local();
		void set_local(RTCIceCandidate* local);
		RTCIceCandidate* get_remote();
		void set_remote(RTCIceCandidate* remote);
	};
	class RTCStats: public Object {
	public:
		String* get_id();
		void set_id(const String& id);
		double get_timestamp();
		void set_timestamp(double timestamp);
		String* get_type();
		void set_type(const String& type);
	};
	class RTCIceCandidatePairStats: public RTCStats {
	public:
		double get_availableIncomingBitrate();
		void set_availableIncomingBitrate(double availableIncomingBitrate);
		double get_availableOutgoingBitrate();
		void set_availableOutgoingBitrate(double availableOutgoingBitrate);
		double get_bytesReceived();
		void set_bytesReceived(double bytesReceived);
		double get_bytesSent();
		void set_bytesSent(double bytesSent);
		double get_currentRoundTripTime();
		void set_currentRoundTripTime(double currentRoundTripTime);
		double get_lastPacketReceivedTimestamp();
		void set_lastPacketReceivedTimestamp(double lastPacketReceivedTimestamp);
		double get_lastPacketSentTimestamp();
		void set_lastPacketSentTimestamp(double lastPacketSentTimestamp);
		String* get_localCandidateId();
		void set_localCandidateId(const String& localCandidateId);
		bool get_nominated();
		void set_nominated(bool nominated);
		String* get_remoteCandidateId();
		void set_remoteCandidateId(const String& remoteCandidateId);
		double get_requestsReceived();
		void set_requestsReceived(double requestsReceived);
		double get_requestsSent();
		void set_requestsSent(double requestsSent);
		double get_responsesReceived();
		void set_responsesReceived(double responsesReceived);
		double get_responsesSent();
		void set_responsesSent(double responsesSent);
		String* get_state();
		void set_state(const String& state);
		double get_totalRoundTripTime();
		void set_totalRoundTripTime(double totalRoundTripTime);
		String* get_transportId();
		void set_transportId(const String& transportId);
	};
	class RTCIceServer: public Object {
	public:
		String* get_credential();
		void set_credential(const String& credential);
		_Union<String*, TArray<String*>*>* get_urls();
		void set_urls(const String& urls);
		void set_urls(TArray<String*>* urls);
		String* get_username();
		void set_username(const String& username);
	};
	class RTCRtpStreamStats: public RTCStats {
	public:
		String* get_codecId();
		void set_codecId(const String& codecId);
		String* get_kind();
		void set_kind(const String& kind);
		double get_ssrc();
		void set_ssrc(double ssrc);
		String* get_transportId();
		void set_transportId(const String& transportId);
	};
	class RTCReceivedRtpStreamStats: public RTCRtpStreamStats {
	public:
		double get_jitter();
		void set_jitter(double jitter);
		double get_packetsLost();
		void set_packetsLost(double packetsLost);
		double get_packetsReceived();
		void set_packetsReceived(double packetsReceived);
	};
	class RTCInboundRtpStreamStats: public RTCReceivedRtpStreamStats {
	public:
		double get_audioLevel();
		void set_audioLevel(double audioLevel);
		double get_bytesReceived();
		void set_bytesReceived(double bytesReceived);
		double get_concealedSamples();
		void set_concealedSamples(double concealedSamples);
		double get_concealmentEvents();
		void set_concealmentEvents(double concealmentEvents);
		String* get_decoderImplementation();
		void set_decoderImplementation(const String& decoderImplementation);
		double get_estimatedPlayoutTimestamp();
		void set_estimatedPlayoutTimestamp(double estimatedPlayoutTimestamp);
		double get_fecPacketsDiscarded();
		void set_fecPacketsDiscarded(double fecPacketsDiscarded);
		double get_fecPacketsReceived();
		void set_fecPacketsReceived(double fecPacketsReceived);
		double get_firCount();
		void set_firCount(double firCount);
		double get_frameHeight();
		void set_frameHeight(double frameHeight);
		double get_frameWidth();
		void set_frameWidth(double frameWidth);
		double get_framesDecoded();
		void set_framesDecoded(double framesDecoded);
		double get_framesDropped();
		void set_framesDropped(double framesDropped);
		double get_framesPerSecond();
		void set_framesPerSecond(double framesPerSecond);
		double get_framesReceived();
		void set_framesReceived(double framesReceived);
		double get_headerBytesReceived();
		void set_headerBytesReceived(double headerBytesReceived);
		double get_insertedSamplesForDeceleration();
		void set_insertedSamplesForDeceleration(double insertedSamplesForDeceleration);
		double get_jitterBufferDelay();
		void set_jitterBufferDelay(double jitterBufferDelay);
		double get_jitterBufferEmittedCount();
		void set_jitterBufferEmittedCount(double jitterBufferEmittedCount);
		double get_keyFramesDecoded();
		void set_keyFramesDecoded(double keyFramesDecoded);
		String* get_kind();
		void set_kind(const String& kind);
		double get_lastPacketReceivedTimestamp();
		void set_lastPacketReceivedTimestamp(double lastPacketReceivedTimestamp);
		double get_nackCount();
		void set_nackCount(double nackCount);
		double get_packetsDiscarded();
		void set_packetsDiscarded(double packetsDiscarded);
		double get_pliCount();
		void set_pliCount(double pliCount);
		double get_qpSum();
		void set_qpSum(double qpSum);
		String* get_remoteId();
		void set_remoteId(const String& remoteId);
		double get_removedSamplesForAcceleration();
		void set_removedSamplesForAcceleration(double removedSamplesForAcceleration);
		double get_silentConcealedSamples();
		void set_silentConcealedSamples(double silentConcealedSamples);
		double get_totalAudioEnergy();
		void set_totalAudioEnergy(double totalAudioEnergy);
		double get_totalDecodeTime();
		void set_totalDecodeTime(double totalDecodeTime);
		double get_totalInterFrameDelay();
		void set_totalInterFrameDelay(double totalInterFrameDelay);
		double get_totalProcessingDelay();
		void set_totalProcessingDelay(double totalProcessingDelay);
		double get_totalSamplesDuration();
		void set_totalSamplesDuration(double totalSamplesDuration);
		double get_totalSamplesReceived();
		void set_totalSamplesReceived(double totalSamplesReceived);
		double get_totalSquaredInterFrameDelay();
		void set_totalSquaredInterFrameDelay(double totalSquaredInterFrameDelay);
	};
	class RTCLocalSessionDescriptionInit: public Object {
	public:
		String* get_sdp();
		void set_sdp(const String& sdp);
		String* get_type();
		void set_type(const String& type);
	};
	class RTCOfferOptions: public RTCOfferAnswerOptions {
	public:
		bool get_iceRestart();
		void set_iceRestart(bool iceRestart);
		bool get_offerToReceiveAudio();
		void set_offerToReceiveAudio(bool offerToReceiveAudio);
		bool get_offerToReceiveVideo();
		void set_offerToReceiveVideo(bool offerToReceiveVideo);
	};
	class RTCSentRtpStreamStats: public RTCRtpStreamStats {
	public:
		double get_bytesSent();
		void set_bytesSent(double bytesSent);
		double get_packetsSent();
		void set_packetsSent(double packetsSent);
	};
	class RTCOutboundRtpStreamStats: public RTCSentRtpStreamStats {
	public:
		double get_firCount();
		void set_firCount(double firCount);
		double get_frameHeight();
		void set_frameHeight(double frameHeight);
		double get_frameWidth();
		void set_frameWidth(double frameWidth);
		double get_framesEncoded();
		void set_framesEncoded(double framesEncoded);
		double get_framesPerSecond();
		void set_framesPerSecond(double framesPerSecond);
		double get_framesSent();
		void set_framesSent(double framesSent);
		double get_headerBytesSent();
		void set_headerBytesSent(double headerBytesSent);
		double get_hugeFramesSent();
		void set_hugeFramesSent(double hugeFramesSent);
		double get_keyFramesEncoded();
		void set_keyFramesEncoded(double keyFramesEncoded);
		String* get_mediaSourceId();
		void set_mediaSourceId(const String& mediaSourceId);
		double get_nackCount();
		void set_nackCount(double nackCount);
		double get_pliCount();
		void set_pliCount(double pliCount);
		double get_qpSum();
		void set_qpSum(double qpSum);
		double get_qualityLimitationResolutionChanges();
		void set_qualityLimitationResolutionChanges(double qualityLimitationResolutionChanges);
		String* get_remoteId();
		void set_remoteId(const String& remoteId);
		double get_retransmittedBytesSent();
		void set_retransmittedBytesSent(double retransmittedBytesSent);
		double get_retransmittedPacketsSent();
		void set_retransmittedPacketsSent(double retransmittedPacketsSent);
		String* get_rid();
		void set_rid(const String& rid);
		double get_targetBitrate();
		void set_targetBitrate(double targetBitrate);
		double get_totalEncodeTime();
		void set_totalEncodeTime(double totalEncodeTime);
		double get_totalEncodedBytesTarget();
		void set_totalEncodedBytesTarget(double totalEncodedBytesTarget);
		double get_totalPacketSendDelay();
		void set_totalPacketSendDelay(double totalPacketSendDelay);
	};
	class RTCPeerConnectionIceErrorEventInit: public EventInit {
	public:
		String* get_address();
		void set_address(const String& address);
		double get_errorCode();
		void set_errorCode(double errorCode);
		String* get_errorText();
		void set_errorText(const String& errorText);
		double get_port();
		void set_port(double port);
		String* get_url();
		void set_url(const String& url);
	};
	class RTCPeerConnectionIceEventInit: public EventInit {
	public:
		RTCIceCandidate* get_candidate();
		void set_candidate(RTCIceCandidate* candidate);
		String* get_url();
		void set_url(const String& url);
	};
	class RTCRtcpParameters: public Object {
	public:
		String* get_cname();
		void set_cname(const String& cname);
		bool get_reducedSize();
		void set_reducedSize(bool reducedSize);
	};
	class RTCRtpCodecCapability;
	class RTCRtpHeaderExtensionCapability;
	class RTCRtpCapabilities: public Object {
	public:
		TArray<RTCRtpCodecCapability*>* get_codecs();
		void set_codecs(TArray<RTCRtpCodecCapability*>* codecs);
		TArray<RTCRtpHeaderExtensionCapability*>* get_headerExtensions();
		void set_headerExtensions(TArray<RTCRtpHeaderExtensionCapability*>* headerExtensions);
	};
	class RTCRtpCodec: public Object {
	public:
		double get_channels();
		void set_channels(double channels);
		double get_clockRate();
		void set_clockRate(double clockRate);
		String* get_mimeType();
		void set_mimeType(const String& mimeType);
		String* get_sdpFmtpLine();
		void set_sdpFmtpLine(const String& sdpFmtpLine);
	};
	class RTCRtpCodecCapability: public RTCRtpCodec {
	};
	class RTCRtpCodecParameters: public RTCRtpCodec {
	public:
		double get_payloadType();
		void set_payloadType(double payloadType);
	};
	class RTCRtpCodingParameters: public Object {
	public:
		String* get_rid();
		void set_rid(const String& rid);
	};
	class RTCRtpContributingSource: public Object {
	public:
		double get_audioLevel();
		void set_audioLevel(double audioLevel);
		double get_rtpTimestamp();
		void set_rtpTimestamp(double rtpTimestamp);
		double get_source();
		void set_source(double source);
		double get_timestamp();
		void set_timestamp(double timestamp);
	};
	class RTCRtpEncodingParameters: public RTCRtpCodingParameters {
	public:
		bool get_active();
		void set_active(bool active);
		double get_maxBitrate();
		void set_maxBitrate(double maxBitrate);
		double get_maxFramerate();
		void set_maxFramerate(double maxFramerate);
		String* get_networkPriority();
		void set_networkPriority(const String& networkPriority);
		String* get_priority();
		void set_priority(const String& priority);
		double get_scaleResolutionDownBy();
		void set_scaleResolutionDownBy(double scaleResolutionDownBy);
	};
	class RTCRtpHeaderExtensionCapability: public Object {
	public:
		String* get_uri();
		void set_uri(const String& uri);
	};
	class RTCRtpHeaderExtensionParameters: public Object {
	public:
		bool get_encrypted();
		void set_encrypted(bool encrypted);
		double get_id();
		void set_id(double id);
		String* get_uri();
		void set_uri(const String& uri);
	};
	class RTCRtpParameters: public Object {
	public:
		TArray<RTCRtpCodecParameters*>* get_codecs();
		void set_codecs(TArray<RTCRtpCodecParameters*>* codecs);
		TArray<RTCRtpHeaderExtensionParameters*>* get_headerExtensions();
		void set_headerExtensions(TArray<RTCRtpHeaderExtensionParameters*>* headerExtensions);
		RTCRtcpParameters* get_rtcp();
		void set_rtcp(RTCRtcpParameters* rtcp);
	};
	class RTCRtpReceiveParameters: public RTCRtpParameters {
	};
	class RTCRtpSendParameters: public RTCRtpParameters {
	public:
		String* get_degradationPreference();
		void set_degradationPreference(const String& degradationPreference);
		TArray<RTCRtpEncodingParameters*>* get_encodings();
		void set_encodings(TArray<RTCRtpEncodingParameters*>* encodings);
		String* get_transactionId();
		void set_transactionId(const String& transactionId);
	};
	class RTCRtpSynchronizationSource: public RTCRtpContributingSource {
	};
	class RTCRtpTransceiverInit: public Object {
	public:
		String* get_direction();
		void set_direction(const String& direction);
		TArray<RTCRtpEncodingParameters*>* get_sendEncodings();
		void set_sendEncodings(TArray<RTCRtpEncodingParameters*>* sendEncodings);
		TArray<MediaStream*>* get_streams();
		void set_streams(TArray<MediaStream*>* streams);
	};
	class RTCSessionDescriptionInit: public Object {
	public:
		String* get_sdp();
		void set_sdp(const String& sdp);
		String* get_type();
		void set_type(const String& type);
	};
	class RTCRtpReceiver;
	class RTCRtpTransceiver;
	class RTCTrackEventInit: public EventInit {
	public:
		RTCRtpReceiver* get_receiver();
		void set_receiver(RTCRtpReceiver* receiver);
		TArray<MediaStream*>* get_streams();
		void set_streams(TArray<MediaStream*>* streams);
		MediaStreamTrack* get_track();
		void set_track(MediaStreamTrack* track);
		RTCRtpTransceiver* get_transceiver();
		void set_transceiver(RTCRtpTransceiver* transceiver);
	};
	class RTCTransportStats: public RTCStats {
	public:
		double get_bytesReceived();
		void set_bytesReceived(double bytesReceived);
		double get_bytesSent();
		void set_bytesSent(double bytesSent);
		String* get_dtlsCipher();
		void set_dtlsCipher(const String& dtlsCipher);
		String* get_dtlsState();
		void set_dtlsState(const String& dtlsState);
		String* get_localCertificateId();
		void set_localCertificateId(const String& localCertificateId);
		String* get_remoteCertificateId();
		void set_remoteCertificateId(const String& remoteCertificateId);
		String* get_selectedCandidatePairId();
		void set_selectedCandidatePairId(const String& selectedCandidatePairId);
		String* get_srtpCipher();
		void set_srtpCipher(const String& srtpCipher);
		String* get_tlsVersion();
		void set_tlsVersion(const String& tlsVersion);
	};
	class ReadableStreamGetReaderOptions: public Object {
	public:
		String* get_mode();
		void set_mode(const String& mode);
	};
	template<class _T0>
	class ReadableStreamReadDoneResult: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool get_done();
		void set_done(bool done);
		_T0 get_value();
		void set_value(_T0 value);
	};
	template<class _T0>
	class ReadableStreamReadValueResult: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool get_done();
		void set_done(bool done);
		_T0 get_value();
		void set_value(_T0 value);
	};
	template<class _T0>
	class ReadableStream;
	template<class _T0>
	class WritableStream;
	template<class _T0, class _T1>
	class ReadableWritablePair: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		ReadableStream<_T0>* get_readable();
		void set_readable(ReadableStream<_T0>* readable);
		WritableStream<_T1>* get_writable();
		void set_writable(WritableStream<_T1>* writable);
	};
	class RegistrationOptions: public Object {
	public:
		String* get_scope();
		void set_scope(const String& scope);
		String* get_type();
		void set_type(const String& type);
		String* get_updateViaCache();
		void set_updateViaCache(const String& updateViaCache);
	};
	class ReportingObserverOptions: public Object {
	public:
		bool get_buffered();
		void set_buffered(bool buffered);
		TArray<String*>* get_types();
		void set_types(TArray<String*>* types);
	};
	class URLSearchParams;
	class Headers;
	class RequestInit: public Object {
	public:
		_Union<String*, ArrayBuffer*, ArrayBufferView*, Blob*, FormData*, URLSearchParams*, ReadableStream<_Any*>*>* get_body();
		void set_body(const String& body);
		void set_body(const _Union<ArrayBuffer*, ArrayBufferView*, Blob*, FormData*, URLSearchParams*, ReadableStream<_Any*>*>& body);
		String* get_cache();
		void set_cache(const String& cache);
		String* get_credentials();
		void set_credentials(const String& credentials);
		_Union<Headers*, Object*, TArray<Object*>*>* get_headers();
		void set_headers(const _Union<Headers*, Object*, TArray<Object*>*>& headers);
		String* get_integrity();
		void set_integrity(const String& integrity);
		bool get_keepalive();
		void set_keepalive(bool keepalive);
		String* get_method();
		void set_method(const String& method);
		String* get_mode();
		void set_mode(const String& mode);
		String* get_redirect();
		void set_redirect(const String& redirect);
		String* get_referrer();
		void set_referrer(const String& referrer);
		String* get_referrerPolicy();
		void set_referrerPolicy(const String& referrerPolicy);
		AbortSignal* get_signal();
		void set_signal(AbortSignal* signal);
		Object* get_window();
		void set_window(Object* window);
	};
	class ResizeObserverOptions: public Object {
	public:
		String* get_box();
		void set_box(const String& box);
	};
	class ResponseInit: public Object {
	public:
		_Union<Headers*, Object*, TArray<Object*>*>* get_headers();
		void set_headers(const _Union<Headers*, Object*, TArray<Object*>*>& headers);
		double get_status();
		void set_status(double status);
		String* get_statusText();
		void set_statusText(const String& statusText);
	};
	class RsaHashedImportParams: public Algorithm {
	public:
		_Union<String*, Algorithm*>* get_hash();
		void set_hash(const String& hash);
		void set_hash(Algorithm* hash);
	};
	class RsaKeyAlgorithm: public KeyAlgorithm {
	public:
		double get_modulusLength();
		void set_modulusLength(double modulusLength);
		Uint8Array* get_publicExponent();
		void set_publicExponent(Uint8Array* publicExponent);
	};
	class RsaHashedKeyAlgorithm: public RsaKeyAlgorithm {
	public:
		KeyAlgorithm* get_hash();
		void set_hash(KeyAlgorithm* hash);
	};
	class RsaKeyGenParams: public Algorithm {
	public:
		double get_modulusLength();
		void set_modulusLength(double modulusLength);
		Uint8Array* get_publicExponent();
		void set_publicExponent(Uint8Array* publicExponent);
	};
	class RsaHashedKeyGenParams: public RsaKeyGenParams {
	public:
		_Union<String*, Algorithm*>* get_hash();
		void set_hash(const String& hash);
		void set_hash(Algorithm* hash);
	};
	class RsaOaepParams: public Algorithm {
	public:
		_Union<ArrayBuffer*, ArrayBufferView*>* get_label();
		void set_label(const _Union<ArrayBuffer*, ArrayBufferView*>& label);
	};
	class RsaOtherPrimesInfo: public Object {
	public:
		String* get_d();
		void set_d(const String& d);
		String* get_r();
		void set_r(const String& r);
		String* get_t();
		void set_t(const String& t);
	};
	class RsaPssParams: public Algorithm {
	public:
		double get_saltLength();
		void set_saltLength(double saltLength);
	};
	class SVGBoundingBoxOptions: public Object {
	public:
		bool get_clipped();
		void set_clipped(bool clipped);
		bool get_fill();
		void set_fill(bool fill);
		bool get_markers();
		void set_markers(bool markers);
		bool get_stroke();
		void set_stroke(bool stroke);
	};
	class ScrollOptions: public Object {
	public:
		String* get_behavior();
		void set_behavior(const String& behavior);
	};
	class ScrollIntoViewOptions: public ScrollOptions {
	public:
		String* get_block();
		void set_block(const String& block);
		[[cheerp::interface_name(("get_inline"))]]
		String* get_inline_();
		[[cheerp::interface_name(("set_inline"))]]
		void set_inline_(const String& inline_);
	};
	class ScrollToOptions: public ScrollOptions {
	public:
		double get_left();
		void set_left(double left);
		double get_top();
		void set_top(double top);
	};
	class SecurityPolicyViolationEventInit: public EventInit {
	public:
		String* get_blockedURI();
		void set_blockedURI(const String& blockedURI);
		double get_columnNumber();
		void set_columnNumber(double columnNumber);
		String* get_disposition();
		void set_disposition(const String& disposition);
		String* get_documentURI();
		void set_documentURI(const String& documentURI);
		String* get_effectiveDirective();
		void set_effectiveDirective(const String& effectiveDirective);
		double get_lineNumber();
		void set_lineNumber(double lineNumber);
		String* get_originalPolicy();
		void set_originalPolicy(const String& originalPolicy);
		String* get_referrer();
		void set_referrer(const String& referrer);
		String* get_sample();
		void set_sample(const String& sample);
		String* get_sourceFile();
		void set_sourceFile(const String& sourceFile);
		double get_statusCode();
		void set_statusCode(double statusCode);
		String* get_violatedDirective();
		void set_violatedDirective(const String& violatedDirective);
	};
	class ShadowRootInit: public Object {
	public:
		bool get_delegatesFocus();
		void set_delegatesFocus(bool delegatesFocus);
		String* get_mode();
		void set_mode(const String& mode);
		String* get_slotAssignment();
		void set_slotAssignment(const String& slotAssignment);
	};
	class File;
	class ShareData: public Object {
	public:
		TArray<File*>* get_files();
		void set_files(TArray<File*>* files);
		String* get_text();
		void set_text(const String& text);
		String* get_title();
		void set_title(const String& title);
		String* get_url();
		void set_url(const String& url);
	};
	class SpeechSynthesisUtterance;
	class SpeechSynthesisEventInit: public EventInit {
	public:
		double get_charIndex();
		void set_charIndex(double charIndex);
		double get_charLength();
		void set_charLength(double charLength);
		double get_elapsedTime();
		void set_elapsedTime(double elapsedTime);
		String* get_name();
		void set_name(const String& name);
		SpeechSynthesisUtterance* get_utterance();
		void set_utterance(SpeechSynthesisUtterance* utterance);
	};
	class SpeechSynthesisErrorEventInit: public SpeechSynthesisEventInit {
	public:
		String* get_error();
		void set_error(const String& error);
	};
	class Node;
	class StaticRangeInit: public Object {
	public:
		Node* get_endContainer();
		void set_endContainer(Node* endContainer);
		double get_endOffset();
		void set_endOffset(double endOffset);
		Node* get_startContainer();
		void set_startContainer(Node* startContainer);
		double get_startOffset();
		void set_startOffset(double startOffset);
	};
	class StereoPannerOptions: public AudioNodeOptions {
	public:
		double get_pan();
		void set_pan(double pan);
	};
	class StorageEstimate: public Object {
	public:
		double get_quota();
		void set_quota(double quota);
		double get_usage();
		void set_usage(double usage);
	};
	class Storage;
	class StorageEventInit: public EventInit {
	public:
		String* get_key();
		void set_key(const String& key);
		String* get_newValue();
		void set_newValue(const String& newValue);
		String* get_oldValue();
		void set_oldValue(const String& oldValue);
		Storage* get_storageArea();
		void set_storageArea(Storage* storageArea);
		String* get_url();
		void set_url(const String& url);
	};
	class StreamPipeOptions: public Object {
	public:
		bool get_preventAbort();
		void set_preventAbort(bool preventAbort);
		bool get_preventCancel();
		void set_preventCancel(bool preventCancel);
		bool get_preventClose();
		void set_preventClose(bool preventClose);
		AbortSignal* get_signal();
		void set_signal(AbortSignal* signal);
	};
	class StructuredSerializeOptions: public Object {
	public:
		TArray<_Any*>* get_transfer();
		void set_transfer(Array* transfer);
	};
	class HTMLElement;
	class SubmitEventInit: public EventInit {
	public:
		HTMLElement* get_submitter();
		void set_submitter(HTMLElement* submitter);
	};
	class TextDecodeOptions: public Object {
	public:
		bool get_stream();
		void set_stream(bool stream);
	};
	class TextDecoderOptions: public Object {
	public:
		bool get_fatal();
		void set_fatal(bool fatal);
		bool get_ignoreBOM();
		void set_ignoreBOM(bool ignoreBOM);
	};
	class TextEncoderEncodeIntoResult: public Object {
	public:
		double get_read();
		void set_read(double read);
		double get_written();
		void set_written(double written);
	};
	class ToggleEventInit: public EventInit {
	public:
		String* get_newState();
		void set_newState(const String& newState);
		String* get_oldState();
		void set_oldState(const String& oldState);
	};
	class Touch;
	class TouchEventInit: public EventModifierInit {
	public:
		TArray<Touch*>* get_changedTouches();
		void set_changedTouches(TArray<Touch*>* changedTouches);
		TArray<Touch*>* get_targetTouches();
		void set_targetTouches(TArray<Touch*>* targetTouches);
		TArray<Touch*>* get_touches();
		void set_touches(TArray<Touch*>* touches);
	};
	class TouchInit: public Object {
	public:
		double get_altitudeAngle();
		void set_altitudeAngle(double altitudeAngle);
		double get_azimuthAngle();
		void set_azimuthAngle(double azimuthAngle);
		double get_clientX();
		void set_clientX(double clientX);
		double get_clientY();
		void set_clientY(double clientY);
		double get_force();
		void set_force(double force);
		double get_identifier();
		void set_identifier(double identifier);
		double get_pageX();
		void set_pageX(double pageX);
		double get_pageY();
		void set_pageY(double pageY);
		double get_radiusX();
		void set_radiusX(double radiusX);
		double get_radiusY();
		void set_radiusY(double radiusY);
		double get_rotationAngle();
		void set_rotationAngle(double rotationAngle);
		double get_screenX();
		void set_screenX(double screenX);
		double get_screenY();
		void set_screenY(double screenY);
		EventTarget* get_target();
		void set_target(EventTarget* target);
		String* get_touchType();
		void set_touchType(const String& touchType);
	};
	class TextTrack;
	class TrackEventInit: public EventInit {
	public:
		TextTrack* get_track();
		void set_track(TextTrack* track);
	};
	template<class _T0>
	class TransformStreamDefaultController;
	template<class _T0, class _T1>
	class Transformer: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		_Function<_Union<void, PromiseLike<_Any*>*>*(TransformStreamDefaultController<_Any*>*)>* get_flush();
		void set_flush(EventListener* flush);
		void set_flush(const _Function<_Union<void, PromiseLike<_Any*>*>*(TransformStreamDefaultController<_Any*>*)>& flush);
		Object* get_readableType();
		void set_readableType(const _Any& readableType);
		_Function<_Any*(TransformStreamDefaultController<_Any*>*)>* get_start();
		void set_start(EventListener* start);
		void set_start(const _Function<_Any*(TransformStreamDefaultController<_Any*>*)>& start);
		_Function<_Union<void, PromiseLike<_Any*>*>*(_Any*, TransformStreamDefaultController<_Any*>*)>* get_transform();
		void set_transform(EventListener* transform);
		void set_transform(const _Function<_Union<void, PromiseLike<_Any*>*>*(_Any*, TransformStreamDefaultController<_Any*>*)>& transform);
		Object* get_writableType();
		void set_writableType(const _Any& writableType);
	};
	class TransitionEventInit: public EventInit {
	public:
		double get_elapsedTime();
		void set_elapsedTime(double elapsedTime);
		String* get_propertyName();
		void set_propertyName(const String& propertyName);
		String* get_pseudoElement();
		void set_pseudoElement(const String& pseudoElement);
	};
	class ReadableByteStreamController;
	class UnderlyingByteSource: public Object {
	public:
		double get_autoAllocateChunkSize();
		void set_autoAllocateChunkSize(double autoAllocateChunkSize);
		_Function<_Union<void, PromiseLike<_Any*>*>*(_Any*)>* get_cancel();
		void set_cancel(EventListener* cancel);
		void set_cancel(const _Function<_Union<void, PromiseLike<_Any*>*>*(_Any*)>& cancel);
		_Function<_Union<void, PromiseLike<_Any*>*>*(ReadableByteStreamController*)>* get_pull();
		void set_pull(EventListener* pull);
		void set_pull(const _Function<_Union<void, PromiseLike<_Any*>*>*(ReadableByteStreamController*)>& pull);
		_Function<_Any*(ReadableByteStreamController*)>* get_start();
		void set_start(EventListener* start);
		void set_start(const _Function<_Any*(ReadableByteStreamController*)>& start);
		String* get_type();
		void set_type(const String& type);
	};
	template<class _T0>
	class ReadableStreamDefaultController;
	template<class _T0>
	class UnderlyingDefaultSource: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_Function<_Union<void, PromiseLike<_Any*>*>*(_Any*)>* get_cancel();
		void set_cancel(EventListener* cancel);
		void set_cancel(const _Function<_Union<void, PromiseLike<_Any*>*>*(_Any*)>& cancel);
		_Function<_Union<void, PromiseLike<_Any*>*>*(ReadableStreamDefaultController<_T0>*)>* get_pull();
		void set_pull(EventListener* pull);
		void set_pull(const _Function<_Union<void, PromiseLike<_Any*>*>*(ReadableStreamDefaultController<_T0>*)>& pull);
		_Function<_Any*(ReadableStreamDefaultController<_T0>*)>* get_start();
		void set_start(EventListener* start);
		void set_start(const _Function<_Any*(ReadableStreamDefaultController<_T0>*)>& start);
		Object* get_type();
		void set_type(const _Any& type);
	};
	class WritableStreamDefaultController;
	template<class _T0>
	class UnderlyingSink: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_Function<_Union<void, PromiseLike<_Any*>*>*(_Any*)>* get_abort();
		void set_abort(EventListener* abort);
		void set_abort(const _Function<_Union<void, PromiseLike<_Any*>*>*(_Any*)>& abort);
		_Function<_Union<void, PromiseLike<_Any*>*>*()>* get_close();
		void set_close(EventListener* close);
		void set_close(const _Function<_Union<void, PromiseLike<_Any*>*>*()>& close);
		_Function<_Any*(WritableStreamDefaultController*)>* get_start();
		void set_start(EventListener* start);
		void set_start(const _Function<_Any*(WritableStreamDefaultController*)>& start);
		Object* get_type();
		void set_type(const _Any& type);
		_Function<_Union<void, PromiseLike<_Any*>*>*(_Any*, WritableStreamDefaultController*)>* get_write();
		void set_write(EventListener* write);
		void set_write(const _Function<_Union<void, PromiseLike<_Any*>*>*(_Any*, WritableStreamDefaultController*)>& write);
	};
	template<class _T0>
	class UnderlyingSource: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		double get_autoAllocateChunkSize();
		void set_autoAllocateChunkSize(double autoAllocateChunkSize);
		_Function<_Union<void, PromiseLike<_Any*>*>*(_Any*)>* get_cancel();
		void set_cancel(EventListener* cancel);
		void set_cancel(const _Function<_Union<void, PromiseLike<_Any*>*>*(_Any*)>& cancel);
		_Function<_Union<void, PromiseLike<_Any*>*>*(_Union<ReadableByteStreamController*, ReadableStreamDefaultController<_Any*>*>*)>* get_pull();
		void set_pull(EventListener* pull);
		void set_pull(const _Function<_Union<void, PromiseLike<_Any*>*>*(_Union<ReadableByteStreamController*, ReadableStreamDefaultController<_Any*>*>*)>& pull);
		_Function<_Any*(_Union<ReadableByteStreamController*, ReadableStreamDefaultController<_Any*>*>*)>* get_start();
		void set_start(EventListener* start);
		void set_start(const _Function<_Any*(_Union<ReadableByteStreamController*, ReadableStreamDefaultController<_Any*>*>*)>& start);
		String* get_type();
		void set_type(const String& type);
	};
	class ValidityStateFlags: public Object {
	public:
		bool get_badInput();
		void set_badInput(bool badInput);
		bool get_customError();
		void set_customError(bool customError);
		bool get_patternMismatch();
		void set_patternMismatch(bool patternMismatch);
		bool get_rangeOverflow();
		void set_rangeOverflow(bool rangeOverflow);
		bool get_rangeUnderflow();
		void set_rangeUnderflow(bool rangeUnderflow);
		bool get_stepMismatch();
		void set_stepMismatch(bool stepMismatch);
		bool get_tooLong();
		void set_tooLong(bool tooLong);
		bool get_tooShort();
		void set_tooShort(bool tooShort);
		bool get_typeMismatch();
		void set_typeMismatch(bool typeMismatch);
		bool get_valueMissing();
		void set_valueMissing(bool valueMissing);
	};
	class VideoColorSpaceInit: public Object {
	public:
		bool get_fullRange();
		void set_fullRange(bool fullRange);
		String* get_matrix();
		void set_matrix(const String& matrix);
		String* get_primaries();
		void set_primaries(const String& primaries);
		String* get_transfer();
		void set_transfer(const String& transfer);
	};
	class VideoConfiguration: public Object {
	public:
		double get_bitrate();
		void set_bitrate(double bitrate);
		String* get_colorGamut();
		void set_colorGamut(const String& colorGamut);
		String* get_contentType();
		void set_contentType(const String& contentType);
		double get_framerate();
		void set_framerate(double framerate);
		String* get_hdrMetadataType();
		void set_hdrMetadataType(const String& hdrMetadataType);
		double get_height();
		void set_height(double height);
		String* get_scalabilityMode();
		void set_scalabilityMode(const String& scalabilityMode);
		String* get_transferFunction();
		void set_transferFunction(const String& transferFunction);
		double get_width();
		void set_width(double width);
	};
	class VideoDecoderConfig: public Object {
	public:
		String* get_codec();
		void set_codec(const String& codec);
		double get_codedHeight();
		void set_codedHeight(double codedHeight);
		double get_codedWidth();
		void set_codedWidth(double codedWidth);
		VideoColorSpaceInit* get_colorSpace();
		void set_colorSpace(VideoColorSpaceInit* colorSpace);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_description();
		void set_description(const _Union<ArrayBuffer*, ArrayBufferView*>& description);
		double get_displayAspectHeight();
		void set_displayAspectHeight(double displayAspectHeight);
		double get_displayAspectWidth();
		void set_displayAspectWidth(double displayAspectWidth);
		String* get_hardwareAcceleration();
		void set_hardwareAcceleration(const String& hardwareAcceleration);
		bool get_optimizeForLatency();
		void set_optimizeForLatency(bool optimizeForLatency);
	};
	class DOMException;
	class VideoFrame;
	class VideoDecoderInit: public Object {
	public:
		_Function<void(DOMException*)>* get_error();
		void set_error(EventListener* error);
		void set_error(const _Function<void(DOMException*)>& error);
		_Function<void(VideoFrame*)>* get_output();
		void set_output(EventListener* output);
		void set_output(const _Function<void(VideoFrame*)>& output);
	};
	class VideoDecoderSupport: public Object {
	public:
		VideoDecoderConfig* get_config();
		void set_config(VideoDecoderConfig* config);
		bool get_supported();
		void set_supported(bool supported);
	};
	class VideoEncoderConfig: public Object {
	public:
		String* get_alpha();
		void set_alpha(const String& alpha);
		AvcEncoderConfig* get_avc();
		void set_avc(AvcEncoderConfig* avc);
		double get_bitrate();
		void set_bitrate(double bitrate);
		String* get_bitrateMode();
		void set_bitrateMode(const String& bitrateMode);
		String* get_codec();
		void set_codec(const String& codec);
		double get_displayHeight();
		void set_displayHeight(double displayHeight);
		double get_displayWidth();
		void set_displayWidth(double displayWidth);
		double get_framerate();
		void set_framerate(double framerate);
		String* get_hardwareAcceleration();
		void set_hardwareAcceleration(const String& hardwareAcceleration);
		double get_height();
		void set_height(double height);
		String* get_latencyMode();
		void set_latencyMode(const String& latencyMode);
		String* get_scalabilityMode();
		void set_scalabilityMode(const String& scalabilityMode);
		double get_width();
		void set_width(double width);
	};
	class VideoEncoderEncodeOptions: public Object {
	public:
		bool get_keyFrame();
		void set_keyFrame(bool keyFrame);
	};
	class EncodedVideoChunk;
	class VideoEncoderInit: public Object {
	public:
		_Function<void(DOMException*)>* get_error();
		void set_error(EventListener* error);
		void set_error(const _Function<void(DOMException*)>& error);
		_Function<void(EncodedVideoChunk*, EncodedVideoChunkMetadata*)>* get_output();
		void set_output(EventListener* output);
		void set_output(const _Function<void(EncodedVideoChunk*, EncodedVideoChunkMetadata*)>& output);
	};
	class VideoEncoderSupport: public Object {
	public:
		VideoEncoderConfig* get_config();
		void set_config(VideoEncoderConfig* config);
		bool get_supported();
		void set_supported(bool supported);
	};
	class VideoFrameBufferInit: public Object {
	public:
		double get_codedHeight();
		void set_codedHeight(double codedHeight);
		double get_codedWidth();
		void set_codedWidth(double codedWidth);
		VideoColorSpaceInit* get_colorSpace();
		void set_colorSpace(VideoColorSpaceInit* colorSpace);
		double get_displayHeight();
		void set_displayHeight(double displayHeight);
		double get_displayWidth();
		void set_displayWidth(double displayWidth);
		double get_duration();
		void set_duration(double duration);
		String* get_format();
		void set_format(const String& format);
		TArray<PlaneLayout*>* get_layout();
		void set_layout(TArray<PlaneLayout*>* layout);
		double get_timestamp();
		void set_timestamp(double timestamp);
		DOMRectInit* get_visibleRect();
		void set_visibleRect(DOMRectInit* visibleRect);
	};
	class VideoFrameCallbackMetadata: public Object {
	public:
		double get_captureTime();
		void set_captureTime(double captureTime);
		double get_expectedDisplayTime();
		void set_expectedDisplayTime(double expectedDisplayTime);
		double get_height();
		void set_height(double height);
		double get_mediaTime();
		void set_mediaTime(double mediaTime);
		double get_presentationTime();
		void set_presentationTime(double presentationTime);
		double get_presentedFrames();
		void set_presentedFrames(double presentedFrames);
		double get_processingDuration();
		void set_processingDuration(double processingDuration);
		double get_receiveTime();
		void set_receiveTime(double receiveTime);
		double get_rtpTimestamp();
		void set_rtpTimestamp(double rtpTimestamp);
		double get_width();
		void set_width(double width);
	};
	class VideoFrameCopyToOptions: public Object {
	public:
		TArray<PlaneLayout*>* get_layout();
		void set_layout(TArray<PlaneLayout*>* layout);
		DOMRectInit* get_rect();
		void set_rect(DOMRectInit* rect);
	};
	class VideoFrameInit: public Object {
	public:
		String* get_alpha();
		void set_alpha(const String& alpha);
		double get_displayHeight();
		void set_displayHeight(double displayHeight);
		double get_displayWidth();
		void set_displayWidth(double displayWidth);
		double get_duration();
		void set_duration(double duration);
		double get_timestamp();
		void set_timestamp(double timestamp);
		DOMRectInit* get_visibleRect();
		void set_visibleRect(DOMRectInit* visibleRect);
	};
	class WaveShaperOptions: public AudioNodeOptions {
	public:
		_Union<Float32Array*, TArray<double>*>* get_curve();
		void set_curve(const _Union<Float32Array*, TArray<double>*>& curve);
		String* get_oversample();
		void set_oversample(const String& oversample);
	};
	class WebGLContextAttributes: public Object {
	public:
		bool get_alpha();
		void set_alpha(bool alpha);
		bool get_antialias();
		void set_antialias(bool antialias);
		bool get_depth();
		void set_depth(bool depth);
		bool get_desynchronized();
		void set_desynchronized(bool desynchronized);
		bool get_failIfMajorPerformanceCaveat();
		void set_failIfMajorPerformanceCaveat(bool failIfMajorPerformanceCaveat);
		String* get_powerPreference();
		void set_powerPreference(const String& powerPreference);
		bool get_premultipliedAlpha();
		void set_premultipliedAlpha(bool premultipliedAlpha);
		bool get_preserveDrawingBuffer();
		void set_preserveDrawingBuffer(bool preserveDrawingBuffer);
		bool get_stencil();
		void set_stencil(bool stencil);
	};
	class WebGLContextEventInit: public EventInit {
	public:
		String* get_statusMessage();
		void set_statusMessage(const String& statusMessage);
	};
	class WebTransportCloseInfo: public Object {
	public:
		double get_closeCode();
		void set_closeCode(double closeCode);
		String* get_reason();
		void set_reason(const String& reason);
	};
	class WebTransportErrorOptions: public Object {
	public:
		String* get_source();
		void set_source(const String& source);
		double get_streamErrorCode();
		void set_streamErrorCode(double streamErrorCode);
	};
	class WebTransportHash: public Object {
	public:
		String* get_algorithm();
		void set_algorithm(const String& algorithm);
		_Union<ArrayBuffer*, ArrayBufferView*>* get_value();
		void set_value(const _Union<ArrayBuffer*, ArrayBufferView*>& value);
	};
	class WebTransportOptions: public Object {
	public:
		bool get_allowPooling();
		void set_allowPooling(bool allowPooling);
		String* get_congestionControl();
		void set_congestionControl(const String& congestionControl);
		bool get_requireUnreliable();
		void set_requireUnreliable(bool requireUnreliable);
		TArray<WebTransportHash*>* get_serverCertificateHashes();
		void set_serverCertificateHashes(TArray<WebTransportHash*>* serverCertificateHashes);
	};
	class WebTransportSendStreamOptions: public Object {
	public:
		double get_sendOrder();
		void set_sendOrder(double sendOrder);
	};
	class WheelEventInit: public MouseEventInit {
	public:
		double get_deltaMode();
		void set_deltaMode(double deltaMode);
		double get_deltaX();
		void set_deltaX(double deltaX);
		double get_deltaY();
		void set_deltaY(double deltaY);
		double get_deltaZ();
		void set_deltaZ(double deltaZ);
	};
	class WindowPostMessageOptions: public StructuredSerializeOptions {
	public:
		String* get_targetOrigin();
		void set_targetOrigin(const String& targetOrigin);
	};
	class WorkerOptions: public Object {
	public:
		String* get_credentials();
		void set_credentials(const String& credentials);
		String* get_name();
		void set_name(const String& name);
		String* get_type();
		void set_type(const String& type);
	};
	class WorkletOptions: public Object {
	public:
		String* get_credentials();
		void set_credentials(const String& credentials);
	};
	class WriteParams: public Object {
	public:
		_Union<String*, ArrayBuffer*, ArrayBufferView*, Blob*>* get_data();
		void set_data(const String& data);
		void set_data(const _Union<ArrayBuffer*, ArrayBufferView*, Blob*>& data);
		double get_position();
		void set_position(double position);
		int get_size() const;
		void set_size(double size);
		String* get_type();
		void set_type(const String& type);
	};
	extern Object NodeFilter;
	using XPathNSResolver = _Any;
	class ANGLE_instanced_arrays: public Object {
	public:
		void drawArraysInstancedANGLE(double mode, double first, double count, double primcount);
		void drawElementsInstancedANGLE(double mode, double count, double type, double offset, double primcount);
		void vertexAttribDivisorANGLE(double index, double divisor);
		double get_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE();
	};
	class ARIAMixin: public virtual Object {
	public:
		String* get_ariaAtomic();
		void set_ariaAtomic(const String& ariaAtomic);
		String* get_ariaAutoComplete();
		void set_ariaAutoComplete(const String& ariaAutoComplete);
		String* get_ariaBusy();
		void set_ariaBusy(const String& ariaBusy);
		String* get_ariaChecked();
		void set_ariaChecked(const String& ariaChecked);
		String* get_ariaColCount();
		void set_ariaColCount(const String& ariaColCount);
		String* get_ariaColIndex();
		void set_ariaColIndex(const String& ariaColIndex);
		String* get_ariaColSpan();
		void set_ariaColSpan(const String& ariaColSpan);
		String* get_ariaCurrent();
		void set_ariaCurrent(const String& ariaCurrent);
		String* get_ariaDisabled();
		void set_ariaDisabled(const String& ariaDisabled);
		String* get_ariaExpanded();
		void set_ariaExpanded(const String& ariaExpanded);
		String* get_ariaHasPopup();
		void set_ariaHasPopup(const String& ariaHasPopup);
		String* get_ariaHidden();
		void set_ariaHidden(const String& ariaHidden);
		String* get_ariaInvalid();
		void set_ariaInvalid(const String& ariaInvalid);
		String* get_ariaKeyShortcuts();
		void set_ariaKeyShortcuts(const String& ariaKeyShortcuts);
		String* get_ariaLabel();
		void set_ariaLabel(const String& ariaLabel);
		String* get_ariaLevel();
		void set_ariaLevel(const String& ariaLevel);
		String* get_ariaLive();
		void set_ariaLive(const String& ariaLive);
		String* get_ariaModal();
		void set_ariaModal(const String& ariaModal);
		String* get_ariaMultiLine();
		void set_ariaMultiLine(const String& ariaMultiLine);
		String* get_ariaMultiSelectable();
		void set_ariaMultiSelectable(const String& ariaMultiSelectable);
		String* get_ariaOrientation();
		void set_ariaOrientation(const String& ariaOrientation);
		String* get_ariaPlaceholder();
		void set_ariaPlaceholder(const String& ariaPlaceholder);
		String* get_ariaPosInSet();
		void set_ariaPosInSet(const String& ariaPosInSet);
		String* get_ariaPressed();
		void set_ariaPressed(const String& ariaPressed);
		String* get_ariaReadOnly();
		void set_ariaReadOnly(const String& ariaReadOnly);
		String* get_ariaRequired();
		void set_ariaRequired(const String& ariaRequired);
		String* get_ariaRoleDescription();
		void set_ariaRoleDescription(const String& ariaRoleDescription);
		String* get_ariaRowCount();
		void set_ariaRowCount(const String& ariaRowCount);
		String* get_ariaRowIndex();
		void set_ariaRowIndex(const String& ariaRowIndex);
		String* get_ariaRowSpan();
		void set_ariaRowSpan(const String& ariaRowSpan);
		String* get_ariaSelected();
		void set_ariaSelected(const String& ariaSelected);
		String* get_ariaSetSize();
		void set_ariaSetSize(const String& ariaSetSize);
		String* get_ariaSort();
		void set_ariaSort(const String& ariaSort);
		String* get_ariaValueMax();
		void set_ariaValueMax(const String& ariaValueMax);
		String* get_ariaValueMin();
		void set_ariaValueMin(const String& ariaValueMin);
		String* get_ariaValueNow();
		void set_ariaValueNow(const String& ariaValueNow);
		String* get_ariaValueText();
		void set_ariaValueText(const String& ariaValueText);
		String* get_role();
		void set_role(const String& role);
	};
	class AbortController: public Object {
	public:
		AbortSignal* get_signal();
		void abort();
		void abort(const _Any& reason);
		static AbortController* prototype;
		AbortController();
	};
	class Event;
	class AbortSignalEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"abort\""))]]
		Event* get__34_abort_34_();
		[[cheerp::interface_name(("set_\"abort\""))]]
		void set__34_abort_34_(Event* _34_abort_34_);
	};
	class EventListenerObject;
	class EventTarget: public virtual Object {
	public:
		void addEventListener(const String& type, EventListener* callback);
		void addEventListener(const String& type, const _Function<void(Event*)>& callback);
		void addEventListener(const String& type, EventListenerObject* callback);
		void addEventListener(const String& type, EventListener* callback, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<void(Event*)>& callback, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* callback, const _Union<bool, AddEventListenerOptions*>& options);
		bool dispatchEvent(Event* event);
		void removeEventListener(const String& type, EventListener* callback);
		void removeEventListener(const String& type, const _Function<void(Event*)>& callback);
		void removeEventListener(const String& type, EventListenerObject* callback);
		void removeEventListener(const String& type, EventListener* callback, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<void(Event*)>& callback, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* callback, const _Union<bool, EventListenerOptions*>& options);
		static EventTarget* prototype;
		EventTarget();
	};
	class AbortSignal: public EventTarget {
	public:
		bool get_aborted();
		_Function<_Any*(Event*)>* get_onabort();
		void set_onabort(EventListener* onabort);
		void set_onabort(const _Function<_Any*(Event*)>& onabort);
		Object* get_reason();
		void throwIfAborted();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static AbortSignal* prototype;
		AbortSignal();
		static AbortSignal* abort();
		static AbortSignal* abort(const _Any& reason);
		static AbortSignal* timeout(double milliseconds);
	};
	class AbstractRange: public Object {
	public:
		bool get_collapsed();
		Node* get_endContainer();
		double get_endOffset();
		Node* get_startContainer();
		double get_startOffset();
		static AbstractRange* prototype;
		AbstractRange();
	};
	class ErrorEvent;
	class AbstractWorkerEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"error\""))]]
		ErrorEvent* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(ErrorEvent* _34_error_34_);
	};
	class AbstractWorker: public virtual Object {
	public:
		_Function<_Any*(ErrorEvent*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(ErrorEvent*)>& onerror);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
	};
	class BaseAudioContext;
	class AudioParam;
	class AudioNode: public EventTarget {
	public:
		double get_channelCount();
		void set_channelCount(double channelCount);
		String* get_channelCountMode();
		void set_channelCountMode(const String& channelCountMode);
		String* get_channelInterpretation();
		void set_channelInterpretation(const String& channelInterpretation);
		BaseAudioContext* get_context();
		double get_numberOfInputs();
		double get_numberOfOutputs();
		AudioNode* connect(AudioNode* destinationNode);
		AudioNode* connect(AudioNode* destinationNode, double output);
		AudioNode* connect(AudioNode* destinationNode, double output, double input);
		void connect(AudioParam* destinationParam);
		void connect(AudioParam* destinationParam, double output);
		void disconnect();
		void disconnect(double output);
		void disconnect(AudioNode* destinationNode);
		void disconnect(AudioNode* destinationNode, double output);
		void disconnect(AudioNode* destinationNode, double output, double input);
		void disconnect(AudioParam* destinationParam);
		void disconnect(AudioParam* destinationParam, double output);
		static AudioNode* prototype;
		AudioNode();
	};
	class AnalyserNode: public AudioNode {
	public:
		double get_fftSize();
		void set_fftSize(double fftSize);
		double get_frequencyBinCount();
		double get_maxDecibels();
		void set_maxDecibels(double maxDecibels);
		double get_minDecibels();
		void set_minDecibels(double minDecibels);
		double get_smoothingTimeConstant();
		void set_smoothingTimeConstant(double smoothingTimeConstant);
		void getByteFrequencyData(Uint8Array* array);
		void getByteTimeDomainData(Uint8Array* array);
		void getFloatFrequencyData(Float32Array* array);
		void getFloatTimeDomainData(Float32Array* array);
		static AnalyserNode* prototype;
		AnalyserNode(BaseAudioContext* context);
		AnalyserNode(BaseAudioContext* context, AnalyserOptions* options);
	};
	class Animation;
	class Animatable: public virtual Object {
	public:
		Animation* animate(const _Union<PropertyIndexedKeyframes*, TArray<Keyframe*>*>& keyframes);
		Animation* animate(const _Union<PropertyIndexedKeyframes*, TArray<Keyframe*>*>& keyframes, const _Union<double, KeyframeAnimationOptions*>& options);
		TArray<Animation*>* getAnimations();
		TArray<Animation*>* getAnimations(GetAnimationsOptions* options);
	};
	class AnimationPlaybackEvent;
	class AnimationEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"cancel\""))]]
		AnimationPlaybackEvent* get__34_cancel_34_();
		[[cheerp::interface_name(("set_\"cancel\""))]]
		void set__34_cancel_34_(AnimationPlaybackEvent* _34_cancel_34_);
		[[cheerp::interface_name(("get_\"finish\""))]]
		AnimationPlaybackEvent* get__34_finish_34_();
		[[cheerp::interface_name(("set_\"finish\""))]]
		void set__34_finish_34_(AnimationPlaybackEvent* _34_finish_34_);
		[[cheerp::interface_name(("get_\"remove\""))]]
		Event* get__34_remove_34_();
		[[cheerp::interface_name(("set_\"remove\""))]]
		void set__34_remove_34_(Event* _34_remove_34_);
	};
	class AnimationEffect;
	class Animation: public EventTarget {
	public:
		_Union<double, CSSNumericValue*>* get_currentTime();
		void set_currentTime(const _Union<double, CSSNumericValue*>& currentTime);
		AnimationEffect* get_effect();
		void set_effect(AnimationEffect* effect);
		Promise<Animation*>* get_finished();
		String* get_id();
		void set_id(const String& id);
		_Function<_Any*(AnimationPlaybackEvent*)>* get_oncancel();
		void set_oncancel(EventListener* oncancel);
		void set_oncancel(const _Function<_Any*(AnimationPlaybackEvent*)>& oncancel);
		_Function<_Any*(AnimationPlaybackEvent*)>* get_onfinish();
		void set_onfinish(EventListener* onfinish);
		void set_onfinish(const _Function<_Any*(AnimationPlaybackEvent*)>& onfinish);
		_Function<_Any*(Event*)>* get_onremove();
		void set_onremove(EventListener* onremove);
		void set_onremove(const _Function<_Any*(Event*)>& onremove);
		bool get_pending();
		String* get_playState();
		double get_playbackRate();
		void set_playbackRate(double playbackRate);
		Promise<Animation*>* get_ready();
		String* get_replaceState();
		_Union<double, CSSNumericValue*>* get_startTime();
		void set_startTime(const _Union<double, CSSNumericValue*>& startTime);
		AnimationTimeline* get_timeline();
		void set_timeline(AnimationTimeline* timeline);
		void cancel();
		void commitStyles();
		void finish();
		void pause();
		void persist();
		void play();
		void reverse();
		void updatePlaybackRate(double playbackRate);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static Animation* prototype;
		Animation();
		Animation(AnimationEffect* effect);
		Animation(AnimationEffect* effect, AnimationTimeline* timeline);
	};
	class AnimationEffect: public Object {
	public:
		ComputedEffectTiming* getComputedTiming();
		EffectTiming* getTiming();
		void updateTiming();
		void updateTiming(OptionalEffectTiming* timing);
		static AnimationEffect* prototype;
		AnimationEffect();
	};
	class Event: public Object {
	public:
		bool get_bubbles();
		bool get_cancelBubble();
		void set_cancelBubble(bool cancelBubble);
		bool get_cancelable();
		bool get_composed();
		EventTarget* get_currentTarget();
		bool get_defaultPrevented();
		double get_eventPhase();
		bool get_isTrusted();
		bool get_returnValue();
		void set_returnValue(bool returnValue);
		EventTarget* get_srcElement();
		EventTarget* get_target();
		double get_timeStamp();
		String* get_type();
		TArray<EventTarget*>* composedPath();
		void initEvent(const String& type);
		void initEvent(const String& type, bool bubbles);
		void initEvent(const String& type, bool bubbles, bool cancelable);
		void preventDefault();
		void stopImmediatePropagation();
		void stopPropagation();
		double get_NONE();
		double get_CAPTURING_PHASE();
		double get_AT_TARGET();
		double get_BUBBLING_PHASE();
		static Event* prototype;
		Event(const String& type);
		Event(const String& type, EventInit* eventInitDict);
		static double NONE;
		static double CAPTURING_PHASE;
		static double AT_TARGET;
		static double BUBBLING_PHASE;
	};
	class AnimationEvent: public Event {
	public:
		String* get_animationName();
		double get_elapsedTime();
		String* get_pseudoElement();
		static AnimationEvent* prototype;
		AnimationEvent(const String& type);
		AnimationEvent(const String& type, AnimationEventInit* animationEventInitDict);
	};
	class AnimationFrameProvider: public virtual Object {
	public:
		void cancelAnimationFrame(double handle);
		double requestAnimationFrame(EventListener* callback);
		double requestAnimationFrame(const _Function<void(double)>& callback);
	};
	class AnimationPlaybackEvent: public Event {
	public:
		_Union<double, CSSNumericValue*>* get_currentTime();
		_Union<double, CSSNumericValue*>* get_timelineTime();
		static AnimationPlaybackEvent* prototype;
		AnimationPlaybackEvent(const String& type);
		AnimationPlaybackEvent(const String& type, AnimationPlaybackEventInit* eventInitDict);
	};
	class AnimationTimeline: public Object {
	public:
		_Union<double, CSSNumericValue*>* get_currentTime();
		static AnimationTimeline* prototype;
		AnimationTimeline();
	};
	class ChildNode;
	template<class _T0>
	class NodeListOf;
	class ParentNode;
	class Node: public EventTarget {
	public:
		String* get_baseURI();
		NodeListOf<ChildNode*>* get_childNodes();
		ChildNode* get_firstChild();
		bool get_isConnected();
		ChildNode* get_lastChild();
		ChildNode* get_nextSibling();
		String* get_nodeName();
		double get_nodeType();
		String* get_nodeValue();
		void set_nodeValue(const String& nodeValue);
		Document* get_ownerDocument();
		HTMLElement* get_parentElement();
		ParentNode* get_parentNode();
		ChildNode* get_previousSibling();
		String* get_textContent();
		void set_textContent(const String& textContent);
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Node*>, _T0> appendChild(_T0 node);
		Node* cloneNode();
		Node* cloneNode(bool deep);
		double compareDocumentPosition(Node* other);
		bool contains(Node* other);
		Node* getRootNode();
		Node* getRootNode(GetRootNodeOptions* options);
		bool hasChildNodes();
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Node*>, _T0> insertBefore(_T0 node, Node* child);
		bool isDefaultNamespace(const String& namespace_);
		bool isEqualNode(Node* otherNode);
		bool isSameNode(Node* otherNode);
		String* lookupNamespaceURI(const String& prefix);
		String* lookupPrefix(const String& namespace_);
		void normalize();
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Node*>, _T0> removeChild(_T0 child);
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Node*>, _T0> replaceChild(Node* node, _T0 child);
		double get_ELEMENT_NODE();
		double get_ATTRIBUTE_NODE();
		double get_TEXT_NODE();
		double get_CDATA_SECTION_NODE();
		double get_ENTITY_REFERENCE_NODE();
		double get_ENTITY_NODE();
		double get_PROCESSING_INSTRUCTION_NODE();
		double get_COMMENT_NODE();
		double get_DOCUMENT_NODE();
		double get_DOCUMENT_TYPE_NODE();
		double get_DOCUMENT_FRAGMENT_NODE();
		double get_NOTATION_NODE();
		double get_DOCUMENT_POSITION_DISCONNECTED();
		double get_DOCUMENT_POSITION_PRECEDING();
		double get_DOCUMENT_POSITION_FOLLOWING();
		double get_DOCUMENT_POSITION_CONTAINS();
		double get_DOCUMENT_POSITION_CONTAINED_BY();
		double get_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC();
		static Node* prototype;
		Node();
		static double ELEMENT_NODE;
		static double ATTRIBUTE_NODE;
		static double TEXT_NODE;
		static double CDATA_SECTION_NODE;
		static double ENTITY_REFERENCE_NODE;
		static double ENTITY_NODE;
		static double PROCESSING_INSTRUCTION_NODE;
		static double COMMENT_NODE;
		static double DOCUMENT_NODE;
		static double DOCUMENT_TYPE_NODE;
		static double DOCUMENT_FRAGMENT_NODE;
		static double NOTATION_NODE;
		static double DOCUMENT_POSITION_DISCONNECTED;
		static double DOCUMENT_POSITION_PRECEDING;
		static double DOCUMENT_POSITION_FOLLOWING;
		static double DOCUMENT_POSITION_CONTAINS;
		static double DOCUMENT_POSITION_CONTAINED_BY;
		static double DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
	};
	class Attr: public Node {
	public:
		String* get_localName();
		String* get_name();
		String* get_namespaceURI();
		Document* get_ownerDocument();
		Element* get_ownerElement();
		String* get_prefix();
		bool get_specified();
		String* get_value();
		void set_value(const String& value);
		static Attr* prototype;
		Attr();
	};
	class AudioBuffer: public Object {
	public:
		double get_duration();
		int get_length() const;
		double get_numberOfChannels();
		double get_sampleRate();
		void copyFromChannel(Float32Array* destination, double channelNumber);
		void copyFromChannel(Float32Array* destination, double channelNumber, double bufferOffset);
		void copyToChannel(Float32Array* source, double channelNumber);
		void copyToChannel(Float32Array* source, double channelNumber, double bufferOffset);
		Float32Array* getChannelData(double channel);
		static AudioBuffer* prototype;
		AudioBuffer(AudioBufferOptions* options);
	};
	class AudioScheduledSourceNode: public AudioNode {
	public:
		_Function<_Any*(Event*)>* get_onended();
		void set_onended(EventListener* onended);
		void set_onended(const _Function<_Any*(Event*)>& onended);
		void start();
		void start(double when);
		void stop();
		void stop(double when);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static AudioScheduledSourceNode* prototype;
		AudioScheduledSourceNode();
	};
	class AudioBufferSourceNode: public AudioScheduledSourceNode {
	public:
		AudioBuffer* get_buffer();
		void set_buffer(AudioBuffer* buffer);
		AudioParam* get_detune();
		bool get_loop();
		void set_loop(bool loop);
		double get_loopEnd();
		void set_loopEnd(double loopEnd);
		double get_loopStart();
		void set_loopStart(double loopStart);
		AudioParam* get_playbackRate();
		void start();
		void start(double when);
		void start(double when, double offset);
		void start(double when, double offset, double duration);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static AudioBufferSourceNode* prototype;
		AudioBufferSourceNode(BaseAudioContext* context);
		AudioBufferSourceNode(BaseAudioContext* context, AudioBufferSourceOptions* options);
	};
	class MediaElementAudioSourceNode;
	class MediaStreamAudioDestinationNode;
	class MediaStreamAudioSourceNode;
	class AudioWorklet;
	class AudioDestinationNode;
	class AudioListener;
	class BiquadFilterNode;
	class ChannelMergerNode;
	class ChannelSplitterNode;
	class ConstantSourceNode;
	class ConvolverNode;
	class DelayNode;
	class DynamicsCompressorNode;
	class GainNode;
	class IIRFilterNode;
	class OscillatorNode;
	class PannerNode;
	class ScriptProcessorNode;
	class StereoPannerNode;
	class WaveShaperNode;
	class BaseAudioContext: public EventTarget {
	public:
		AudioWorklet* get_audioWorklet();
		double get_currentTime();
		AudioDestinationNode* get_destination();
		AudioListener* get_listener();
		_Function<_Any*(Event*)>* get_onstatechange();
		void set_onstatechange(EventListener* onstatechange);
		void set_onstatechange(const _Function<_Any*(Event*)>& onstatechange);
		double get_sampleRate();
		String* get_state();
		AnalyserNode* createAnalyser();
		BiquadFilterNode* createBiquadFilter();
		AudioBuffer* createBuffer(double numberOfChannels, double length, double sampleRate);
		AudioBufferSourceNode* createBufferSource();
		ChannelMergerNode* createChannelMerger();
		ChannelMergerNode* createChannelMerger(double numberOfInputs);
		ChannelSplitterNode* createChannelSplitter();
		ChannelSplitterNode* createChannelSplitter(double numberOfOutputs);
		ConstantSourceNode* createConstantSource();
		ConvolverNode* createConvolver();
		DelayNode* createDelay();
		DelayNode* createDelay(double maxDelayTime);
		DynamicsCompressorNode* createDynamicsCompressor();
		GainNode* createGain();
		IIRFilterNode* createIIRFilter(TArray<double>* feedforward, TArray<double>* feedback);
		OscillatorNode* createOscillator();
		PannerNode* createPanner();
		PeriodicWave* createPeriodicWave(const _Union<Float32Array*, TArray<double>*>& real, const _Union<Float32Array*, TArray<double>*>& imag);
		PeriodicWave* createPeriodicWave(const _Union<Float32Array*, TArray<double>*>& real, const _Union<Float32Array*, TArray<double>*>& imag, PeriodicWaveConstraints* constraints);
		ScriptProcessorNode* createScriptProcessor();
		ScriptProcessorNode* createScriptProcessor(double bufferSize);
		ScriptProcessorNode* createScriptProcessor(double bufferSize, double numberOfInputChannels);
		ScriptProcessorNode* createScriptProcessor(double bufferSize, double numberOfInputChannels, double numberOfOutputChannels);
		StereoPannerNode* createStereoPanner();
		WaveShaperNode* createWaveShaper();
		Promise<AudioBuffer*>* decodeAudioData(ArrayBuffer* audioData);
		Promise<AudioBuffer*>* decodeAudioData(ArrayBuffer* audioData, EventListener* successCallback);
		Promise<AudioBuffer*>* decodeAudioData(ArrayBuffer* audioData, const _Function<void(AudioBuffer*)>& successCallback);
		Promise<AudioBuffer*>* decodeAudioData(ArrayBuffer* audioData, EventListener* successCallback, EventListener* errorCallback);
		Promise<AudioBuffer*>* decodeAudioData(ArrayBuffer* audioData, const _Function<void(AudioBuffer*)>& successCallback, EventListener* errorCallback);
		Promise<AudioBuffer*>* decodeAudioData(ArrayBuffer* audioData, EventListener* successCallback, const _Function<void(DOMException*)>& errorCallback);
		Promise<AudioBuffer*>* decodeAudioData(ArrayBuffer* audioData, const _Function<void(AudioBuffer*)>& successCallback, const _Function<void(DOMException*)>& errorCallback);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static BaseAudioContext* prototype;
		BaseAudioContext();
	};
	class AudioContext: public BaseAudioContext {
	public:
		double get_baseLatency();
		double get_outputLatency();
		Promise<_Any*>* close();
		MediaElementAudioSourceNode* createMediaElementSource(HTMLMediaElement* mediaElement);
		MediaStreamAudioDestinationNode* createMediaStreamDestination();
		MediaStreamAudioSourceNode* createMediaStreamSource(MediaStream* mediaStream);
		AudioTimestamp* getOutputTimestamp();
		Promise<_Any*>* resume();
		Promise<_Any*>* suspend();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static AudioContext* prototype;
		AudioContext();
		AudioContext(AudioContextOptions* contextOptions);
	};
	class AudioDestinationNode: public AudioNode {
	public:
		double get_maxChannelCount();
		static AudioDestinationNode* prototype;
		AudioDestinationNode();
	};
	class AudioListener: public Object {
	public:
		AudioParam* get_forwardX();
		AudioParam* get_forwardY();
		AudioParam* get_forwardZ();
		AudioParam* get_positionX();
		AudioParam* get_positionY();
		AudioParam* get_positionZ();
		AudioParam* get_upX();
		AudioParam* get_upY();
		AudioParam* get_upZ();
		void setOrientation(double x, double y, double z, double xUp, double yUp, double zUp);
		void setPosition(double x, double y, double z);
		static AudioListener* prototype;
		AudioListener();
	};
	class AudioParam: public Object {
	public:
		String* get_automationRate();
		void set_automationRate(const String& automationRate);
		double get_defaultValue();
		double get_maxValue();
		double get_minValue();
		double get_value();
		void set_value(double value);
		AudioParam* cancelAndHoldAtTime(double cancelTime);
		AudioParam* cancelScheduledValues(double cancelTime);
		AudioParam* exponentialRampToValueAtTime(double value, double endTime);
		AudioParam* linearRampToValueAtTime(double value, double endTime);
		AudioParam* setTargetAtTime(double target, double startTime, double timeConstant);
		AudioParam* setValueAtTime(double value, double startTime);
		AudioParam* setValueCurveAtTime(const _Union<Float32Array*, TArray<double>*>& values, double startTime, double duration);
		static AudioParam* prototype;
		AudioParam();
	};
	class AudioParamMap: public Object {
	public:
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(AudioParam*, String*, AudioParamMap*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(AudioParam*, String*, AudioParamMap*)>& callbackfn, const _Any& thisArg);
		static AudioParamMap* prototype;
		AudioParamMap();
	};
	class AudioProcessingEvent: public Event {
	public:
		AudioBuffer* get_inputBuffer();
		AudioBuffer* get_outputBuffer();
		double get_playbackTime();
		static AudioProcessingEvent* prototype;
		AudioProcessingEvent(const String& type, AudioProcessingEventInit* eventInitDict);
	};
	class AudioScheduledSourceNodeEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"ended\""))]]
		Event* get__34_ended_34_();
		[[cheerp::interface_name(("set_\"ended\""))]]
		void set__34_ended_34_(Event* _34_ended_34_);
	};
	class URL;
	class Worklet: public Object {
	public:
		Promise<_Any*>* addModule(const String& moduleURL);
		Promise<_Any*>* addModule(URL* moduleURL);
		Promise<_Any*>* addModule(const String& moduleURL, WorkletOptions* options);
		Promise<_Any*>* addModule(URL* moduleURL, WorkletOptions* options);
		static Worklet* prototype;
		Worklet();
	};
	class AudioWorklet: public Worklet {
	public:
		static AudioWorklet* prototype;
		AudioWorklet();
	};
	class AudioWorkletNodeEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"processorerror\""))]]
		Event* get__34_processorerror_34_();
		[[cheerp::interface_name(("set_\"processorerror\""))]]
		void set__34_processorerror_34_(Event* _34_processorerror_34_);
	};
	class AudioWorkletNode: public AudioNode {
	public:
		_Function<_Any*(Event*)>* get_onprocessorerror();
		void set_onprocessorerror(EventListener* onprocessorerror);
		void set_onprocessorerror(const _Function<_Any*(Event*)>& onprocessorerror);
		AudioParamMap* get_parameters();
		MessagePort* get_port();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static AudioWorkletNode* prototype;
		AudioWorkletNode(BaseAudioContext* context, const String& name);
		AudioWorkletNode(BaseAudioContext* context, const String& name, AudioWorkletNodeOptions* options);
	};
	class AuthenticatorResponse: public Object {
	public:
		ArrayBuffer* get_clientDataJSON();
		static AuthenticatorResponse* prototype;
		AuthenticatorResponse();
	};
	class AuthenticatorAssertionResponse: public AuthenticatorResponse {
	public:
		ArrayBuffer* get_authenticatorData();
		ArrayBuffer* get_signature();
		ArrayBuffer* get_userHandle();
		static AuthenticatorAssertionResponse* prototype;
		AuthenticatorAssertionResponse();
	};
	class AuthenticatorAttestationResponse: public AuthenticatorResponse {
	public:
		ArrayBuffer* get_attestationObject();
		ArrayBuffer* getAuthenticatorData();
		ArrayBuffer* getPublicKey();
		double getPublicKeyAlgorithm();
		TArray<String*>* getTransports();
		static AuthenticatorAttestationResponse* prototype;
		AuthenticatorAttestationResponse();
	};
	class BarProp: public Object {
	public:
		bool get_visible();
		static BarProp* prototype;
		BarProp();
	};
	class BaseAudioContextEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"statechange\""))]]
		Event* get__34_statechange_34_();
		[[cheerp::interface_name(("set_\"statechange\""))]]
		void set__34_statechange_34_(Event* _34_statechange_34_);
	};
	class BeforeUnloadEvent: public Event {
	public:
		Object* get_returnValue();
		void set_returnValue(const _Any& returnValue);
		static BeforeUnloadEvent* prototype;
		BeforeUnloadEvent();
	};
	class BiquadFilterNode: public AudioNode {
	public:
		AudioParam* get_Q();
		AudioParam* get_detune();
		AudioParam* get_frequency();
		AudioParam* get_gain();
		String* get_type();
		void set_type(const String& type);
		void getFrequencyResponse(Float32Array* frequencyHz, Float32Array* magResponse, Float32Array* phaseResponse);
		static BiquadFilterNode* prototype;
		BiquadFilterNode(BaseAudioContext* context);
		BiquadFilterNode(BaseAudioContext* context, BiquadFilterOptions* options);
	};
	class Blob: public Object {
	public:
		int get_size() const;
		String* get_type();
		Promise<ArrayBuffer*>* arrayBuffer();
		Blob* slice();
		Blob* slice(double start);
		Blob* slice(double start, double end);
		Blob* slice(double start, double end, const String& contentType);
		ReadableStream<Uint8Array*>* stream();
		Promise<String*>* text();
		static Blob* prototype;
		Blob();
		Blob(Array* blobParts);
		Blob(Array* blobParts, BlobPropertyBag* options);
	};
	class BlobEvent: public Event {
	public:
		Blob* get_data();
		double get_timecode();
		static BlobEvent* prototype;
		BlobEvent(const String& type, BlobEventInit* eventInitDict);
	};
	class Body: public Object {
	public:
		ReadableStream<Uint8Array*>* get_body();
		bool get_bodyUsed();
		Promise<ArrayBuffer*>* arrayBuffer();
		Promise<Blob*>* blob();
		Promise<FormData*>* formData();
		Promise<_Any*>* json();
		Promise<String*>* text();
	};
	template<class _T0>
	class MessageEvent;
	class BroadcastChannelEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"messageerror\""))]]
		MessageEvent<_Any*>* get__34_messageerror_34_();
		[[cheerp::interface_name(("set_\"messageerror\""))]]
		void set__34_messageerror_34_(MessageEvent<_Any*>* _34_messageerror_34_);
	};
	class BroadcastChannel: public EventTarget {
	public:
		String* get_name();
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessageerror();
		void set_onmessageerror(EventListener* onmessageerror);
		void set_onmessageerror(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessageerror);
		void close();
		void postMessage(const _Any& message);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static BroadcastChannel* prototype;
		BroadcastChannel(const String& name);
	};
	class ByteLengthQueuingStrategy: public QueuingStrategy<ArrayBufferView*> {
	public:
		double get_highWaterMark();
		int get_size() const;
		static ByteLengthQueuingStrategy* prototype;
		ByteLengthQueuingStrategy(QueuingStrategyInit* init);
	};
	class ChildNode: public virtual Node {
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void after(_Args... nodes) {
			_after(cheerp::clientCast(nodes)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("after"))]]
		_Any* _after(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void before(_Args... nodes) {
			_before(cheerp::clientCast(nodes)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("before"))]]
		_Any* _before(_Args... data);
	public:
		void remove();
		template<class... _Args>
		[[gnu::always_inline]]
		void replaceWith(_Args... nodes) {
			_replaceWith(cheerp::clientCast(nodes)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("replaceWith"))]]
		_Any* _replaceWith(_Args... data);
	};
	class NonDocumentTypeChildNode: public virtual Object {
	public:
		Element* get_nextElementSibling();
		Element* get_previousElementSibling();
	};
	class CharacterData: public virtual Node, public ChildNode, public NonDocumentTypeChildNode {
	public:
		String* get_data();
		void set_data(const String& data);
		int get_length() const;
		Document* get_ownerDocument();
		void appendData(const String& data);
		void deleteData(double offset, double count);
		void insertData(double offset, const String& data);
		void replaceData(double offset, double count, const String& data);
		String* substringData(double offset, double count);
		static CharacterData* prototype;
		CharacterData();
	};
	class HTMLSlotElement;
	class Slottable: public virtual Object {
	public:
		HTMLSlotElement* get_assignedSlot();
	};
	class Text: public CharacterData, public Slottable {
	public:
		String* get_wholeText();
		Text* splitText(double offset);
		static Text* prototype;
		Text();
		Text(const String& data);
	};
	class CDATASection: public Text {
	public:
		static CDATASection* prototype;
		CDATASection();
	};
	class CSSAnimation: public Animation {
	public:
		String* get_animationName();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static CSSAnimation* prototype;
		CSSAnimation();
	};
	class CSSRuleList;
	class CSSStyleSheet;
	class CSSRule: public Object {
	public:
		String* get_cssText();
		void set_cssText(const String& cssText);
		CSSRule* get_parentRule();
		CSSStyleSheet* get_parentStyleSheet();
		double get_type();
		double get_STYLE_RULE();
		double get_CHARSET_RULE();
		double get_IMPORT_RULE();
		double get_MEDIA_RULE();
		double get_FONT_FACE_RULE();
		double get_PAGE_RULE();
		double get_NAMESPACE_RULE();
		double get_KEYFRAMES_RULE();
		double get_KEYFRAME_RULE();
		double get_SUPPORTS_RULE();
		static CSSRule* prototype;
		CSSRule();
		static double STYLE_RULE;
		static double CHARSET_RULE;
		static double IMPORT_RULE;
		static double MEDIA_RULE;
		static double FONT_FACE_RULE;
		static double PAGE_RULE;
		static double NAMESPACE_RULE;
		static double KEYFRAMES_RULE;
		static double KEYFRAME_RULE;
		static double SUPPORTS_RULE;
	};
	class CSSGroupingRule: public CSSRule {
	public:
		CSSRuleList* get_cssRules();
		void deleteRule(double index);
		double insertRule(const String& rule);
		double insertRule(const String& rule, double index);
		static CSSGroupingRule* prototype;
		CSSGroupingRule();
	};
	class CSSConditionRule: public CSSGroupingRule {
	public:
		String* get_conditionText();
		static CSSConditionRule* prototype;
		CSSConditionRule();
	};
	class CSSContainerRule: public CSSConditionRule {
	public:
		String* get_containerName();
		String* get_containerQuery();
		static CSSContainerRule* prototype;
		CSSContainerRule();
	};
	class CSSCounterStyleRule: public CSSRule {
	public:
		String* get_additiveSymbols();
		void set_additiveSymbols(const String& additiveSymbols);
		String* get_fallback();
		void set_fallback(const String& fallback);
		String* get_name();
		void set_name(const String& name);
		String* get_negative();
		void set_negative(const String& negative);
		String* get_pad();
		void set_pad(const String& pad);
		String* get_prefix();
		void set_prefix(const String& prefix);
		String* get_range();
		void set_range(const String& range);
		String* get_speakAs();
		void set_speakAs(const String& speakAs);
		String* get_suffix();
		void set_suffix(const String& suffix);
		String* get_symbols();
		void set_symbols(const String& symbols);
		String* get_system();
		void set_system(const String& system);
		static CSSCounterStyleRule* prototype;
		CSSCounterStyleRule();
	};
	class CSSStyleDeclaration;
	class CSSFontFaceRule: public CSSRule {
	public:
		CSSStyleDeclaration* get_style();
		static CSSFontFaceRule* prototype;
		CSSFontFaceRule();
	};
	class CSSFontFeatureValuesRule: public CSSRule {
	public:
		String* get_fontFamily();
		void set_fontFamily(const String& fontFamily);
		static CSSFontFeatureValuesRule* prototype;
		CSSFontFeatureValuesRule();
	};
	class CSSFontPaletteValuesRule: public CSSRule {
	public:
		String* get_basePalette();
		String* get_fontFamily();
		String* get_name();
		String* get_overrideColors();
		static CSSFontPaletteValuesRule* prototype;
		CSSFontPaletteValuesRule();
	};
	class CSSStyleValue: public Object {
	public:
		String* toString();
		static CSSStyleValue* prototype;
		CSSStyleValue();
	};
	class CSSImageValue: public CSSStyleValue {
	public:
		static CSSImageValue* prototype;
		CSSImageValue();
	};
	class CSSImportRule: public CSSRule {
	public:
		String* get_href();
		String* get_layerName();
		MediaList* get_media();
		CSSStyleSheet* get_styleSheet();
		static CSSImportRule* prototype;
		CSSImportRule();
	};
	class CSSKeyframeRule: public CSSRule {
	public:
		String* get_keyText();
		void set_keyText(const String& keyText);
		CSSStyleDeclaration* get_style();
		static CSSKeyframeRule* prototype;
		CSSKeyframeRule();
	};
	class CSSKeyframesRule: public CSSRule {
	public:
		CSSRuleList* get_cssRules();
		int get_length() const;
		String* get_name();
		void set_name(const String& name);
		void appendRule(const String& rule);
		void deleteRule(const String& select);
		CSSKeyframeRule* findRule(const String& select);
		CSSKeyframeRule* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		CSSKeyframeRule*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::CSSKeyframeRule*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static CSSKeyframesRule* prototype;
		CSSKeyframesRule();
	public:
		using client::Object::operator[];
	};
	class CSSKeywordValue: public CSSStyleValue {
	public:
		String* get_value();
		void set_value(const String& value);
		static CSSKeywordValue* prototype;
		CSSKeywordValue(const String& value);
	};
	class CSSLayerBlockRule: public CSSGroupingRule {
	public:
		String* get_name();
		static CSSLayerBlockRule* prototype;
		CSSLayerBlockRule();
	};
	class CSSLayerStatementRule: public CSSRule {
	public:
		ReadonlyArray<String*>* get_nameList();
		static CSSLayerStatementRule* prototype;
		CSSLayerStatementRule();
	};
	class CSSUnitValue;
	class CSSMathSum;
	class CSSNumericValue: public CSSStyleValue {
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		CSSNumericValue* add(_Args... values) {
			return _add(cheerp::clientCast(values)...)->template cast<CSSNumericValue*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("add"))]]
		_Any* _add(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		CSSNumericValue* div(_Args... values) {
			return _div(cheerp::clientCast(values)...)->template cast<CSSNumericValue*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("div"))]]
		_Any* _div(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		bool equals(_Args... value) {
			return _equals(cheerp::clientCast(value)...)->template cast<bool>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("equals"))]]
		_Any* _equals(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		CSSNumericValue* max(_Args... values) {
			return _max(cheerp::clientCast(values)...)->template cast<CSSNumericValue*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("max"))]]
		_Any* _max(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		CSSNumericValue* min(_Args... values) {
			return _min(cheerp::clientCast(values)...)->template cast<CSSNumericValue*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("min"))]]
		_Any* _min(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		CSSNumericValue* mul(_Args... values) {
			return _mul(cheerp::clientCast(values)...)->template cast<CSSNumericValue*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("mul"))]]
		_Any* _mul(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		CSSNumericValue* sub(_Args... values) {
			return _sub(cheerp::clientCast(values)...)->template cast<CSSNumericValue*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("sub"))]]
		_Any* _sub(_Args... data);
	public:
		CSSUnitValue* to(const String& unit);
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, String*> && ...), CSSMathSum*> toSum(_Args... units) {
			return _toSum(cheerp::clientCast(units)...)->template cast<client::CSSMathSum*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("toSum"))]]
		_Any* _toSum(_Args... data);
	public:
		CSSNumericType* type();
		static CSSNumericValue* prototype;
		CSSNumericValue();
	};
	class CSSMathValue: public CSSNumericValue {
	public:
		[[cheerp::interface_name(("get_operator"))]]
		String* get_operator_();
		static CSSMathValue* prototype;
		CSSMathValue();
	};
	class CSSMathClamp: public CSSMathValue {
	public:
		CSSNumericValue* get_lower();
		CSSNumericValue* get_upper();
		CSSNumericValue* get_value();
		static CSSMathClamp* prototype;
		CSSMathClamp(const _Union<double, CSSNumericValue*>& lower, const _Union<double, CSSNumericValue*>& value, const _Union<double, CSSNumericValue*>& upper);
	};
	class CSSMathInvert: public CSSMathValue {
	public:
		CSSNumericValue* get_value();
		static CSSMathInvert* prototype;
		CSSMathInvert(const _Union<double, CSSNumericValue*>& arg);
	};
	class CSSNumericArray;
	class CSSMathMax: public CSSMathValue {
	public:
		CSSNumericArray* get_values();
		static CSSMathMax* prototype;
		template<class... _Args>
		CSSMathMax(_Args... args);
	};
	class CSSMathMin: public CSSMathValue {
	public:
		CSSNumericArray* get_values();
		static CSSMathMin* prototype;
		template<class... _Args>
		CSSMathMin(_Args... args);
	};
	class CSSMathNegate: public CSSMathValue {
	public:
		CSSNumericValue* get_value();
		static CSSMathNegate* prototype;
		CSSMathNegate(const _Union<double, CSSNumericValue*>& arg);
	};
	class CSSMathProduct: public CSSMathValue {
	public:
		CSSNumericArray* get_values();
		static CSSMathProduct* prototype;
		template<class... _Args>
		CSSMathProduct(_Args... args);
	};
	class CSSMathSum: public CSSMathValue {
	public:
		CSSNumericArray* get_values();
		static CSSMathSum* prototype;
		template<class... _Args>
		CSSMathSum(_Args... args);
	};
	class DOMMatrix;
	class DOMMatrixReadOnly;
	class CSSTransformComponent: public Object {
	public:
		bool get_is2D();
		void set_is2D(bool is2D);
		DOMMatrix* toMatrix();
		String* toString();
		static CSSTransformComponent* prototype;
		CSSTransformComponent();
	};
	class CSSMatrixComponent: public CSSTransformComponent {
	public:
		DOMMatrix* get_matrix();
		void set_matrix(DOMMatrix* matrix);
		static CSSMatrixComponent* prototype;
		CSSMatrixComponent(DOMMatrixReadOnly* matrix);
		CSSMatrixComponent(DOMMatrixReadOnly* matrix, CSSMatrixComponentOptions* options);
	};
	class CSSMediaRule: public CSSConditionRule {
	public:
		MediaList* get_media();
		static CSSMediaRule* prototype;
		CSSMediaRule();
	};
	class CSSNamespaceRule: public CSSRule {
	public:
		String* get_namespaceURI();
		String* get_prefix();
		static CSSNamespaceRule* prototype;
		CSSNamespaceRule();
	};
	class CSSNumericArray: public Object {
	public:
		int get_length() const;
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(CSSNumericValue*, double, CSSNumericArray*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(CSSNumericValue*, double, CSSNumericArray*)>& callbackfn, const _Any& thisArg);
		CSSNumericValue* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		CSSNumericValue*& operator[](double index) {
			return __builtin_cheerp_make_regular<CSSNumericValue*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static CSSNumericArray* prototype;
		CSSNumericArray();
	public:
		using client::Object::operator[];
	};
	class CSSPageRule: public CSSGroupingRule {
	public:
		String* get_selectorText();
		void set_selectorText(const String& selectorText);
		CSSStyleDeclaration* get_style();
		static CSSPageRule* prototype;
		CSSPageRule();
	};
	class CSSPerspective: public CSSTransformComponent {
	public:
		int get_length() const;
		void set_length(const String& length);
		void set_length(const _Union<CSSKeywordValue*, CSSNumericValue*>& length);
		static CSSPerspective* prototype;
		CSSPerspective(const String& length);
		CSSPerspective(const _Union<CSSKeywordValue*, CSSNumericValue*>& length);
	};
	class CSSPropertyRule: public CSSRule {
	public:
		bool get_inherits();
		String* get_initialValue();
		String* get_name();
		String* get_syntax();
		static CSSPropertyRule* prototype;
		CSSPropertyRule();
	};
	class CSSRotate: public CSSTransformComponent {
	public:
		CSSNumericValue* get_angle();
		void set_angle(CSSNumericValue* angle);
		_Union<double, CSSNumericValue*>* get_x();
		void set_x(const _Union<double, CSSNumericValue*>& x);
		_Union<double, CSSNumericValue*>* get_y();
		void set_y(const _Union<double, CSSNumericValue*>& y);
		_Union<double, CSSNumericValue*>* get_z();
		void set_z(const _Union<double, CSSNumericValue*>& z);
		static CSSRotate* prototype;
		CSSRotate(CSSNumericValue* angle);
		CSSRotate(const _Union<double, CSSNumericValue*>& x, const _Union<double, CSSNumericValue*>& y, const _Union<double, CSSNumericValue*>& z, CSSNumericValue* angle);
	};
	class CSSRuleList: public Object {
	public:
		int get_length() const;
		CSSRule* item(double index);
		CSSRule* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		CSSRule*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::CSSRule*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static CSSRuleList* prototype;
		CSSRuleList();
	public:
		using client::Object::operator[];
	};
	class CSSScale: public CSSTransformComponent {
	public:
		_Union<double, CSSNumericValue*>* get_x();
		void set_x(const _Union<double, CSSNumericValue*>& x);
		_Union<double, CSSNumericValue*>* get_y();
		void set_y(const _Union<double, CSSNumericValue*>& y);
		_Union<double, CSSNumericValue*>* get_z();
		void set_z(const _Union<double, CSSNumericValue*>& z);
		static CSSScale* prototype;
		CSSScale(const _Union<double, CSSNumericValue*>& x, const _Union<double, CSSNumericValue*>& y);
		CSSScale(const _Union<double, CSSNumericValue*>& x, const _Union<double, CSSNumericValue*>& y, const _Union<double, CSSNumericValue*>& z);
	};
	class CSSSkew: public CSSTransformComponent {
	public:
		CSSNumericValue* get_ax();
		void set_ax(CSSNumericValue* ax);
		CSSNumericValue* get_ay();
		void set_ay(CSSNumericValue* ay);
		static CSSSkew* prototype;
		CSSSkew(CSSNumericValue* ax, CSSNumericValue* ay);
	};
	class CSSSkewX: public CSSTransformComponent {
	public:
		CSSNumericValue* get_ax();
		void set_ax(CSSNumericValue* ax);
		static CSSSkewX* prototype;
		CSSSkewX(CSSNumericValue* ax);
	};
	class CSSSkewY: public CSSTransformComponent {
	public:
		CSSNumericValue* get_ay();
		void set_ay(CSSNumericValue* ay);
		static CSSSkewY* prototype;
		CSSSkewY(CSSNumericValue* ay);
	};
	class CSSStyleDeclaration: public Object {
	public:
		String* get_accentColor();
		void set_accentColor(const String& accentColor);
		String* get_alignContent();
		void set_alignContent(const String& alignContent);
		String* get_alignItems();
		void set_alignItems(const String& alignItems);
		String* get_alignSelf();
		void set_alignSelf(const String& alignSelf);
		String* get_alignmentBaseline();
		void set_alignmentBaseline(const String& alignmentBaseline);
		String* get_all();
		void set_all(const String& all);
		String* get_animation();
		void set_animation(const String& animation);
		String* get_animationComposition();
		void set_animationComposition(const String& animationComposition);
		String* get_animationDelay();
		void set_animationDelay(const String& animationDelay);
		String* get_animationDirection();
		void set_animationDirection(const String& animationDirection);
		String* get_animationDuration();
		void set_animationDuration(const String& animationDuration);
		String* get_animationFillMode();
		void set_animationFillMode(const String& animationFillMode);
		String* get_animationIterationCount();
		void set_animationIterationCount(const String& animationIterationCount);
		String* get_animationName();
		void set_animationName(const String& animationName);
		String* get_animationPlayState();
		void set_animationPlayState(const String& animationPlayState);
		String* get_animationTimingFunction();
		void set_animationTimingFunction(const String& animationTimingFunction);
		String* get_appearance();
		void set_appearance(const String& appearance);
		String* get_aspectRatio();
		void set_aspectRatio(const String& aspectRatio);
		String* get_backdropFilter();
		void set_backdropFilter(const String& backdropFilter);
		String* get_backfaceVisibility();
		void set_backfaceVisibility(const String& backfaceVisibility);
		String* get_background();
		void set_background(const String& background);
		String* get_backgroundAttachment();
		void set_backgroundAttachment(const String& backgroundAttachment);
		String* get_backgroundBlendMode();
		void set_backgroundBlendMode(const String& backgroundBlendMode);
		String* get_backgroundClip();
		void set_backgroundClip(const String& backgroundClip);
		String* get_backgroundColor();
		void set_backgroundColor(const String& backgroundColor);
		String* get_backgroundImage();
		void set_backgroundImage(const String& backgroundImage);
		String* get_backgroundOrigin();
		void set_backgroundOrigin(const String& backgroundOrigin);
		String* get_backgroundPosition();
		void set_backgroundPosition(const String& backgroundPosition);
		String* get_backgroundPositionX();
		void set_backgroundPositionX(const String& backgroundPositionX);
		String* get_backgroundPositionY();
		void set_backgroundPositionY(const String& backgroundPositionY);
		String* get_backgroundRepeat();
		void set_backgroundRepeat(const String& backgroundRepeat);
		String* get_backgroundSize();
		void set_backgroundSize(const String& backgroundSize);
		String* get_baselineShift();
		void set_baselineShift(const String& baselineShift);
		String* get_blockSize();
		void set_blockSize(const String& blockSize);
		String* get_border();
		void set_border(const String& border);
		String* get_borderBlock();
		void set_borderBlock(const String& borderBlock);
		String* get_borderBlockColor();
		void set_borderBlockColor(const String& borderBlockColor);
		String* get_borderBlockEnd();
		void set_borderBlockEnd(const String& borderBlockEnd);
		String* get_borderBlockEndColor();
		void set_borderBlockEndColor(const String& borderBlockEndColor);
		String* get_borderBlockEndStyle();
		void set_borderBlockEndStyle(const String& borderBlockEndStyle);
		String* get_borderBlockEndWidth();
		void set_borderBlockEndWidth(const String& borderBlockEndWidth);
		String* get_borderBlockStart();
		void set_borderBlockStart(const String& borderBlockStart);
		String* get_borderBlockStartColor();
		void set_borderBlockStartColor(const String& borderBlockStartColor);
		String* get_borderBlockStartStyle();
		void set_borderBlockStartStyle(const String& borderBlockStartStyle);
		String* get_borderBlockStartWidth();
		void set_borderBlockStartWidth(const String& borderBlockStartWidth);
		String* get_borderBlockStyle();
		void set_borderBlockStyle(const String& borderBlockStyle);
		String* get_borderBlockWidth();
		void set_borderBlockWidth(const String& borderBlockWidth);
		String* get_borderBottom();
		void set_borderBottom(const String& borderBottom);
		String* get_borderBottomColor();
		void set_borderBottomColor(const String& borderBottomColor);
		String* get_borderBottomLeftRadius();
		void set_borderBottomLeftRadius(const String& borderBottomLeftRadius);
		String* get_borderBottomRightRadius();
		void set_borderBottomRightRadius(const String& borderBottomRightRadius);
		String* get_borderBottomStyle();
		void set_borderBottomStyle(const String& borderBottomStyle);
		String* get_borderBottomWidth();
		void set_borderBottomWidth(const String& borderBottomWidth);
		String* get_borderCollapse();
		void set_borderCollapse(const String& borderCollapse);
		String* get_borderColor();
		void set_borderColor(const String& borderColor);
		String* get_borderEndEndRadius();
		void set_borderEndEndRadius(const String& borderEndEndRadius);
		String* get_borderEndStartRadius();
		void set_borderEndStartRadius(const String& borderEndStartRadius);
		String* get_borderImage();
		void set_borderImage(const String& borderImage);
		String* get_borderImageOutset();
		void set_borderImageOutset(const String& borderImageOutset);
		String* get_borderImageRepeat();
		void set_borderImageRepeat(const String& borderImageRepeat);
		String* get_borderImageSlice();
		void set_borderImageSlice(const String& borderImageSlice);
		String* get_borderImageSource();
		void set_borderImageSource(const String& borderImageSource);
		String* get_borderImageWidth();
		void set_borderImageWidth(const String& borderImageWidth);
		String* get_borderInline();
		void set_borderInline(const String& borderInline);
		String* get_borderInlineColor();
		void set_borderInlineColor(const String& borderInlineColor);
		String* get_borderInlineEnd();
		void set_borderInlineEnd(const String& borderInlineEnd);
		String* get_borderInlineEndColor();
		void set_borderInlineEndColor(const String& borderInlineEndColor);
		String* get_borderInlineEndStyle();
		void set_borderInlineEndStyle(const String& borderInlineEndStyle);
		String* get_borderInlineEndWidth();
		void set_borderInlineEndWidth(const String& borderInlineEndWidth);
		String* get_borderInlineStart();
		void set_borderInlineStart(const String& borderInlineStart);
		String* get_borderInlineStartColor();
		void set_borderInlineStartColor(const String& borderInlineStartColor);
		String* get_borderInlineStartStyle();
		void set_borderInlineStartStyle(const String& borderInlineStartStyle);
		String* get_borderInlineStartWidth();
		void set_borderInlineStartWidth(const String& borderInlineStartWidth);
		String* get_borderInlineStyle();
		void set_borderInlineStyle(const String& borderInlineStyle);
		String* get_borderInlineWidth();
		void set_borderInlineWidth(const String& borderInlineWidth);
		String* get_borderLeft();
		void set_borderLeft(const String& borderLeft);
		String* get_borderLeftColor();
		void set_borderLeftColor(const String& borderLeftColor);
		String* get_borderLeftStyle();
		void set_borderLeftStyle(const String& borderLeftStyle);
		String* get_borderLeftWidth();
		void set_borderLeftWidth(const String& borderLeftWidth);
		String* get_borderRadius();
		void set_borderRadius(const String& borderRadius);
		String* get_borderRight();
		void set_borderRight(const String& borderRight);
		String* get_borderRightColor();
		void set_borderRightColor(const String& borderRightColor);
		String* get_borderRightStyle();
		void set_borderRightStyle(const String& borderRightStyle);
		String* get_borderRightWidth();
		void set_borderRightWidth(const String& borderRightWidth);
		String* get_borderSpacing();
		void set_borderSpacing(const String& borderSpacing);
		String* get_borderStartEndRadius();
		void set_borderStartEndRadius(const String& borderStartEndRadius);
		String* get_borderStartStartRadius();
		void set_borderStartStartRadius(const String& borderStartStartRadius);
		String* get_borderStyle();
		void set_borderStyle(const String& borderStyle);
		String* get_borderTop();
		void set_borderTop(const String& borderTop);
		String* get_borderTopColor();
		void set_borderTopColor(const String& borderTopColor);
		String* get_borderTopLeftRadius();
		void set_borderTopLeftRadius(const String& borderTopLeftRadius);
		String* get_borderTopRightRadius();
		void set_borderTopRightRadius(const String& borderTopRightRadius);
		String* get_borderTopStyle();
		void set_borderTopStyle(const String& borderTopStyle);
		String* get_borderTopWidth();
		void set_borderTopWidth(const String& borderTopWidth);
		String* get_borderWidth();
		void set_borderWidth(const String& borderWidth);
		String* get_bottom();
		void set_bottom(const String& bottom);
		String* get_boxShadow();
		void set_boxShadow(const String& boxShadow);
		String* get_boxSizing();
		void set_boxSizing(const String& boxSizing);
		String* get_breakAfter();
		void set_breakAfter(const String& breakAfter);
		String* get_breakBefore();
		void set_breakBefore(const String& breakBefore);
		String* get_breakInside();
		void set_breakInside(const String& breakInside);
		String* get_captionSide();
		void set_captionSide(const String& captionSide);
		String* get_caretColor();
		void set_caretColor(const String& caretColor);
		String* get_clear();
		void set_clear(const String& clear);
		String* get_clip();
		void set_clip(const String& clip);
		String* get_clipPath();
		void set_clipPath(const String& clipPath);
		String* get_clipRule();
		void set_clipRule(const String& clipRule);
		String* get_color();
		void set_color(const String& color);
		String* get_colorInterpolation();
		void set_colorInterpolation(const String& colorInterpolation);
		String* get_colorInterpolationFilters();
		void set_colorInterpolationFilters(const String& colorInterpolationFilters);
		String* get_colorScheme();
		void set_colorScheme(const String& colorScheme);
		String* get_columnCount();
		void set_columnCount(const String& columnCount);
		String* get_columnFill();
		void set_columnFill(const String& columnFill);
		String* get_columnGap();
		void set_columnGap(const String& columnGap);
		String* get_columnRule();
		void set_columnRule(const String& columnRule);
		String* get_columnRuleColor();
		void set_columnRuleColor(const String& columnRuleColor);
		String* get_columnRuleStyle();
		void set_columnRuleStyle(const String& columnRuleStyle);
		String* get_columnRuleWidth();
		void set_columnRuleWidth(const String& columnRuleWidth);
		String* get_columnSpan();
		void set_columnSpan(const String& columnSpan);
		String* get_columnWidth();
		void set_columnWidth(const String& columnWidth);
		String* get_columns();
		void set_columns(const String& columns);
		String* get_contain();
		void set_contain(const String& contain);
		String* get_containIntrinsicBlockSize();
		void set_containIntrinsicBlockSize(const String& containIntrinsicBlockSize);
		String* get_containIntrinsicHeight();
		void set_containIntrinsicHeight(const String& containIntrinsicHeight);
		String* get_containIntrinsicInlineSize();
		void set_containIntrinsicInlineSize(const String& containIntrinsicInlineSize);
		String* get_containIntrinsicSize();
		void set_containIntrinsicSize(const String& containIntrinsicSize);
		String* get_containIntrinsicWidth();
		void set_containIntrinsicWidth(const String& containIntrinsicWidth);
		String* get_container();
		void set_container(const String& container);
		String* get_containerName();
		void set_containerName(const String& containerName);
		String* get_containerType();
		void set_containerType(const String& containerType);
		String* get_content();
		void set_content(const String& content);
		String* get_counterIncrement();
		void set_counterIncrement(const String& counterIncrement);
		String* get_counterReset();
		void set_counterReset(const String& counterReset);
		String* get_counterSet();
		void set_counterSet(const String& counterSet);
		String* get_cssFloat();
		void set_cssFloat(const String& cssFloat);
		String* get_cssText();
		void set_cssText(const String& cssText);
		String* get_cursor();
		void set_cursor(const String& cursor);
		String* get_direction();
		void set_direction(const String& direction);
		String* get_display();
		void set_display(const String& display);
		String* get_dominantBaseline();
		void set_dominantBaseline(const String& dominantBaseline);
		String* get_emptyCells();
		void set_emptyCells(const String& emptyCells);
		String* get_fill();
		void set_fill(const String& fill);
		String* get_fillOpacity();
		void set_fillOpacity(const String& fillOpacity);
		String* get_fillRule();
		void set_fillRule(const String& fillRule);
		String* get_filter();
		void set_filter(const String& filter);
		String* get_flex();
		void set_flex(const String& flex);
		String* get_flexBasis();
		void set_flexBasis(const String& flexBasis);
		String* get_flexDirection();
		void set_flexDirection(const String& flexDirection);
		String* get_flexFlow();
		void set_flexFlow(const String& flexFlow);
		String* get_flexGrow();
		void set_flexGrow(const String& flexGrow);
		String* get_flexShrink();
		void set_flexShrink(const String& flexShrink);
		String* get_flexWrap();
		void set_flexWrap(const String& flexWrap);
		[[cheerp::interface_name(("get_float"))]]
		String* get_float_();
		[[cheerp::interface_name(("set_float"))]]
		void set_float_(const String& float_);
		String* get_floodColor();
		void set_floodColor(const String& floodColor);
		String* get_floodOpacity();
		void set_floodOpacity(const String& floodOpacity);
		String* get_font();
		void set_font(const String& font);
		String* get_fontFamily();
		void set_fontFamily(const String& fontFamily);
		String* get_fontFeatureSettings();
		void set_fontFeatureSettings(const String& fontFeatureSettings);
		String* get_fontKerning();
		void set_fontKerning(const String& fontKerning);
		String* get_fontOpticalSizing();
		void set_fontOpticalSizing(const String& fontOpticalSizing);
		String* get_fontPalette();
		void set_fontPalette(const String& fontPalette);
		String* get_fontSize();
		void set_fontSize(const String& fontSize);
		String* get_fontSizeAdjust();
		void set_fontSizeAdjust(const String& fontSizeAdjust);
		String* get_fontStretch();
		void set_fontStretch(const String& fontStretch);
		String* get_fontStyle();
		void set_fontStyle(const String& fontStyle);
		String* get_fontSynthesis();
		void set_fontSynthesis(const String& fontSynthesis);
		String* get_fontSynthesisSmallCaps();
		void set_fontSynthesisSmallCaps(const String& fontSynthesisSmallCaps);
		String* get_fontSynthesisStyle();
		void set_fontSynthesisStyle(const String& fontSynthesisStyle);
		String* get_fontSynthesisWeight();
		void set_fontSynthesisWeight(const String& fontSynthesisWeight);
		String* get_fontVariant();
		void set_fontVariant(const String& fontVariant);
		String* get_fontVariantAlternates();
		void set_fontVariantAlternates(const String& fontVariantAlternates);
		String* get_fontVariantCaps();
		void set_fontVariantCaps(const String& fontVariantCaps);
		String* get_fontVariantEastAsian();
		void set_fontVariantEastAsian(const String& fontVariantEastAsian);
		String* get_fontVariantLigatures();
		void set_fontVariantLigatures(const String& fontVariantLigatures);
		String* get_fontVariantNumeric();
		void set_fontVariantNumeric(const String& fontVariantNumeric);
		String* get_fontVariantPosition();
		void set_fontVariantPosition(const String& fontVariantPosition);
		String* get_fontVariationSettings();
		void set_fontVariationSettings(const String& fontVariationSettings);
		String* get_fontWeight();
		void set_fontWeight(const String& fontWeight);
		String* get_forcedColorAdjust();
		void set_forcedColorAdjust(const String& forcedColorAdjust);
		String* get_gap();
		void set_gap(const String& gap);
		String* get_grid();
		void set_grid(const String& grid);
		String* get_gridArea();
		void set_gridArea(const String& gridArea);
		String* get_gridAutoColumns();
		void set_gridAutoColumns(const String& gridAutoColumns);
		String* get_gridAutoFlow();
		void set_gridAutoFlow(const String& gridAutoFlow);
		String* get_gridAutoRows();
		void set_gridAutoRows(const String& gridAutoRows);
		String* get_gridColumn();
		void set_gridColumn(const String& gridColumn);
		String* get_gridColumnEnd();
		void set_gridColumnEnd(const String& gridColumnEnd);
		String* get_gridColumnGap();
		void set_gridColumnGap(const String& gridColumnGap);
		String* get_gridColumnStart();
		void set_gridColumnStart(const String& gridColumnStart);
		String* get_gridGap();
		void set_gridGap(const String& gridGap);
		String* get_gridRow();
		void set_gridRow(const String& gridRow);
		String* get_gridRowEnd();
		void set_gridRowEnd(const String& gridRowEnd);
		String* get_gridRowGap();
		void set_gridRowGap(const String& gridRowGap);
		String* get_gridRowStart();
		void set_gridRowStart(const String& gridRowStart);
		String* get_gridTemplate();
		void set_gridTemplate(const String& gridTemplate);
		String* get_gridTemplateAreas();
		void set_gridTemplateAreas(const String& gridTemplateAreas);
		String* get_gridTemplateColumns();
		void set_gridTemplateColumns(const String& gridTemplateColumns);
		String* get_gridTemplateRows();
		void set_gridTemplateRows(const String& gridTemplateRows);
		String* get_height();
		void set_height(const String& height);
		String* get_hyphenateCharacter();
		void set_hyphenateCharacter(const String& hyphenateCharacter);
		String* get_hyphens();
		void set_hyphens(const String& hyphens);
		String* get_imageOrientation();
		void set_imageOrientation(const String& imageOrientation);
		String* get_imageRendering();
		void set_imageRendering(const String& imageRendering);
		String* get_inlineSize();
		void set_inlineSize(const String& inlineSize);
		String* get_inset();
		void set_inset(const String& inset);
		String* get_insetBlock();
		void set_insetBlock(const String& insetBlock);
		String* get_insetBlockEnd();
		void set_insetBlockEnd(const String& insetBlockEnd);
		String* get_insetBlockStart();
		void set_insetBlockStart(const String& insetBlockStart);
		String* get_insetInline();
		void set_insetInline(const String& insetInline);
		String* get_insetInlineEnd();
		void set_insetInlineEnd(const String& insetInlineEnd);
		String* get_insetInlineStart();
		void set_insetInlineStart(const String& insetInlineStart);
		String* get_isolation();
		void set_isolation(const String& isolation);
		String* get_justifyContent();
		void set_justifyContent(const String& justifyContent);
		String* get_justifyItems();
		void set_justifyItems(const String& justifyItems);
		String* get_justifySelf();
		void set_justifySelf(const String& justifySelf);
		String* get_left();
		void set_left(const String& left);
		int get_length() const;
		String* get_letterSpacing();
		void set_letterSpacing(const String& letterSpacing);
		String* get_lightingColor();
		void set_lightingColor(const String& lightingColor);
		String* get_lineBreak();
		void set_lineBreak(const String& lineBreak);
		String* get_lineHeight();
		void set_lineHeight(const String& lineHeight);
		String* get_listStyle();
		void set_listStyle(const String& listStyle);
		String* get_listStyleImage();
		void set_listStyleImage(const String& listStyleImage);
		String* get_listStylePosition();
		void set_listStylePosition(const String& listStylePosition);
		String* get_listStyleType();
		void set_listStyleType(const String& listStyleType);
		String* get_margin();
		void set_margin(const String& margin);
		String* get_marginBlock();
		void set_marginBlock(const String& marginBlock);
		String* get_marginBlockEnd();
		void set_marginBlockEnd(const String& marginBlockEnd);
		String* get_marginBlockStart();
		void set_marginBlockStart(const String& marginBlockStart);
		String* get_marginBottom();
		void set_marginBottom(const String& marginBottom);
		String* get_marginInline();
		void set_marginInline(const String& marginInline);
		String* get_marginInlineEnd();
		void set_marginInlineEnd(const String& marginInlineEnd);
		String* get_marginInlineStart();
		void set_marginInlineStart(const String& marginInlineStart);
		String* get_marginLeft();
		void set_marginLeft(const String& marginLeft);
		String* get_marginRight();
		void set_marginRight(const String& marginRight);
		String* get_marginTop();
		void set_marginTop(const String& marginTop);
		String* get_marker();
		void set_marker(const String& marker);
		String* get_markerEnd();
		void set_markerEnd(const String& markerEnd);
		String* get_markerMid();
		void set_markerMid(const String& markerMid);
		String* get_markerStart();
		void set_markerStart(const String& markerStart);
		String* get_mask();
		void set_mask(const String& mask);
		String* get_maskClip();
		void set_maskClip(const String& maskClip);
		String* get_maskComposite();
		void set_maskComposite(const String& maskComposite);
		String* get_maskImage();
		void set_maskImage(const String& maskImage);
		String* get_maskMode();
		void set_maskMode(const String& maskMode);
		String* get_maskOrigin();
		void set_maskOrigin(const String& maskOrigin);
		String* get_maskPosition();
		void set_maskPosition(const String& maskPosition);
		String* get_maskRepeat();
		void set_maskRepeat(const String& maskRepeat);
		String* get_maskSize();
		void set_maskSize(const String& maskSize);
		String* get_maskType();
		void set_maskType(const String& maskType);
		String* get_mathStyle();
		void set_mathStyle(const String& mathStyle);
		String* get_maxBlockSize();
		void set_maxBlockSize(const String& maxBlockSize);
		String* get_maxHeight();
		void set_maxHeight(const String& maxHeight);
		String* get_maxInlineSize();
		void set_maxInlineSize(const String& maxInlineSize);
		String* get_maxWidth();
		void set_maxWidth(const String& maxWidth);
		String* get_minBlockSize();
		void set_minBlockSize(const String& minBlockSize);
		String* get_minHeight();
		void set_minHeight(const String& minHeight);
		String* get_minInlineSize();
		void set_minInlineSize(const String& minInlineSize);
		String* get_minWidth();
		void set_minWidth(const String& minWidth);
		String* get_mixBlendMode();
		void set_mixBlendMode(const String& mixBlendMode);
		String* get_objectFit();
		void set_objectFit(const String& objectFit);
		String* get_objectPosition();
		void set_objectPosition(const String& objectPosition);
		String* get_offset();
		void set_offset(const String& offset);
		String* get_offsetDistance();
		void set_offsetDistance(const String& offsetDistance);
		String* get_offsetPath();
		void set_offsetPath(const String& offsetPath);
		String* get_offsetRotate();
		void set_offsetRotate(const String& offsetRotate);
		String* get_opacity();
		void set_opacity(const String& opacity);
		String* get_order();
		void set_order(const String& order);
		String* get_orphans();
		void set_orphans(const String& orphans);
		String* get_outline();
		void set_outline(const String& outline);
		String* get_outlineColor();
		void set_outlineColor(const String& outlineColor);
		String* get_outlineOffset();
		void set_outlineOffset(const String& outlineOffset);
		String* get_outlineStyle();
		void set_outlineStyle(const String& outlineStyle);
		String* get_outlineWidth();
		void set_outlineWidth(const String& outlineWidth);
		String* get_overflow();
		void set_overflow(const String& overflow);
		String* get_overflowAnchor();
		void set_overflowAnchor(const String& overflowAnchor);
		String* get_overflowClipMargin();
		void set_overflowClipMargin(const String& overflowClipMargin);
		String* get_overflowWrap();
		void set_overflowWrap(const String& overflowWrap);
		String* get_overflowX();
		void set_overflowX(const String& overflowX);
		String* get_overflowY();
		void set_overflowY(const String& overflowY);
		String* get_overscrollBehavior();
		void set_overscrollBehavior(const String& overscrollBehavior);
		String* get_overscrollBehaviorBlock();
		void set_overscrollBehaviorBlock(const String& overscrollBehaviorBlock);
		String* get_overscrollBehaviorInline();
		void set_overscrollBehaviorInline(const String& overscrollBehaviorInline);
		String* get_overscrollBehaviorX();
		void set_overscrollBehaviorX(const String& overscrollBehaviorX);
		String* get_overscrollBehaviorY();
		void set_overscrollBehaviorY(const String& overscrollBehaviorY);
		String* get_padding();
		void set_padding(const String& padding);
		String* get_paddingBlock();
		void set_paddingBlock(const String& paddingBlock);
		String* get_paddingBlockEnd();
		void set_paddingBlockEnd(const String& paddingBlockEnd);
		String* get_paddingBlockStart();
		void set_paddingBlockStart(const String& paddingBlockStart);
		String* get_paddingBottom();
		void set_paddingBottom(const String& paddingBottom);
		String* get_paddingInline();
		void set_paddingInline(const String& paddingInline);
		String* get_paddingInlineEnd();
		void set_paddingInlineEnd(const String& paddingInlineEnd);
		String* get_paddingInlineStart();
		void set_paddingInlineStart(const String& paddingInlineStart);
		String* get_paddingLeft();
		void set_paddingLeft(const String& paddingLeft);
		String* get_paddingRight();
		void set_paddingRight(const String& paddingRight);
		String* get_paddingTop();
		void set_paddingTop(const String& paddingTop);
		String* get_page();
		void set_page(const String& page);
		String* get_pageBreakAfter();
		void set_pageBreakAfter(const String& pageBreakAfter);
		String* get_pageBreakBefore();
		void set_pageBreakBefore(const String& pageBreakBefore);
		String* get_pageBreakInside();
		void set_pageBreakInside(const String& pageBreakInside);
		String* get_paintOrder();
		void set_paintOrder(const String& paintOrder);
		CSSRule* get_parentRule();
		String* get_perspective();
		void set_perspective(const String& perspective);
		String* get_perspectiveOrigin();
		void set_perspectiveOrigin(const String& perspectiveOrigin);
		String* get_placeContent();
		void set_placeContent(const String& placeContent);
		String* get_placeItems();
		void set_placeItems(const String& placeItems);
		String* get_placeSelf();
		void set_placeSelf(const String& placeSelf);
		String* get_pointerEvents();
		void set_pointerEvents(const String& pointerEvents);
		String* get_position();
		void set_position(const String& position);
		String* get_printColorAdjust();
		void set_printColorAdjust(const String& printColorAdjust);
		String* get_quotes();
		void set_quotes(const String& quotes);
		String* get_resize();
		void set_resize(const String& resize);
		String* get_right();
		void set_right(const String& right);
		String* get_rotate();
		void set_rotate(const String& rotate);
		String* get_rowGap();
		void set_rowGap(const String& rowGap);
		String* get_rubyPosition();
		void set_rubyPosition(const String& rubyPosition);
		String* get_scale();
		void set_scale(const String& scale);
		String* get_scrollBehavior();
		void set_scrollBehavior(const String& scrollBehavior);
		String* get_scrollMargin();
		void set_scrollMargin(const String& scrollMargin);
		String* get_scrollMarginBlock();
		void set_scrollMarginBlock(const String& scrollMarginBlock);
		String* get_scrollMarginBlockEnd();
		void set_scrollMarginBlockEnd(const String& scrollMarginBlockEnd);
		String* get_scrollMarginBlockStart();
		void set_scrollMarginBlockStart(const String& scrollMarginBlockStart);
		String* get_scrollMarginBottom();
		void set_scrollMarginBottom(const String& scrollMarginBottom);
		String* get_scrollMarginInline();
		void set_scrollMarginInline(const String& scrollMarginInline);
		String* get_scrollMarginInlineEnd();
		void set_scrollMarginInlineEnd(const String& scrollMarginInlineEnd);
		String* get_scrollMarginInlineStart();
		void set_scrollMarginInlineStart(const String& scrollMarginInlineStart);
		String* get_scrollMarginLeft();
		void set_scrollMarginLeft(const String& scrollMarginLeft);
		String* get_scrollMarginRight();
		void set_scrollMarginRight(const String& scrollMarginRight);
		String* get_scrollMarginTop();
		void set_scrollMarginTop(const String& scrollMarginTop);
		String* get_scrollPadding();
		void set_scrollPadding(const String& scrollPadding);
		String* get_scrollPaddingBlock();
		void set_scrollPaddingBlock(const String& scrollPaddingBlock);
		String* get_scrollPaddingBlockEnd();
		void set_scrollPaddingBlockEnd(const String& scrollPaddingBlockEnd);
		String* get_scrollPaddingBlockStart();
		void set_scrollPaddingBlockStart(const String& scrollPaddingBlockStart);
		String* get_scrollPaddingBottom();
		void set_scrollPaddingBottom(const String& scrollPaddingBottom);
		String* get_scrollPaddingInline();
		void set_scrollPaddingInline(const String& scrollPaddingInline);
		String* get_scrollPaddingInlineEnd();
		void set_scrollPaddingInlineEnd(const String& scrollPaddingInlineEnd);
		String* get_scrollPaddingInlineStart();
		void set_scrollPaddingInlineStart(const String& scrollPaddingInlineStart);
		String* get_scrollPaddingLeft();
		void set_scrollPaddingLeft(const String& scrollPaddingLeft);
		String* get_scrollPaddingRight();
		void set_scrollPaddingRight(const String& scrollPaddingRight);
		String* get_scrollPaddingTop();
		void set_scrollPaddingTop(const String& scrollPaddingTop);
		String* get_scrollSnapAlign();
		void set_scrollSnapAlign(const String& scrollSnapAlign);
		String* get_scrollSnapStop();
		void set_scrollSnapStop(const String& scrollSnapStop);
		String* get_scrollSnapType();
		void set_scrollSnapType(const String& scrollSnapType);
		String* get_scrollbarGutter();
		void set_scrollbarGutter(const String& scrollbarGutter);
		String* get_shapeImageThreshold();
		void set_shapeImageThreshold(const String& shapeImageThreshold);
		String* get_shapeMargin();
		void set_shapeMargin(const String& shapeMargin);
		String* get_shapeOutside();
		void set_shapeOutside(const String& shapeOutside);
		String* get_shapeRendering();
		void set_shapeRendering(const String& shapeRendering);
		String* get_stopColor();
		void set_stopColor(const String& stopColor);
		String* get_stopOpacity();
		void set_stopOpacity(const String& stopOpacity);
		String* get_stroke();
		void set_stroke(const String& stroke);
		String* get_strokeDasharray();
		void set_strokeDasharray(const String& strokeDasharray);
		String* get_strokeDashoffset();
		void set_strokeDashoffset(const String& strokeDashoffset);
		String* get_strokeLinecap();
		void set_strokeLinecap(const String& strokeLinecap);
		String* get_strokeLinejoin();
		void set_strokeLinejoin(const String& strokeLinejoin);
		String* get_strokeMiterlimit();
		void set_strokeMiterlimit(const String& strokeMiterlimit);
		String* get_strokeOpacity();
		void set_strokeOpacity(const String& strokeOpacity);
		String* get_strokeWidth();
		void set_strokeWidth(const String& strokeWidth);
		String* get_tabSize();
		void set_tabSize(const String& tabSize);
		String* get_tableLayout();
		void set_tableLayout(const String& tableLayout);
		String* get_textAlign();
		void set_textAlign(const String& textAlign);
		String* get_textAlignLast();
		void set_textAlignLast(const String& textAlignLast);
		String* get_textAnchor();
		void set_textAnchor(const String& textAnchor);
		String* get_textCombineUpright();
		void set_textCombineUpright(const String& textCombineUpright);
		String* get_textDecoration();
		void set_textDecoration(const String& textDecoration);
		String* get_textDecorationColor();
		void set_textDecorationColor(const String& textDecorationColor);
		String* get_textDecorationLine();
		void set_textDecorationLine(const String& textDecorationLine);
		String* get_textDecorationSkipInk();
		void set_textDecorationSkipInk(const String& textDecorationSkipInk);
		String* get_textDecorationStyle();
		void set_textDecorationStyle(const String& textDecorationStyle);
		String* get_textDecorationThickness();
		void set_textDecorationThickness(const String& textDecorationThickness);
		String* get_textEmphasis();
		void set_textEmphasis(const String& textEmphasis);
		String* get_textEmphasisColor();
		void set_textEmphasisColor(const String& textEmphasisColor);
		String* get_textEmphasisPosition();
		void set_textEmphasisPosition(const String& textEmphasisPosition);
		String* get_textEmphasisStyle();
		void set_textEmphasisStyle(const String& textEmphasisStyle);
		String* get_textIndent();
		void set_textIndent(const String& textIndent);
		String* get_textOrientation();
		void set_textOrientation(const String& textOrientation);
		String* get_textOverflow();
		void set_textOverflow(const String& textOverflow);
		String* get_textRendering();
		void set_textRendering(const String& textRendering);
		String* get_textShadow();
		void set_textShadow(const String& textShadow);
		String* get_textTransform();
		void set_textTransform(const String& textTransform);
		String* get_textUnderlineOffset();
		void set_textUnderlineOffset(const String& textUnderlineOffset);
		String* get_textUnderlinePosition();
		void set_textUnderlinePosition(const String& textUnderlinePosition);
		String* get_top();
		void set_top(const String& top);
		String* get_touchAction();
		void set_touchAction(const String& touchAction);
		String* get_transform();
		void set_transform(const String& transform);
		String* get_transformBox();
		void set_transformBox(const String& transformBox);
		String* get_transformOrigin();
		void set_transformOrigin(const String& transformOrigin);
		String* get_transformStyle();
		void set_transformStyle(const String& transformStyle);
		String* get_transition();
		void set_transition(const String& transition);
		String* get_transitionDelay();
		void set_transitionDelay(const String& transitionDelay);
		String* get_transitionDuration();
		void set_transitionDuration(const String& transitionDuration);
		String* get_transitionProperty();
		void set_transitionProperty(const String& transitionProperty);
		String* get_transitionTimingFunction();
		void set_transitionTimingFunction(const String& transitionTimingFunction);
		String* get_translate();
		void set_translate(const String& translate);
		String* get_unicodeBidi();
		void set_unicodeBidi(const String& unicodeBidi);
		String* get_userSelect();
		void set_userSelect(const String& userSelect);
		String* get_verticalAlign();
		void set_verticalAlign(const String& verticalAlign);
		String* get_visibility();
		void set_visibility(const String& visibility);
		String* get_webkitAlignContent();
		void set_webkitAlignContent(const String& webkitAlignContent);
		String* get_webkitAlignItems();
		void set_webkitAlignItems(const String& webkitAlignItems);
		String* get_webkitAlignSelf();
		void set_webkitAlignSelf(const String& webkitAlignSelf);
		String* get_webkitAnimation();
		void set_webkitAnimation(const String& webkitAnimation);
		String* get_webkitAnimationDelay();
		void set_webkitAnimationDelay(const String& webkitAnimationDelay);
		String* get_webkitAnimationDirection();
		void set_webkitAnimationDirection(const String& webkitAnimationDirection);
		String* get_webkitAnimationDuration();
		void set_webkitAnimationDuration(const String& webkitAnimationDuration);
		String* get_webkitAnimationFillMode();
		void set_webkitAnimationFillMode(const String& webkitAnimationFillMode);
		String* get_webkitAnimationIterationCount();
		void set_webkitAnimationIterationCount(const String& webkitAnimationIterationCount);
		String* get_webkitAnimationName();
		void set_webkitAnimationName(const String& webkitAnimationName);
		String* get_webkitAnimationPlayState();
		void set_webkitAnimationPlayState(const String& webkitAnimationPlayState);
		String* get_webkitAnimationTimingFunction();
		void set_webkitAnimationTimingFunction(const String& webkitAnimationTimingFunction);
		String* get_webkitAppearance();
		void set_webkitAppearance(const String& webkitAppearance);
		String* get_webkitBackfaceVisibility();
		void set_webkitBackfaceVisibility(const String& webkitBackfaceVisibility);
		String* get_webkitBackgroundClip();
		void set_webkitBackgroundClip(const String& webkitBackgroundClip);
		String* get_webkitBackgroundOrigin();
		void set_webkitBackgroundOrigin(const String& webkitBackgroundOrigin);
		String* get_webkitBackgroundSize();
		void set_webkitBackgroundSize(const String& webkitBackgroundSize);
		String* get_webkitBorderBottomLeftRadius();
		void set_webkitBorderBottomLeftRadius(const String& webkitBorderBottomLeftRadius);
		String* get_webkitBorderBottomRightRadius();
		void set_webkitBorderBottomRightRadius(const String& webkitBorderBottomRightRadius);
		String* get_webkitBorderRadius();
		void set_webkitBorderRadius(const String& webkitBorderRadius);
		String* get_webkitBorderTopLeftRadius();
		void set_webkitBorderTopLeftRadius(const String& webkitBorderTopLeftRadius);
		String* get_webkitBorderTopRightRadius();
		void set_webkitBorderTopRightRadius(const String& webkitBorderTopRightRadius);
		String* get_webkitBoxAlign();
		void set_webkitBoxAlign(const String& webkitBoxAlign);
		String* get_webkitBoxFlex();
		void set_webkitBoxFlex(const String& webkitBoxFlex);
		String* get_webkitBoxOrdinalGroup();
		void set_webkitBoxOrdinalGroup(const String& webkitBoxOrdinalGroup);
		String* get_webkitBoxOrient();
		void set_webkitBoxOrient(const String& webkitBoxOrient);
		String* get_webkitBoxPack();
		void set_webkitBoxPack(const String& webkitBoxPack);
		String* get_webkitBoxShadow();
		void set_webkitBoxShadow(const String& webkitBoxShadow);
		String* get_webkitBoxSizing();
		void set_webkitBoxSizing(const String& webkitBoxSizing);
		String* get_webkitFilter();
		void set_webkitFilter(const String& webkitFilter);
		String* get_webkitFlex();
		void set_webkitFlex(const String& webkitFlex);
		String* get_webkitFlexBasis();
		void set_webkitFlexBasis(const String& webkitFlexBasis);
		String* get_webkitFlexDirection();
		void set_webkitFlexDirection(const String& webkitFlexDirection);
		String* get_webkitFlexFlow();
		void set_webkitFlexFlow(const String& webkitFlexFlow);
		String* get_webkitFlexGrow();
		void set_webkitFlexGrow(const String& webkitFlexGrow);
		String* get_webkitFlexShrink();
		void set_webkitFlexShrink(const String& webkitFlexShrink);
		String* get_webkitFlexWrap();
		void set_webkitFlexWrap(const String& webkitFlexWrap);
		String* get_webkitJustifyContent();
		void set_webkitJustifyContent(const String& webkitJustifyContent);
		String* get_webkitLineClamp();
		void set_webkitLineClamp(const String& webkitLineClamp);
		String* get_webkitMask();
		void set_webkitMask(const String& webkitMask);
		String* get_webkitMaskBoxImage();
		void set_webkitMaskBoxImage(const String& webkitMaskBoxImage);
		String* get_webkitMaskBoxImageOutset();
		void set_webkitMaskBoxImageOutset(const String& webkitMaskBoxImageOutset);
		String* get_webkitMaskBoxImageRepeat();
		void set_webkitMaskBoxImageRepeat(const String& webkitMaskBoxImageRepeat);
		String* get_webkitMaskBoxImageSlice();
		void set_webkitMaskBoxImageSlice(const String& webkitMaskBoxImageSlice);
		String* get_webkitMaskBoxImageSource();
		void set_webkitMaskBoxImageSource(const String& webkitMaskBoxImageSource);
		String* get_webkitMaskBoxImageWidth();
		void set_webkitMaskBoxImageWidth(const String& webkitMaskBoxImageWidth);
		String* get_webkitMaskClip();
		void set_webkitMaskClip(const String& webkitMaskClip);
		String* get_webkitMaskComposite();
		void set_webkitMaskComposite(const String& webkitMaskComposite);
		String* get_webkitMaskImage();
		void set_webkitMaskImage(const String& webkitMaskImage);
		String* get_webkitMaskOrigin();
		void set_webkitMaskOrigin(const String& webkitMaskOrigin);
		String* get_webkitMaskPosition();
		void set_webkitMaskPosition(const String& webkitMaskPosition);
		String* get_webkitMaskRepeat();
		void set_webkitMaskRepeat(const String& webkitMaskRepeat);
		String* get_webkitMaskSize();
		void set_webkitMaskSize(const String& webkitMaskSize);
		String* get_webkitOrder();
		void set_webkitOrder(const String& webkitOrder);
		String* get_webkitPerspective();
		void set_webkitPerspective(const String& webkitPerspective);
		String* get_webkitPerspectiveOrigin();
		void set_webkitPerspectiveOrigin(const String& webkitPerspectiveOrigin);
		String* get_webkitTextFillColor();
		void set_webkitTextFillColor(const String& webkitTextFillColor);
		String* get_webkitTextSizeAdjust();
		void set_webkitTextSizeAdjust(const String& webkitTextSizeAdjust);
		String* get_webkitTextStroke();
		void set_webkitTextStroke(const String& webkitTextStroke);
		String* get_webkitTextStrokeColor();
		void set_webkitTextStrokeColor(const String& webkitTextStrokeColor);
		String* get_webkitTextStrokeWidth();
		void set_webkitTextStrokeWidth(const String& webkitTextStrokeWidth);
		String* get_webkitTransform();
		void set_webkitTransform(const String& webkitTransform);
		String* get_webkitTransformOrigin();
		void set_webkitTransformOrigin(const String& webkitTransformOrigin);
		String* get_webkitTransformStyle();
		void set_webkitTransformStyle(const String& webkitTransformStyle);
		String* get_webkitTransition();
		void set_webkitTransition(const String& webkitTransition);
		String* get_webkitTransitionDelay();
		void set_webkitTransitionDelay(const String& webkitTransitionDelay);
		String* get_webkitTransitionDuration();
		void set_webkitTransitionDuration(const String& webkitTransitionDuration);
		String* get_webkitTransitionProperty();
		void set_webkitTransitionProperty(const String& webkitTransitionProperty);
		String* get_webkitTransitionTimingFunction();
		void set_webkitTransitionTimingFunction(const String& webkitTransitionTimingFunction);
		String* get_webkitUserSelect();
		void set_webkitUserSelect(const String& webkitUserSelect);
		String* get_whiteSpace();
		void set_whiteSpace(const String& whiteSpace);
		String* get_widows();
		void set_widows(const String& widows);
		String* get_width();
		void set_width(const String& width);
		String* get_willChange();
		void set_willChange(const String& willChange);
		String* get_wordBreak();
		void set_wordBreak(const String& wordBreak);
		String* get_wordSpacing();
		void set_wordSpacing(const String& wordSpacing);
		String* get_wordWrap();
		void set_wordWrap(const String& wordWrap);
		String* get_writingMode();
		void set_writingMode(const String& writingMode);
		String* get_zIndex();
		void set_zIndex(const String& zIndex);
		String* getPropertyPriority(const String& property);
		String* getPropertyValue(const String& property);
		String* item(double index);
		String* removeProperty(const String& property);
		void setProperty(const String& property, const String& value);
		void setProperty(const String& property, const String& value, const String& priority);
		String* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		String*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::String*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static CSSStyleDeclaration* prototype;
		CSSStyleDeclaration();
	public:
		using client::Object::operator[];
	};
	class StylePropertyMap;
	class CSSStyleRule: public CSSRule {
	public:
		CSSRuleList* get_cssRules();
		String* get_selectorText();
		void set_selectorText(const String& selectorText);
		CSSStyleDeclaration* get_style();
		StylePropertyMap* get_styleMap();
		void deleteRule(double index);
		double insertRule(const String& rule);
		double insertRule(const String& rule, double index);
		static CSSStyleRule* prototype;
		CSSStyleRule();
	};
	class ProcessingInstruction;
	class StyleSheet: public Object {
	public:
		bool get_disabled();
		void set_disabled(bool disabled);
		String* get_href();
		MediaList* get_media();
		_Union<Element*, ProcessingInstruction*>* get_ownerNode();
		CSSStyleSheet* get_parentStyleSheet();
		String* get_title();
		String* get_type();
		static StyleSheet* prototype;
		StyleSheet();
	};
	class CSSStyleSheet: public StyleSheet {
	public:
		CSSRuleList* get_cssRules();
		CSSRule* get_ownerRule();
		CSSRuleList* get_rules();
		double addRule();
		double addRule(const String& selector);
		double addRule(const String& selector, const String& style);
		double addRule(const String& selector, const String& style, double index);
		void deleteRule(double index);
		double insertRule(const String& rule);
		double insertRule(const String& rule, double index);
		void removeRule();
		void removeRule(double index);
		Promise<CSSStyleSheet*>* replace(const String& text) const;
		void replaceSync(const String& text);
		static CSSStyleSheet* prototype;
		CSSStyleSheet();
		CSSStyleSheet(CSSStyleSheetInit* options);
	};
	class CSSSupportsRule: public CSSConditionRule {
	public:
		static CSSSupportsRule* prototype;
		CSSSupportsRule();
	};
	class CSSTransformValue: public CSSStyleValue {
	public:
		bool get_is2D();
		int get_length() const;
		DOMMatrix* toMatrix();
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(CSSTransformComponent*, double, CSSTransformValue*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(CSSTransformComponent*, double, CSSTransformValue*)>& callbackfn, const _Any& thisArg);
		CSSTransformComponent* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		CSSTransformComponent*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::CSSTransformComponent*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static CSSTransformValue* prototype;
		CSSTransformValue(TArray<CSSTransformComponent*>* transforms);
	public:
		using client::Object::operator[];
	};
	class CSSTransition: public Animation {
	public:
		String* get_transitionProperty();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static CSSTransition* prototype;
		CSSTransition();
	};
	class CSSTranslate: public CSSTransformComponent {
	public:
		CSSNumericValue* get_x();
		void set_x(CSSNumericValue* x);
		CSSNumericValue* get_y();
		void set_y(CSSNumericValue* y);
		CSSNumericValue* get_z();
		void set_z(CSSNumericValue* z);
		static CSSTranslate* prototype;
		CSSTranslate(CSSNumericValue* x, CSSNumericValue* y);
		CSSTranslate(CSSNumericValue* x, CSSNumericValue* y, CSSNumericValue* z);
	};
	class CSSUnitValue: public CSSNumericValue {
	public:
		String* get_unit();
		double get_value();
		void set_value(double value);
		static CSSUnitValue* prototype;
		CSSUnitValue(double value, const String& unit);
	};
	class CSSVariableReferenceValue;
	class CSSUnparsedValue: public CSSStyleValue {
	public:
		int get_length() const;
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(_Union<String*, CSSVariableReferenceValue*>*, double, CSSUnparsedValue*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(_Union<String*, CSSVariableReferenceValue*>*, double, CSSUnparsedValue*)>& callbackfn, const _Any& thisArg);
		_Union<String*, CSSVariableReferenceValue*>* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		_Union<String*, CSSVariableReferenceValue*>* operator[](double index) {
			return __builtin_cheerp_make_regular<_Union<client::String*, CSSVariableReferenceValue*>*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static CSSUnparsedValue* prototype;
		CSSUnparsedValue(Array* members);
	public:
		using client::Object::operator[];
	};
	class CSSVariableReferenceValue: public Object {
	public:
		CSSUnparsedValue* get_fallback();
		String* get_variable();
		void set_variable(const String& variable);
		static CSSVariableReferenceValue* prototype;
		CSSVariableReferenceValue(const String& variable);
		CSSVariableReferenceValue(const String& variable, CSSUnparsedValue* fallback);
	};
	class Request;
	class Response;
	class Cache: public Object {
	public:
		Promise<_Any*>* add(const String& request);
		Promise<_Any*>* add(const _Union<Request*, URL*>& request);
		Promise<_Any*>* addAll(Array* requests);
		[[cheerp::interface_name(("delete"))]]
		Promise<bool>* delete_(const String& request);
		[[cheerp::interface_name(("delete"))]]
		Promise<bool>* delete_(const _Union<Request*, URL*>& request);
		[[cheerp::interface_name(("delete"))]]
		Promise<bool>* delete_(const String& request, CacheQueryOptions* options);
		[[cheerp::interface_name(("delete"))]]
		Promise<bool>* delete_(const _Union<Request*, URL*>& request, CacheQueryOptions* options);
		Promise<ReadonlyArray<Request*>*>* keys();
		Promise<ReadonlyArray<Request*>*>* keys(const String& request);
		Promise<ReadonlyArray<Request*>*>* keys(const _Union<Request*, URL*>& request);
		Promise<ReadonlyArray<Request*>*>* keys(const String& request, CacheQueryOptions* options);
		Promise<ReadonlyArray<Request*>*>* keys(const _Union<Request*, URL*>& request, CacheQueryOptions* options);
		Promise<Response*>* match(const String& request);
		Promise<Response*>* match(const _Union<Request*, URL*>& request);
		Promise<Response*>* match(const String& request, CacheQueryOptions* options);
		Promise<Response*>* match(const _Union<Request*, URL*>& request, CacheQueryOptions* options);
		Promise<ReadonlyArray<Response*>*>* matchAll();
		Promise<ReadonlyArray<Response*>*>* matchAll(const String& request);
		Promise<ReadonlyArray<Response*>*>* matchAll(const _Union<Request*, URL*>& request);
		Promise<ReadonlyArray<Response*>*>* matchAll(const String& request, CacheQueryOptions* options);
		Promise<ReadonlyArray<Response*>*>* matchAll(const _Union<Request*, URL*>& request, CacheQueryOptions* options);
		Promise<_Any*>* put(const String& request, Response* response);
		Promise<_Any*>* put(const _Union<Request*, URL*>& request, Response* response);
		static Cache* prototype;
		Cache();
	};
	class CacheStorage: public Object {
	public:
		[[cheerp::interface_name(("delete"))]]
		Promise<bool>* delete_(const String& cacheName);
		Promise<bool>* has(const String& cacheName);
		Promise<TArray<String*>*>* keys();
		Promise<Response*>* match(const String& request);
		Promise<Response*>* match(const _Union<Request*, URL*>& request);
		Promise<Response*>* match(const String& request, MultiCacheQueryOptions* options);
		Promise<Response*>* match(const _Union<Request*, URL*>& request, MultiCacheQueryOptions* options);
		Promise<Cache*>* open(const String& cacheName);
		static CacheStorage* prototype;
		CacheStorage();
	};
	class HTMLCanvasElement;
	class MediaStreamTrack: public EventTarget {
	public:
		String* get_contentHint();
		void set_contentHint(const String& contentHint);
		bool get_enabled();
		void set_enabled(bool enabled);
		String* get_id();
		String* get_kind();
		String* get_label();
		bool get_muted();
		_Function<_Any*(Event*)>* get_onended();
		void set_onended(EventListener* onended);
		void set_onended(const _Function<_Any*(Event*)>& onended);
		_Function<_Any*(Event*)>* get_onmute();
		void set_onmute(EventListener* onmute);
		void set_onmute(const _Function<_Any*(Event*)>& onmute);
		_Function<_Any*(Event*)>* get_onunmute();
		void set_onunmute(EventListener* onunmute);
		void set_onunmute(const _Function<_Any*(Event*)>& onunmute);
		String* get_readyState();
		Promise<_Any*>* applyConstraints();
		Promise<_Any*>* applyConstraints(MediaTrackConstraints* constraints);
		MediaStreamTrack* clone();
		MediaTrackCapabilities* getCapabilities();
		MediaTrackConstraints* getConstraints();
		MediaTrackSettings* getSettings();
		void stop();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MediaStreamTrack* prototype;
		MediaStreamTrack();
	};
	class CanvasCaptureMediaStreamTrack: public MediaStreamTrack {
	public:
		HTMLCanvasElement* get_canvas();
		void requestFrame();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static CanvasCaptureMediaStreamTrack* prototype;
		CanvasCaptureMediaStreamTrack();
	};
	class CanvasCompositing: public virtual Object {
	public:
		double get_globalAlpha();
		void set_globalAlpha(double globalAlpha);
		String* get_globalCompositeOperation();
		void set_globalCompositeOperation(const String& globalCompositeOperation);
	};
	class HTMLImageElement;
	class HTMLVideoElement;
	class ImageBitmap;
	class OffscreenCanvas;
	class SVGImageElement;
	class CanvasDrawImage: public virtual Object {
	public:
		void drawImage(const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double dx, double dy);
		void drawImage(const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double dx, double dy, double dw, double dh);
		void drawImage(const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh);
	};
	class Path2D;
	class CanvasDrawPath: public virtual Object {
	public:
		void beginPath();
		void clip();
		void clip(const String& fillRule);
		void clip(Path2D* path);
		void clip(Path2D* path, const String& fillRule);
		void fill();
		void fill(const String& fillRule);
		void fill(Path2D* path);
		void fill(Path2D* path, const String& fillRule);
		bool isPointInPath(double x, double y);
		bool isPointInPath(double x, double y, const String& fillRule);
		bool isPointInPath(Path2D* path, double x, double y);
		bool isPointInPath(Path2D* path, double x, double y, const String& fillRule);
		bool isPointInStroke(double x, double y);
		bool isPointInStroke(Path2D* path, double x, double y);
		void stroke();
		void stroke(Path2D* path);
	};
	class CanvasGradient;
	class CanvasPattern;
	class CanvasFillStrokeStyles: public virtual Object {
	public:
		_Union<String*, CanvasGradient*, CanvasPattern*>* get_fillStyle();
		void set_fillStyle(const String& fillStyle);
		void set_fillStyle(const _Union<CanvasGradient*, CanvasPattern*>& fillStyle);
		_Union<String*, CanvasGradient*, CanvasPattern*>* get_strokeStyle();
		void set_strokeStyle(const String& strokeStyle);
		void set_strokeStyle(const _Union<CanvasGradient*, CanvasPattern*>& strokeStyle);
		CanvasGradient* createConicGradient(double startAngle, double x, double y);
		CanvasGradient* createLinearGradient(double x0, double y0, double x1, double y1);
		CanvasPattern* createPattern(const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, const String& repetition);
		CanvasGradient* createRadialGradient(double x0, double y0, double r0, double x1, double y1, double r1);
	};
	class CanvasFilters: public virtual Object {
	public:
		String* get_filter();
		void set_filter(const String& filter);
	};
	class CanvasGradient: public Object {
	public:
		void addColorStop(double offset, const String& color);
		static CanvasGradient* prototype;
		CanvasGradient();
	};
	class ImageData;
	class CanvasImageData: public virtual Object {
	public:
		ImageData* createImageData(double sw, double sh);
		ImageData* createImageData(double sw, double sh, ImageDataSettings* settings);
		ImageData* createImageData(ImageData* imagedata);
		ImageData* getImageData(double sx, double sy, double sw, double sh);
		ImageData* getImageData(double sx, double sy, double sw, double sh, ImageDataSettings* settings);
		void putImageData(ImageData* imagedata, double dx, double dy);
		void putImageData(ImageData* imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight);
	};
	class CanvasImageSmoothing: public virtual Object {
	public:
		bool get_imageSmoothingEnabled();
		void set_imageSmoothingEnabled(bool imageSmoothingEnabled);
		String* get_imageSmoothingQuality();
		void set_imageSmoothingQuality(const String& imageSmoothingQuality);
	};
	class CanvasPath: public virtual Object {
	public:
		void arc(double x, double y, double radius, double startAngle, double endAngle);
		void arc(double x, double y, double radius, double startAngle, double endAngle, bool counterclockwise);
		void arcTo(double x1, double y1, double x2, double y2, double radius);
		void bezierCurveTo(double cp1x, double cp1y, double cp2x, double cp2y, double x, double y);
		void closePath();
		void ellipse(double x, double y, double radiusX, double radiusY, double rotation, double startAngle, double endAngle);
		void ellipse(double x, double y, double radiusX, double radiusY, double rotation, double startAngle, double endAngle, bool counterclockwise);
		void lineTo(double x, double y);
		void moveTo(double x, double y);
		void quadraticCurveTo(double cpx, double cpy, double x, double y);
		void rect(double x, double y, double w, double h);
		void roundRect(double x, double y, double w, double h);
		void roundRect(double x, double y, double w, double h, const _Union<double, DOMPointInit*, Array*>& radii);
	};
	class CanvasPathDrawingStyles: public virtual Object {
	public:
		String* get_lineCap();
		void set_lineCap(const String& lineCap);
		double get_lineDashOffset();
		void set_lineDashOffset(double lineDashOffset);
		String* get_lineJoin();
		void set_lineJoin(const String& lineJoin);
		double get_lineWidth();
		void set_lineWidth(double lineWidth);
		double get_miterLimit();
		void set_miterLimit(double miterLimit);
		TArray<double>* getLineDash();
		void setLineDash(TArray<double>* segments);
	};
	class CanvasPattern: public Object {
	public:
		void setTransform();
		void setTransform(DOMMatrix2DInit* transform);
		static CanvasPattern* prototype;
		CanvasPattern();
	};
	class CanvasRect: public virtual Object {
	public:
		void clearRect(double x, double y, double w, double h);
		void fillRect(double x, double y, double w, double h);
		void strokeRect(double x, double y, double w, double h);
	};
	class CanvasShadowStyles: public virtual Object {
	public:
		double get_shadowBlur();
		void set_shadowBlur(double shadowBlur);
		String* get_shadowColor();
		void set_shadowColor(const String& shadowColor);
		double get_shadowOffsetX();
		void set_shadowOffsetX(double shadowOffsetX);
		double get_shadowOffsetY();
		void set_shadowOffsetY(double shadowOffsetY);
	};
	class CanvasState: public virtual Object {
	public:
		void reset();
		void restore();
		void save();
	};
	class TextMetrics;
	class CanvasText: public virtual Object {
	public:
		void fillText(const String& text, double x, double y);
		void fillText(const String& text, double x, double y, double maxWidth);
		TextMetrics* measureText(const String& text);
		void strokeText(const String& text, double x, double y);
		void strokeText(const String& text, double x, double y, double maxWidth);
	};
	class CanvasTextDrawingStyles: public virtual Object {
	public:
		String* get_direction();
		void set_direction(const String& direction);
		String* get_font();
		void set_font(const String& font);
		String* get_fontKerning();
		void set_fontKerning(const String& fontKerning);
		String* get_textAlign();
		void set_textAlign(const String& textAlign);
		String* get_textBaseline();
		void set_textBaseline(const String& textBaseline);
	};
	class CanvasTransform: public virtual Object {
	public:
		DOMMatrix* getTransform();
		void resetTransform();
		void rotate(double angle);
		void scale(double x, double y);
		void setTransform(double a, double b, double c, double d, double e, double f);
		void setTransform();
		void setTransform(DOMMatrix2DInit* transform);
		void transform(double a, double b, double c, double d, double e, double f);
		void translate(double x, double y);
	};
	class CanvasUserInterface: public virtual Object {
	public:
		void drawFocusIfNeeded(Element* element);
		void drawFocusIfNeeded(Path2D* path, Element* element);
	};
	class CanvasRenderingContext2D: public CanvasCompositing, public CanvasDrawImage, public CanvasDrawPath, public CanvasFillStrokeStyles, public CanvasFilters, public CanvasImageData, public CanvasImageSmoothing, public CanvasPath, public CanvasPathDrawingStyles, public CanvasRect, public CanvasShadowStyles, public CanvasState, public CanvasText, public CanvasTextDrawingStyles, public CanvasTransform, public CanvasUserInterface {
	public:
		HTMLCanvasElement* get_canvas();
		CanvasRenderingContext2DSettings* getContextAttributes();
		static CanvasRenderingContext2D* prototype;
		CanvasRenderingContext2D();
	};
	class ChannelMergerNode: public AudioNode {
	public:
		static ChannelMergerNode* prototype;
		ChannelMergerNode(BaseAudioContext* context);
		ChannelMergerNode(BaseAudioContext* context, ChannelMergerOptions* options);
	};
	class ChannelSplitterNode: public AudioNode {
	public:
		static ChannelSplitterNode* prototype;
		ChannelSplitterNode(BaseAudioContext* context);
		ChannelSplitterNode(BaseAudioContext* context, ChannelSplitterOptions* options);
	};
	class DOMRectReadOnly: public Object {
	public:
		double get_bottom();
		double get_height();
		double get_left();
		double get_right();
		double get_top();
		double get_width();
		double get_x();
		double get_y();
		Object* toJSON();
		static DOMRectReadOnly* prototype;
		DOMRectReadOnly();
		DOMRectReadOnly(double x);
		DOMRectReadOnly(double x, double y);
		DOMRectReadOnly(double x, double y, double width);
		DOMRectReadOnly(double x, double y, double width, double height);
		static DOMRectReadOnly* fromRect();
		static DOMRectReadOnly* fromRect(DOMRectInit* other);
	};
	class DOMRect: public DOMRectReadOnly {
	public:
		double get_height();
		void set_height(double height);
		double get_width();
		void set_width(double width);
		double get_x();
		void set_x(double x);
		double get_y();
		void set_y(double y);
		static DOMRect* prototype;
		DOMRect();
		DOMRect(double x);
		DOMRect(double x, double y);
		DOMRect(double x, double y, double width);
		DOMRect(double x, double y, double width, double height);
		static DOMRect* fromRect();
		static DOMRect* fromRect(DOMRectInit* other);
	};
	class ClientRect: public DOMRect {
	};
	class ClipboardItem;
	class Clipboard: public EventTarget {
	public:
		Promise<TArray<ClipboardItem*>*>* read();
		Promise<String*>* readText();
		Promise<_Any*>* write(TArray<ClipboardItem*>* data);
		Promise<_Any*>* writeText(const String& data);
		static Clipboard* prototype;
		Clipboard();
	};
	class ClipboardEvent: public Event {
	public:
		DataTransfer* get_clipboardData();
		static ClipboardEvent* prototype;
		ClipboardEvent(const String& type);
		ClipboardEvent(const String& type, ClipboardEventInit* eventInitDict);
	};
	class ClipboardItem: public Object {
	public:
		ReadonlyArray<String*>* get_types();
		Promise<Blob*>* getType(const String& type);
		static ClipboardItem* prototype;
		ClipboardItem(Object* items);
		ClipboardItem(Object* items, ClipboardItemOptions* options);
	};
	class CloseEvent: public Event {
	public:
		double get_code();
		String* get_reason();
		bool get_wasClean();
		static CloseEvent* prototype;
		CloseEvent(const String& type);
		CloseEvent(const String& type, CloseEventInit* eventInitDict);
	};
	class Comment: public CharacterData {
	public:
		static Comment* prototype;
		Comment();
		Comment(const String& data);
	};
	class UIEvent: public Event {
	public:
		double get_detail();
		Window* get_view();
		double get_which();
		void initUIEvent(const String& typeArg);
		void initUIEvent(const String& typeArg, bool bubblesArg);
		void initUIEvent(const String& typeArg, bool bubblesArg, bool cancelableArg);
		void initUIEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg);
		void initUIEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg, double detailArg);
		static UIEvent* prototype;
		UIEvent(const String& type);
		UIEvent(const String& type, UIEventInit* eventInitDict);
	};
	class CompositionEvent: public UIEvent {
	public:
		String* get_data();
		void initCompositionEvent(const String& typeArg);
		void initCompositionEvent(const String& typeArg, bool bubblesArg);
		void initCompositionEvent(const String& typeArg, bool bubblesArg, bool cancelableArg);
		void initCompositionEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg);
		void initCompositionEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg, const String& dataArg);
		static CompositionEvent* prototype;
		CompositionEvent(const String& type);
		CompositionEvent(const String& type, CompositionEventInit* eventInitDict);
	};
	class GenericTransformStream: public virtual Object {
	public:
		ReadableStream<_Any*>* get_readable();
		WritableStream<_Any*>* get_writable();
	};
	class CompressionStream: public GenericTransformStream {
	public:
		static CompressionStream* prototype;
		CompressionStream(const String& format);
	};
	class ConstantSourceNode: public AudioScheduledSourceNode {
	public:
		AudioParam* get_offset();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static ConstantSourceNode* prototype;
		ConstantSourceNode(BaseAudioContext* context);
		ConstantSourceNode(BaseAudioContext* context, ConstantSourceOptions* options);
	};
	class ConvolverNode: public AudioNode {
	public:
		AudioBuffer* get_buffer();
		void set_buffer(AudioBuffer* buffer);
		bool get_normalize();
		void set_normalize(bool normalize);
		static ConvolverNode* prototype;
		ConvolverNode(BaseAudioContext* context);
		ConvolverNode(BaseAudioContext* context, ConvolverOptions* options);
	};
	class CountQueuingStrategy: public QueuingStrategy<_Any*> {
	public:
		double get_highWaterMark();
		int get_size() const;
		static CountQueuingStrategy* prototype;
		CountQueuingStrategy(QueuingStrategyInit* init);
	};
	class Credential: public Object {
	public:
		String* get_id();
		String* get_type();
		static Credential* prototype;
		Credential();
	};
	class CredentialsContainer: public Object {
	public:
		Promise<Credential*>* create();
		Promise<Credential*>* create(CredentialCreationOptions* options);
		Promise<Credential*>* get();
		Promise<Credential*>* get(CredentialRequestOptions* options);
		Promise<_Any*>* preventSilentAccess();
		Promise<Credential*>* store(Credential* credential);
		static CredentialsContainer* prototype;
		CredentialsContainer();
	};
	class SubtleCrypto;
	class Crypto: public Object {
	public:
		SubtleCrypto* get_subtle();
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, ArrayBufferView*>, _T0> getRandomValues(_T0 array);
		String* randomUUID();
		static Crypto* prototype;
		Crypto();
	};
	class CryptoKey: public Object {
	public:
		KeyAlgorithm* get_algorithm();
		bool get_extractable();
		String* get_type();
		TArray<String*>* get_usages();
		static CryptoKey* prototype;
		CryptoKey();
	};
	class CustomElementConstructor;
	class CustomElementRegistry: public Object {
	public:
		void define(const String& name, CustomElementConstructor* constructor);
		void define(const String& name, CustomElementConstructor* constructor, ElementDefinitionOptions* options);
		CustomElementConstructor* get(const String& name);
		void upgrade(Node* root);
		Promise<CustomElementConstructor*>* whenDefined(const String& name);
		static CustomElementRegistry* prototype;
		CustomElementRegistry();
	};
	template<class _T0>
	class CustomEvent: public Event {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_T0 get_detail();
		void initCustomEvent(const String& type);
		void initCustomEvent(const String& type, bool bubbles);
		void initCustomEvent(const String& type, bool bubbles, bool cancelable);
		void initCustomEvent(const String& type, bool bubbles, bool cancelable, _T0 detail);
		static CustomEvent<_Any*>* prototype;
		CustomEvent(const String& type);
		template<class _T1>
		CustomEvent(const String& type, CustomEventInit<_T1>* eventInitDict);
	};
	class DOMException: public Error {
	public:
		double get_code();
		String* get_message();
		String* get_name();
		double get_INDEX_SIZE_ERR();
		double get_DOMSTRING_SIZE_ERR();
		double get_HIERARCHY_REQUEST_ERR();
		double get_WRONG_DOCUMENT_ERR();
		double get_INVALID_CHARACTER_ERR();
		double get_NO_DATA_ALLOWED_ERR();
		double get_NO_MODIFICATION_ALLOWED_ERR();
		double get_NOT_FOUND_ERR();
		double get_NOT_SUPPORTED_ERR();
		double get_INUSE_ATTRIBUTE_ERR();
		double get_INVALID_STATE_ERR();
		double get_SYNTAX_ERR();
		double get_INVALID_MODIFICATION_ERR();
		double get_NAMESPACE_ERR();
		double get_INVALID_ACCESS_ERR();
		double get_VALIDATION_ERR();
		double get_TYPE_MISMATCH_ERR();
		double get_SECURITY_ERR();
		double get_NETWORK_ERR();
		double get_ABORT_ERR();
		double get_URL_MISMATCH_ERR();
		double get_QUOTA_EXCEEDED_ERR();
		double get_TIMEOUT_ERR();
		double get_INVALID_NODE_TYPE_ERR();
		double get_DATA_CLONE_ERR();
		static DOMException* prototype;
		DOMException();
		DOMException(const String& message);
		DOMException(const String& message, const String& name);
		static double INDEX_SIZE_ERR;
		static double DOMSTRING_SIZE_ERR;
		static double HIERARCHY_REQUEST_ERR;
		static double WRONG_DOCUMENT_ERR;
		static double INVALID_CHARACTER_ERR;
		static double NO_DATA_ALLOWED_ERR;
		static double NO_MODIFICATION_ALLOWED_ERR;
		static double NOT_FOUND_ERR;
		static double NOT_SUPPORTED_ERR;
		static double INUSE_ATTRIBUTE_ERR;
		static double INVALID_STATE_ERR;
		static double SYNTAX_ERR;
		static double INVALID_MODIFICATION_ERR;
		static double NAMESPACE_ERR;
		static double INVALID_ACCESS_ERR;
		static double VALIDATION_ERR;
		static double TYPE_MISMATCH_ERR;
		static double SECURITY_ERR;
		static double NETWORK_ERR;
		static double ABORT_ERR;
		static double URL_MISMATCH_ERR;
		static double QUOTA_EXCEEDED_ERR;
		static double TIMEOUT_ERR;
		static double INVALID_NODE_TYPE_ERR;
		static double DATA_CLONE_ERR;
	};
	class XMLDocument;
	class DocumentType;
	class DOMImplementation: public Object {
	public:
		XMLDocument* createDocument(const String& namespace_, const String& qualifiedName);
		XMLDocument* createDocument(const String& namespace_, const String& qualifiedName, DocumentType* doctype);
		DocumentType* createDocumentType(const String& qualifiedName, const String& publicId, const String& systemId);
		Document* createHTMLDocument();
		Document* createHTMLDocument(const String& title);
		template<class... _Args>
		[[gnu::always_inline]]
		bool hasFeature(_Args... args) {
			return _hasFeature(cheerp::clientCast(args)...)->template cast<bool>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("hasFeature"))]]
		_Any* _hasFeature(_Args... data);
	public:
		static DOMImplementation* prototype;
		DOMImplementation();
	};
	class DOMPoint;
	class DOMMatrixReadOnly: public Object {
	public:
		double get_a();
		double get_b();
		double get_c();
		double get_d();
		double get_e();
		double get_f();
		bool get_is2D();
		bool get_isIdentity();
		double get_m11();
		double get_m12();
		double get_m13();
		double get_m14();
		double get_m21();
		double get_m22();
		double get_m23();
		double get_m24();
		double get_m31();
		double get_m32();
		double get_m33();
		double get_m34();
		double get_m41();
		double get_m42();
		double get_m43();
		double get_m44();
		DOMMatrix* flipX();
		DOMMatrix* flipY();
		DOMMatrix* inverse();
		DOMMatrix* multiply();
		DOMMatrix* multiply(DOMMatrixInit* other);
		DOMMatrix* rotate();
		DOMMatrix* rotate(double rotX);
		DOMMatrix* rotate(double rotX, double rotY);
		DOMMatrix* rotate(double rotX, double rotY, double rotZ);
		DOMMatrix* rotateAxisAngle();
		DOMMatrix* rotateAxisAngle(double x);
		DOMMatrix* rotateAxisAngle(double x, double y);
		DOMMatrix* rotateAxisAngle(double x, double y, double z);
		DOMMatrix* rotateAxisAngle(double x, double y, double z, double angle);
		DOMMatrix* rotateFromVector();
		DOMMatrix* rotateFromVector(double x);
		DOMMatrix* rotateFromVector(double x, double y);
		DOMMatrix* scale();
		DOMMatrix* scale(double scaleX);
		DOMMatrix* scale(double scaleX, double scaleY);
		DOMMatrix* scale(double scaleX, double scaleY, double scaleZ);
		DOMMatrix* scale(double scaleX, double scaleY, double scaleZ, double originX);
		DOMMatrix* scale(double scaleX, double scaleY, double scaleZ, double originX, double originY);
		DOMMatrix* scale(double scaleX, double scaleY, double scaleZ, double originX, double originY, double originZ);
		DOMMatrix* scale3d();
		DOMMatrix* scale3d(double scale);
		DOMMatrix* scale3d(double scale, double originX);
		DOMMatrix* scale3d(double scale, double originX, double originY);
		DOMMatrix* scale3d(double scale, double originX, double originY, double originZ);
		DOMMatrix* scaleNonUniform();
		DOMMatrix* scaleNonUniform(double scaleX);
		DOMMatrix* scaleNonUniform(double scaleX, double scaleY);
		DOMMatrix* skewX();
		DOMMatrix* skewX(double sx);
		DOMMatrix* skewY();
		DOMMatrix* skewY(double sy);
		Float32Array* toFloat32Array();
		Float64Array* toFloat64Array();
		Object* toJSON();
		DOMPoint* transformPoint();
		DOMPoint* transformPoint(DOMPointInit* point);
		DOMMatrix* translate();
		DOMMatrix* translate(double tx);
		DOMMatrix* translate(double tx, double ty);
		DOMMatrix* translate(double tx, double ty, double tz);
		String* toString();
		static DOMMatrixReadOnly* prototype;
		DOMMatrixReadOnly();
		DOMMatrixReadOnly(const String& init);
		DOMMatrixReadOnly(TArray<double>* init);
		static DOMMatrixReadOnly* fromFloat32Array(Float32Array* array32);
		static DOMMatrixReadOnly* fromFloat64Array(Float64Array* array64);
		static DOMMatrixReadOnly* fromMatrix();
		static DOMMatrixReadOnly* fromMatrix(DOMMatrixInit* other);
	};
	class DOMMatrix: public DOMMatrixReadOnly {
	public:
		double get_a();
		void set_a(double a);
		double get_b();
		void set_b(double b);
		double get_c();
		void set_c(double c);
		double get_d();
		void set_d(double d);
		double get_e();
		void set_e(double e);
		double get_f();
		void set_f(double f);
		double get_m11();
		void set_m11(double m11);
		double get_m12();
		void set_m12(double m12);
		double get_m13();
		void set_m13(double m13);
		double get_m14();
		void set_m14(double m14);
		double get_m21();
		void set_m21(double m21);
		double get_m22();
		void set_m22(double m22);
		double get_m23();
		void set_m23(double m23);
		double get_m24();
		void set_m24(double m24);
		double get_m31();
		void set_m31(double m31);
		double get_m32();
		void set_m32(double m32);
		double get_m33();
		void set_m33(double m33);
		double get_m34();
		void set_m34(double m34);
		double get_m41();
		void set_m41(double m41);
		double get_m42();
		void set_m42(double m42);
		double get_m43();
		void set_m43(double m43);
		double get_m44();
		void set_m44(double m44);
		DOMMatrix* invertSelf();
		DOMMatrix* multiplySelf();
		DOMMatrix* multiplySelf(DOMMatrixInit* other);
		DOMMatrix* preMultiplySelf();
		DOMMatrix* preMultiplySelf(DOMMatrixInit* other);
		DOMMatrix* rotateAxisAngleSelf();
		DOMMatrix* rotateAxisAngleSelf(double x);
		DOMMatrix* rotateAxisAngleSelf(double x, double y);
		DOMMatrix* rotateAxisAngleSelf(double x, double y, double z);
		DOMMatrix* rotateAxisAngleSelf(double x, double y, double z, double angle);
		DOMMatrix* rotateFromVectorSelf();
		DOMMatrix* rotateFromVectorSelf(double x);
		DOMMatrix* rotateFromVectorSelf(double x, double y);
		DOMMatrix* rotateSelf();
		DOMMatrix* rotateSelf(double rotX);
		DOMMatrix* rotateSelf(double rotX, double rotY);
		DOMMatrix* rotateSelf(double rotX, double rotY, double rotZ);
		DOMMatrix* scale3dSelf();
		DOMMatrix* scale3dSelf(double scale);
		DOMMatrix* scale3dSelf(double scale, double originX);
		DOMMatrix* scale3dSelf(double scale, double originX, double originY);
		DOMMatrix* scale3dSelf(double scale, double originX, double originY, double originZ);
		DOMMatrix* scaleSelf();
		DOMMatrix* scaleSelf(double scaleX);
		DOMMatrix* scaleSelf(double scaleX, double scaleY);
		DOMMatrix* scaleSelf(double scaleX, double scaleY, double scaleZ);
		DOMMatrix* scaleSelf(double scaleX, double scaleY, double scaleZ, double originX);
		DOMMatrix* scaleSelf(double scaleX, double scaleY, double scaleZ, double originX, double originY);
		DOMMatrix* scaleSelf(double scaleX, double scaleY, double scaleZ, double originX, double originY, double originZ);
		DOMMatrix* setMatrixValue(const String& transformList);
		DOMMatrix* skewXSelf();
		DOMMatrix* skewXSelf(double sx);
		DOMMatrix* skewYSelf();
		DOMMatrix* skewYSelf(double sy);
		DOMMatrix* translateSelf();
		DOMMatrix* translateSelf(double tx);
		DOMMatrix* translateSelf(double tx, double ty);
		DOMMatrix* translateSelf(double tx, double ty, double tz);
		static DOMMatrix* prototype;
		DOMMatrix();
		DOMMatrix(const String& init);
		DOMMatrix(TArray<double>* init);
		static DOMMatrix* fromFloat32Array(Float32Array* array32);
		static DOMMatrix* fromFloat64Array(Float64Array* array64);
		static DOMMatrix* fromMatrix();
		static DOMMatrix* fromMatrix(DOMMatrixInit* other);
	};
	extern Object SVGMatrix;
	extern Object WebKitCSSMatrix;
	class DOMParser: public Object {
	public:
		Document* parseFromString(const String& string, const String& type);
		static DOMParser* prototype;
		DOMParser();
	};
	class DOMPointReadOnly: public Object {
	public:
		double get_w();
		double get_x();
		double get_y();
		double get_z();
		DOMPoint* matrixTransform();
		DOMPoint* matrixTransform(DOMMatrixInit* matrix);
		Object* toJSON();
		static DOMPointReadOnly* prototype;
		DOMPointReadOnly();
		DOMPointReadOnly(double x);
		DOMPointReadOnly(double x, double y);
		DOMPointReadOnly(double x, double y, double z);
		DOMPointReadOnly(double x, double y, double z, double w);
		static DOMPointReadOnly* fromPoint();
		static DOMPointReadOnly* fromPoint(DOMPointInit* other);
	};
	class DOMPoint: public DOMPointReadOnly {
	public:
		double get_w();
		void set_w(double w);
		double get_x();
		void set_x(double x);
		double get_y();
		void set_y(double y);
		double get_z();
		void set_z(double z);
		static DOMPoint* prototype;
		DOMPoint();
		DOMPoint(double x);
		DOMPoint(double x, double y);
		DOMPoint(double x, double y, double z);
		DOMPoint(double x, double y, double z, double w);
		static DOMPoint* fromPoint();
		static DOMPoint* fromPoint(DOMPointInit* other);
	};
	extern Object SVGPoint;
	class DOMQuad: public Object {
	public:
		DOMPoint* get_p1();
		DOMPoint* get_p2();
		DOMPoint* get_p3();
		DOMPoint* get_p4();
		DOMRect* getBounds();
		Object* toJSON();
		static DOMQuad* prototype;
		DOMQuad();
		DOMQuad(DOMPointInit* p1);
		DOMQuad(DOMPointInit* p1, DOMPointInit* p2);
		DOMQuad(DOMPointInit* p1, DOMPointInit* p2, DOMPointInit* p3);
		DOMQuad(DOMPointInit* p1, DOMPointInit* p2, DOMPointInit* p3, DOMPointInit* p4);
		static DOMQuad* fromQuad();
		static DOMQuad* fromQuad(DOMQuadInit* other);
		static DOMQuad* fromRect();
		static DOMQuad* fromRect(DOMRectInit* other);
	};
	extern Object SVGRect;
	class DOMRectList: public Object {
	public:
		int get_length() const;
		DOMRect* item(double index);
		DOMRect* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		DOMRect*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::DOMRect*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static DOMRectList* prototype;
		DOMRectList();
	public:
		using client::Object::operator[];
	};
	class DOMStringList: public Object {
	public:
		int get_length() const;
		bool contains(const String& string);
		String* item(double index);
		String* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		String*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::String*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static DOMStringList* prototype;
		DOMStringList();
	public:
		using client::Object::operator[];
	};
	class DOMStringMap: public Object {
	public:
		String* operator[](const String& name) const;
		static DOMStringMap* prototype;
		DOMStringMap();
	public:
		using client::Object::operator[];
	};
	class DOMTokenList: public Object {
	public:
		int get_length() const;
		String* get_value();
		void set_value(const String& value);
		String* toString();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, String*> && ...), void> add(_Args... tokens) {
			_add(cheerp::clientCast(tokens)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("add"))]]
		_Any* _add(_Args... data);
	public:
		bool contains(const String& token);
		String* item(double index);
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, String*> && ...), void> remove(_Args... tokens) {
			_remove(cheerp::clientCast(tokens)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("remove"))]]
		_Any* _remove(_Args... data);
	public:
		bool replace(const String& token, const String& newToken) const;
		bool supports(const String& token);
		bool toggle(const String& token);
		bool toggle(const String& token, bool force);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(String*, double, DOMTokenList*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(String*, double, DOMTokenList*)>& callbackfn, const _Any& thisArg);
		String* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		String*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::String*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static DOMTokenList* prototype;
		DOMTokenList();
	public:
		using client::Object::operator[];
	};
	class FileList;
	class DataTransferItemList;
	class DataTransfer: public Object {
	public:
		String* get_dropEffect();
		void set_dropEffect(const String& dropEffect);
		String* get_effectAllowed();
		void set_effectAllowed(const String& effectAllowed);
		FileList* get_files();
		DataTransferItemList* get_items();
		ReadonlyArray<String*>* get_types();
		void clearData();
		void clearData(const String& format);
		String* getData(const String& format);
		void setData(const String& format, const String& data);
		void setDragImage(Element* image, double x, double y);
		static DataTransfer* prototype;
		DataTransfer();
	};
	class FileSystemEntry;
	class DataTransferItem: public Object {
	public:
		String* get_kind();
		String* get_type();
		File* getAsFile();
		void getAsString(EventListener* callback);
		void getAsString(const _Function<void(String*)>& callback);
		FileSystemEntry* webkitGetAsEntry();
		static DataTransferItem* prototype;
		DataTransferItem();
	};
	class DataTransferItemList: public Object {
	public:
		int get_length() const;
		DataTransferItem* add(const String& data, const String& type);
		DataTransferItem* add(File* data);
		void clear();
		void remove(double index);
		DataTransferItem* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		DataTransferItem*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::DataTransferItem*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static DataTransferItemList* prototype;
		DataTransferItemList();
	public:
		using client::Object::operator[];
	};
	class DecompressionStream: public GenericTransformStream {
	public:
		static DecompressionStream* prototype;
		DecompressionStream(const String& format);
	};
	class DelayNode: public AudioNode {
	public:
		AudioParam* get_delayTime();
		static DelayNode* prototype;
		DelayNode(BaseAudioContext* context);
		DelayNode(BaseAudioContext* context, DelayOptions* options);
	};
	class DeviceMotionEventAcceleration;
	class DeviceMotionEventRotationRate;
	class DeviceMotionEvent: public Event {
	public:
		DeviceMotionEventAcceleration* get_acceleration();
		DeviceMotionEventAcceleration* get_accelerationIncludingGravity();
		double get_interval();
		DeviceMotionEventRotationRate* get_rotationRate();
		static DeviceMotionEvent* prototype;
		DeviceMotionEvent(const String& type);
		DeviceMotionEvent(const String& type, DeviceMotionEventInit* eventInitDict);
	};
	class DeviceMotionEventAcceleration: public Object {
	public:
		double get_x();
		double get_y();
		double get_z();
	};
	class DeviceMotionEventRotationRate: public Object {
	public:
		double get_alpha();
		double get_beta();
		double get_gamma();
	};
	class DeviceOrientationEvent: public Event {
	public:
		bool get_absolute();
		double get_alpha();
		double get_beta();
		double get_gamma();
		static DeviceOrientationEvent* prototype;
		DeviceOrientationEvent(const String& type);
		DeviceOrientationEvent(const String& type, DeviceOrientationEventInit* eventInitDict);
	};
	class MouseEvent;
	class InputEvent;
	class FocusEvent;
	class DragEvent;
	class FormDataEvent;
	class KeyboardEvent;
	template<class _T0>
	class ProgressEvent;
	class SecurityPolicyViolationEvent;
	class SubmitEvent;
	class TouchEvent;
	class TransitionEvent;
	class WheelEvent;
	class GlobalEventHandlersEventMap: public virtual Object {
	public:
		[[cheerp::interface_name(("get_\"abort\""))]]
		UIEvent* get__34_abort_34_();
		[[cheerp::interface_name(("set_\"abort\""))]]
		void set__34_abort_34_(UIEvent* _34_abort_34_);
		[[cheerp::interface_name(("get_\"animationcancel\""))]]
		AnimationEvent* get__34_animationcancel_34_();
		[[cheerp::interface_name(("set_\"animationcancel\""))]]
		void set__34_animationcancel_34_(AnimationEvent* _34_animationcancel_34_);
		[[cheerp::interface_name(("get_\"animationend\""))]]
		AnimationEvent* get__34_animationend_34_();
		[[cheerp::interface_name(("set_\"animationend\""))]]
		void set__34_animationend_34_(AnimationEvent* _34_animationend_34_);
		[[cheerp::interface_name(("get_\"animationiteration\""))]]
		AnimationEvent* get__34_animationiteration_34_();
		[[cheerp::interface_name(("set_\"animationiteration\""))]]
		void set__34_animationiteration_34_(AnimationEvent* _34_animationiteration_34_);
		[[cheerp::interface_name(("get_\"animationstart\""))]]
		AnimationEvent* get__34_animationstart_34_();
		[[cheerp::interface_name(("set_\"animationstart\""))]]
		void set__34_animationstart_34_(AnimationEvent* _34_animationstart_34_);
		[[cheerp::interface_name(("get_\"auxclick\""))]]
		MouseEvent* get__34_auxclick_34_();
		[[cheerp::interface_name(("set_\"auxclick\""))]]
		void set__34_auxclick_34_(MouseEvent* _34_auxclick_34_);
		[[cheerp::interface_name(("get_\"beforeinput\""))]]
		InputEvent* get__34_beforeinput_34_();
		[[cheerp::interface_name(("set_\"beforeinput\""))]]
		void set__34_beforeinput_34_(InputEvent* _34_beforeinput_34_);
		[[cheerp::interface_name(("get_\"blur\""))]]
		FocusEvent* get__34_blur_34_();
		[[cheerp::interface_name(("set_\"blur\""))]]
		void set__34_blur_34_(FocusEvent* _34_blur_34_);
		[[cheerp::interface_name(("get_\"cancel\""))]]
		Event* get__34_cancel_34_();
		[[cheerp::interface_name(("set_\"cancel\""))]]
		void set__34_cancel_34_(Event* _34_cancel_34_);
		[[cheerp::interface_name(("get_\"canplay\""))]]
		Event* get__34_canplay_34_();
		[[cheerp::interface_name(("set_\"canplay\""))]]
		void set__34_canplay_34_(Event* _34_canplay_34_);
		[[cheerp::interface_name(("get_\"canplaythrough\""))]]
		Event* get__34_canplaythrough_34_();
		[[cheerp::interface_name(("set_\"canplaythrough\""))]]
		void set__34_canplaythrough_34_(Event* _34_canplaythrough_34_);
		[[cheerp::interface_name(("get_\"change\""))]]
		Event* get__34_change_34_();
		[[cheerp::interface_name(("set_\"change\""))]]
		void set__34_change_34_(Event* _34_change_34_);
		[[cheerp::interface_name(("get_\"click\""))]]
		MouseEvent* get__34_click_34_();
		[[cheerp::interface_name(("set_\"click\""))]]
		void set__34_click_34_(MouseEvent* _34_click_34_);
		[[cheerp::interface_name(("get_\"close\""))]]
		Event* get__34_close_34_();
		[[cheerp::interface_name(("set_\"close\""))]]
		void set__34_close_34_(Event* _34_close_34_);
		[[cheerp::interface_name(("get_\"compositionend\""))]]
		CompositionEvent* get__34_compositionend_34_();
		[[cheerp::interface_name(("set_\"compositionend\""))]]
		void set__34_compositionend_34_(CompositionEvent* _34_compositionend_34_);
		[[cheerp::interface_name(("get_\"compositionstart\""))]]
		CompositionEvent* get__34_compositionstart_34_();
		[[cheerp::interface_name(("set_\"compositionstart\""))]]
		void set__34_compositionstart_34_(CompositionEvent* _34_compositionstart_34_);
		[[cheerp::interface_name(("get_\"compositionupdate\""))]]
		CompositionEvent* get__34_compositionupdate_34_();
		[[cheerp::interface_name(("set_\"compositionupdate\""))]]
		void set__34_compositionupdate_34_(CompositionEvent* _34_compositionupdate_34_);
		[[cheerp::interface_name(("get_\"contextmenu\""))]]
		MouseEvent* get__34_contextmenu_34_();
		[[cheerp::interface_name(("set_\"contextmenu\""))]]
		void set__34_contextmenu_34_(MouseEvent* _34_contextmenu_34_);
		[[cheerp::interface_name(("get_\"copy\""))]]
		ClipboardEvent* get__34_copy_34_();
		[[cheerp::interface_name(("set_\"copy\""))]]
		void set__34_copy_34_(ClipboardEvent* _34_copy_34_);
		[[cheerp::interface_name(("get_\"cuechange\""))]]
		Event* get__34_cuechange_34_();
		[[cheerp::interface_name(("set_\"cuechange\""))]]
		void set__34_cuechange_34_(Event* _34_cuechange_34_);
		[[cheerp::interface_name(("get_\"cut\""))]]
		ClipboardEvent* get__34_cut_34_();
		[[cheerp::interface_name(("set_\"cut\""))]]
		void set__34_cut_34_(ClipboardEvent* _34_cut_34_);
		[[cheerp::interface_name(("get_\"dblclick\""))]]
		MouseEvent* get__34_dblclick_34_();
		[[cheerp::interface_name(("set_\"dblclick\""))]]
		void set__34_dblclick_34_(MouseEvent* _34_dblclick_34_);
		[[cheerp::interface_name(("get_\"drag\""))]]
		DragEvent* get__34_drag_34_();
		[[cheerp::interface_name(("set_\"drag\""))]]
		void set__34_drag_34_(DragEvent* _34_drag_34_);
		[[cheerp::interface_name(("get_\"dragend\""))]]
		DragEvent* get__34_dragend_34_();
		[[cheerp::interface_name(("set_\"dragend\""))]]
		void set__34_dragend_34_(DragEvent* _34_dragend_34_);
		[[cheerp::interface_name(("get_\"dragenter\""))]]
		DragEvent* get__34_dragenter_34_();
		[[cheerp::interface_name(("set_\"dragenter\""))]]
		void set__34_dragenter_34_(DragEvent* _34_dragenter_34_);
		[[cheerp::interface_name(("get_\"dragleave\""))]]
		DragEvent* get__34_dragleave_34_();
		[[cheerp::interface_name(("set_\"dragleave\""))]]
		void set__34_dragleave_34_(DragEvent* _34_dragleave_34_);
		[[cheerp::interface_name(("get_\"dragover\""))]]
		DragEvent* get__34_dragover_34_();
		[[cheerp::interface_name(("set_\"dragover\""))]]
		void set__34_dragover_34_(DragEvent* _34_dragover_34_);
		[[cheerp::interface_name(("get_\"dragstart\""))]]
		DragEvent* get__34_dragstart_34_();
		[[cheerp::interface_name(("set_\"dragstart\""))]]
		void set__34_dragstart_34_(DragEvent* _34_dragstart_34_);
		[[cheerp::interface_name(("get_\"drop\""))]]
		DragEvent* get__34_drop_34_();
		[[cheerp::interface_name(("set_\"drop\""))]]
		void set__34_drop_34_(DragEvent* _34_drop_34_);
		[[cheerp::interface_name(("get_\"durationchange\""))]]
		Event* get__34_durationchange_34_();
		[[cheerp::interface_name(("set_\"durationchange\""))]]
		void set__34_durationchange_34_(Event* _34_durationchange_34_);
		[[cheerp::interface_name(("get_\"emptied\""))]]
		Event* get__34_emptied_34_();
		[[cheerp::interface_name(("set_\"emptied\""))]]
		void set__34_emptied_34_(Event* _34_emptied_34_);
		[[cheerp::interface_name(("get_\"ended\""))]]
		Event* get__34_ended_34_();
		[[cheerp::interface_name(("set_\"ended\""))]]
		void set__34_ended_34_(Event* _34_ended_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		ErrorEvent* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(ErrorEvent* _34_error_34_);
		[[cheerp::interface_name(("get_\"focus\""))]]
		FocusEvent* get__34_focus_34_();
		[[cheerp::interface_name(("set_\"focus\""))]]
		void set__34_focus_34_(FocusEvent* _34_focus_34_);
		[[cheerp::interface_name(("get_\"focusin\""))]]
		FocusEvent* get__34_focusin_34_();
		[[cheerp::interface_name(("set_\"focusin\""))]]
		void set__34_focusin_34_(FocusEvent* _34_focusin_34_);
		[[cheerp::interface_name(("get_\"focusout\""))]]
		FocusEvent* get__34_focusout_34_();
		[[cheerp::interface_name(("set_\"focusout\""))]]
		void set__34_focusout_34_(FocusEvent* _34_focusout_34_);
		[[cheerp::interface_name(("get_\"formdata\""))]]
		FormDataEvent* get__34_formdata_34_();
		[[cheerp::interface_name(("set_\"formdata\""))]]
		void set__34_formdata_34_(FormDataEvent* _34_formdata_34_);
		[[cheerp::interface_name(("get_\"gotpointercapture\""))]]
		PointerEvent* get__34_gotpointercapture_34_();
		[[cheerp::interface_name(("set_\"gotpointercapture\""))]]
		void set__34_gotpointercapture_34_(PointerEvent* _34_gotpointercapture_34_);
		[[cheerp::interface_name(("get_\"input\""))]]
		Event* get__34_input_34_();
		[[cheerp::interface_name(("set_\"input\""))]]
		void set__34_input_34_(Event* _34_input_34_);
		[[cheerp::interface_name(("get_\"invalid\""))]]
		Event* get__34_invalid_34_();
		[[cheerp::interface_name(("set_\"invalid\""))]]
		void set__34_invalid_34_(Event* _34_invalid_34_);
		[[cheerp::interface_name(("get_\"keydown\""))]]
		KeyboardEvent* get__34_keydown_34_();
		[[cheerp::interface_name(("set_\"keydown\""))]]
		void set__34_keydown_34_(KeyboardEvent* _34_keydown_34_);
		[[cheerp::interface_name(("get_\"keypress\""))]]
		KeyboardEvent* get__34_keypress_34_();
		[[cheerp::interface_name(("set_\"keypress\""))]]
		void set__34_keypress_34_(KeyboardEvent* _34_keypress_34_);
		[[cheerp::interface_name(("get_\"keyup\""))]]
		KeyboardEvent* get__34_keyup_34_();
		[[cheerp::interface_name(("set_\"keyup\""))]]
		void set__34_keyup_34_(KeyboardEvent* _34_keyup_34_);
		[[cheerp::interface_name(("get_\"load\""))]]
		Event* get__34_load_34_();
		[[cheerp::interface_name(("set_\"load\""))]]
		void set__34_load_34_(Event* _34_load_34_);
		[[cheerp::interface_name(("get_\"loadeddata\""))]]
		Event* get__34_loadeddata_34_();
		[[cheerp::interface_name(("set_\"loadeddata\""))]]
		void set__34_loadeddata_34_(Event* _34_loadeddata_34_);
		[[cheerp::interface_name(("get_\"loadedmetadata\""))]]
		Event* get__34_loadedmetadata_34_();
		[[cheerp::interface_name(("set_\"loadedmetadata\""))]]
		void set__34_loadedmetadata_34_(Event* _34_loadedmetadata_34_);
		[[cheerp::interface_name(("get_\"loadstart\""))]]
		Event* get__34_loadstart_34_();
		[[cheerp::interface_name(("set_\"loadstart\""))]]
		void set__34_loadstart_34_(Event* _34_loadstart_34_);
		[[cheerp::interface_name(("get_\"lostpointercapture\""))]]
		PointerEvent* get__34_lostpointercapture_34_();
		[[cheerp::interface_name(("set_\"lostpointercapture\""))]]
		void set__34_lostpointercapture_34_(PointerEvent* _34_lostpointercapture_34_);
		[[cheerp::interface_name(("get_\"mousedown\""))]]
		MouseEvent* get__34_mousedown_34_();
		[[cheerp::interface_name(("set_\"mousedown\""))]]
		void set__34_mousedown_34_(MouseEvent* _34_mousedown_34_);
		[[cheerp::interface_name(("get_\"mouseenter\""))]]
		MouseEvent* get__34_mouseenter_34_();
		[[cheerp::interface_name(("set_\"mouseenter\""))]]
		void set__34_mouseenter_34_(MouseEvent* _34_mouseenter_34_);
		[[cheerp::interface_name(("get_\"mouseleave\""))]]
		MouseEvent* get__34_mouseleave_34_();
		[[cheerp::interface_name(("set_\"mouseleave\""))]]
		void set__34_mouseleave_34_(MouseEvent* _34_mouseleave_34_);
		[[cheerp::interface_name(("get_\"mousemove\""))]]
		MouseEvent* get__34_mousemove_34_();
		[[cheerp::interface_name(("set_\"mousemove\""))]]
		void set__34_mousemove_34_(MouseEvent* _34_mousemove_34_);
		[[cheerp::interface_name(("get_\"mouseout\""))]]
		MouseEvent* get__34_mouseout_34_();
		[[cheerp::interface_name(("set_\"mouseout\""))]]
		void set__34_mouseout_34_(MouseEvent* _34_mouseout_34_);
		[[cheerp::interface_name(("get_\"mouseover\""))]]
		MouseEvent* get__34_mouseover_34_();
		[[cheerp::interface_name(("set_\"mouseover\""))]]
		void set__34_mouseover_34_(MouseEvent* _34_mouseover_34_);
		[[cheerp::interface_name(("get_\"mouseup\""))]]
		MouseEvent* get__34_mouseup_34_();
		[[cheerp::interface_name(("set_\"mouseup\""))]]
		void set__34_mouseup_34_(MouseEvent* _34_mouseup_34_);
		[[cheerp::interface_name(("get_\"paste\""))]]
		ClipboardEvent* get__34_paste_34_();
		[[cheerp::interface_name(("set_\"paste\""))]]
		void set__34_paste_34_(ClipboardEvent* _34_paste_34_);
		[[cheerp::interface_name(("get_\"pause\""))]]
		Event* get__34_pause_34_();
		[[cheerp::interface_name(("set_\"pause\""))]]
		void set__34_pause_34_(Event* _34_pause_34_);
		[[cheerp::interface_name(("get_\"play\""))]]
		Event* get__34_play_34_();
		[[cheerp::interface_name(("set_\"play\""))]]
		void set__34_play_34_(Event* _34_play_34_);
		[[cheerp::interface_name(("get_\"playing\""))]]
		Event* get__34_playing_34_();
		[[cheerp::interface_name(("set_\"playing\""))]]
		void set__34_playing_34_(Event* _34_playing_34_);
		[[cheerp::interface_name(("get_\"pointercancel\""))]]
		PointerEvent* get__34_pointercancel_34_();
		[[cheerp::interface_name(("set_\"pointercancel\""))]]
		void set__34_pointercancel_34_(PointerEvent* _34_pointercancel_34_);
		[[cheerp::interface_name(("get_\"pointerdown\""))]]
		PointerEvent* get__34_pointerdown_34_();
		[[cheerp::interface_name(("set_\"pointerdown\""))]]
		void set__34_pointerdown_34_(PointerEvent* _34_pointerdown_34_);
		[[cheerp::interface_name(("get_\"pointerenter\""))]]
		PointerEvent* get__34_pointerenter_34_();
		[[cheerp::interface_name(("set_\"pointerenter\""))]]
		void set__34_pointerenter_34_(PointerEvent* _34_pointerenter_34_);
		[[cheerp::interface_name(("get_\"pointerleave\""))]]
		PointerEvent* get__34_pointerleave_34_();
		[[cheerp::interface_name(("set_\"pointerleave\""))]]
		void set__34_pointerleave_34_(PointerEvent* _34_pointerleave_34_);
		[[cheerp::interface_name(("get_\"pointermove\""))]]
		PointerEvent* get__34_pointermove_34_();
		[[cheerp::interface_name(("set_\"pointermove\""))]]
		void set__34_pointermove_34_(PointerEvent* _34_pointermove_34_);
		[[cheerp::interface_name(("get_\"pointerout\""))]]
		PointerEvent* get__34_pointerout_34_();
		[[cheerp::interface_name(("set_\"pointerout\""))]]
		void set__34_pointerout_34_(PointerEvent* _34_pointerout_34_);
		[[cheerp::interface_name(("get_\"pointerover\""))]]
		PointerEvent* get__34_pointerover_34_();
		[[cheerp::interface_name(("set_\"pointerover\""))]]
		void set__34_pointerover_34_(PointerEvent* _34_pointerover_34_);
		[[cheerp::interface_name(("get_\"pointerup\""))]]
		PointerEvent* get__34_pointerup_34_();
		[[cheerp::interface_name(("set_\"pointerup\""))]]
		void set__34_pointerup_34_(PointerEvent* _34_pointerup_34_);
		[[cheerp::interface_name(("get_\"progress\""))]]
		ProgressEvent<EventTarget*>* get__34_progress_34_();
		[[cheerp::interface_name(("set_\"progress\""))]]
		void set__34_progress_34_(ProgressEvent<EventTarget*>* _34_progress_34_);
		[[cheerp::interface_name(("get_\"ratechange\""))]]
		Event* get__34_ratechange_34_();
		[[cheerp::interface_name(("set_\"ratechange\""))]]
		void set__34_ratechange_34_(Event* _34_ratechange_34_);
		[[cheerp::interface_name(("get_\"reset\""))]]
		Event* get__34_reset_34_();
		[[cheerp::interface_name(("set_\"reset\""))]]
		void set__34_reset_34_(Event* _34_reset_34_);
		[[cheerp::interface_name(("get_\"resize\""))]]
		UIEvent* get__34_resize_34_();
		[[cheerp::interface_name(("set_\"resize\""))]]
		void set__34_resize_34_(UIEvent* _34_resize_34_);
		[[cheerp::interface_name(("get_\"scroll\""))]]
		Event* get__34_scroll_34_();
		[[cheerp::interface_name(("set_\"scroll\""))]]
		void set__34_scroll_34_(Event* _34_scroll_34_);
		[[cheerp::interface_name(("get_\"scrollend\""))]]
		Event* get__34_scrollend_34_();
		[[cheerp::interface_name(("set_\"scrollend\""))]]
		void set__34_scrollend_34_(Event* _34_scrollend_34_);
		[[cheerp::interface_name(("get_\"securitypolicyviolation\""))]]
		SecurityPolicyViolationEvent* get__34_securitypolicyviolation_34_();
		[[cheerp::interface_name(("set_\"securitypolicyviolation\""))]]
		void set__34_securitypolicyviolation_34_(SecurityPolicyViolationEvent* _34_securitypolicyviolation_34_);
		[[cheerp::interface_name(("get_\"seeked\""))]]
		Event* get__34_seeked_34_();
		[[cheerp::interface_name(("set_\"seeked\""))]]
		void set__34_seeked_34_(Event* _34_seeked_34_);
		[[cheerp::interface_name(("get_\"seeking\""))]]
		Event* get__34_seeking_34_();
		[[cheerp::interface_name(("set_\"seeking\""))]]
		void set__34_seeking_34_(Event* _34_seeking_34_);
		[[cheerp::interface_name(("get_\"select\""))]]
		Event* get__34_select_34_();
		[[cheerp::interface_name(("set_\"select\""))]]
		void set__34_select_34_(Event* _34_select_34_);
		[[cheerp::interface_name(("get_\"selectionchange\""))]]
		Event* get__34_selectionchange_34_();
		[[cheerp::interface_name(("set_\"selectionchange\""))]]
		void set__34_selectionchange_34_(Event* _34_selectionchange_34_);
		[[cheerp::interface_name(("get_\"selectstart\""))]]
		Event* get__34_selectstart_34_();
		[[cheerp::interface_name(("set_\"selectstart\""))]]
		void set__34_selectstart_34_(Event* _34_selectstart_34_);
		[[cheerp::interface_name(("get_\"slotchange\""))]]
		Event* get__34_slotchange_34_();
		[[cheerp::interface_name(("set_\"slotchange\""))]]
		void set__34_slotchange_34_(Event* _34_slotchange_34_);
		[[cheerp::interface_name(("get_\"stalled\""))]]
		Event* get__34_stalled_34_();
		[[cheerp::interface_name(("set_\"stalled\""))]]
		void set__34_stalled_34_(Event* _34_stalled_34_);
		[[cheerp::interface_name(("get_\"submit\""))]]
		SubmitEvent* get__34_submit_34_();
		[[cheerp::interface_name(("set_\"submit\""))]]
		void set__34_submit_34_(SubmitEvent* _34_submit_34_);
		[[cheerp::interface_name(("get_\"suspend\""))]]
		Event* get__34_suspend_34_();
		[[cheerp::interface_name(("set_\"suspend\""))]]
		void set__34_suspend_34_(Event* _34_suspend_34_);
		[[cheerp::interface_name(("get_\"timeupdate\""))]]
		Event* get__34_timeupdate_34_();
		[[cheerp::interface_name(("set_\"timeupdate\""))]]
		void set__34_timeupdate_34_(Event* _34_timeupdate_34_);
		[[cheerp::interface_name(("get_\"toggle\""))]]
		Event* get__34_toggle_34_();
		[[cheerp::interface_name(("set_\"toggle\""))]]
		void set__34_toggle_34_(Event* _34_toggle_34_);
		[[cheerp::interface_name(("get_\"touchcancel\""))]]
		TouchEvent* get__34_touchcancel_34_();
		[[cheerp::interface_name(("set_\"touchcancel\""))]]
		void set__34_touchcancel_34_(TouchEvent* _34_touchcancel_34_);
		[[cheerp::interface_name(("get_\"touchend\""))]]
		TouchEvent* get__34_touchend_34_();
		[[cheerp::interface_name(("set_\"touchend\""))]]
		void set__34_touchend_34_(TouchEvent* _34_touchend_34_);
		[[cheerp::interface_name(("get_\"touchmove\""))]]
		TouchEvent* get__34_touchmove_34_();
		[[cheerp::interface_name(("set_\"touchmove\""))]]
		void set__34_touchmove_34_(TouchEvent* _34_touchmove_34_);
		[[cheerp::interface_name(("get_\"touchstart\""))]]
		TouchEvent* get__34_touchstart_34_();
		[[cheerp::interface_name(("set_\"touchstart\""))]]
		void set__34_touchstart_34_(TouchEvent* _34_touchstart_34_);
		[[cheerp::interface_name(("get_\"transitioncancel\""))]]
		TransitionEvent* get__34_transitioncancel_34_();
		[[cheerp::interface_name(("set_\"transitioncancel\""))]]
		void set__34_transitioncancel_34_(TransitionEvent* _34_transitioncancel_34_);
		[[cheerp::interface_name(("get_\"transitionend\""))]]
		TransitionEvent* get__34_transitionend_34_();
		[[cheerp::interface_name(("set_\"transitionend\""))]]
		void set__34_transitionend_34_(TransitionEvent* _34_transitionend_34_);
		[[cheerp::interface_name(("get_\"transitionrun\""))]]
		TransitionEvent* get__34_transitionrun_34_();
		[[cheerp::interface_name(("set_\"transitionrun\""))]]
		void set__34_transitionrun_34_(TransitionEvent* _34_transitionrun_34_);
		[[cheerp::interface_name(("get_\"transitionstart\""))]]
		TransitionEvent* get__34_transitionstart_34_();
		[[cheerp::interface_name(("set_\"transitionstart\""))]]
		void set__34_transitionstart_34_(TransitionEvent* _34_transitionstart_34_);
		[[cheerp::interface_name(("get_\"volumechange\""))]]
		Event* get__34_volumechange_34_();
		[[cheerp::interface_name(("set_\"volumechange\""))]]
		void set__34_volumechange_34_(Event* _34_volumechange_34_);
		[[cheerp::interface_name(("get_\"waiting\""))]]
		Event* get__34_waiting_34_();
		[[cheerp::interface_name(("set_\"waiting\""))]]
		void set__34_waiting_34_(Event* _34_waiting_34_);
		[[cheerp::interface_name(("get_\"webkitanimationend\""))]]
		Event* get__34_webkitanimationend_34_();
		[[cheerp::interface_name(("set_\"webkitanimationend\""))]]
		void set__34_webkitanimationend_34_(Event* _34_webkitanimationend_34_);
		[[cheerp::interface_name(("get_\"webkitanimationiteration\""))]]
		Event* get__34_webkitanimationiteration_34_();
		[[cheerp::interface_name(("set_\"webkitanimationiteration\""))]]
		void set__34_webkitanimationiteration_34_(Event* _34_webkitanimationiteration_34_);
		[[cheerp::interface_name(("get_\"webkitanimationstart\""))]]
		Event* get__34_webkitanimationstart_34_();
		[[cheerp::interface_name(("set_\"webkitanimationstart\""))]]
		void set__34_webkitanimationstart_34_(Event* _34_webkitanimationstart_34_);
		[[cheerp::interface_name(("get_\"webkittransitionend\""))]]
		Event* get__34_webkittransitionend_34_();
		[[cheerp::interface_name(("set_\"webkittransitionend\""))]]
		void set__34_webkittransitionend_34_(Event* _34_webkittransitionend_34_);
		[[cheerp::interface_name(("get_\"wheel\""))]]
		WheelEvent* get__34_wheel_34_();
		[[cheerp::interface_name(("set_\"wheel\""))]]
		void set__34_wheel_34_(WheelEvent* _34_wheel_34_);
	};
	class DocumentEventMap: public GlobalEventHandlersEventMap {
	public:
		[[cheerp::interface_name(("get_\"DOMContentLoaded\""))]]
		Event* get__34_DOMContentLoaded_34_();
		[[cheerp::interface_name(("set_\"DOMContentLoaded\""))]]
		void set__34_DOMContentLoaded_34_(Event* _34_DOMContentLoaded_34_);
		[[cheerp::interface_name(("get_\"fullscreenchange\""))]]
		Event* get__34_fullscreenchange_34_();
		[[cheerp::interface_name(("set_\"fullscreenchange\""))]]
		void set__34_fullscreenchange_34_(Event* _34_fullscreenchange_34_);
		[[cheerp::interface_name(("get_\"fullscreenerror\""))]]
		Event* get__34_fullscreenerror_34_();
		[[cheerp::interface_name(("set_\"fullscreenerror\""))]]
		void set__34_fullscreenerror_34_(Event* _34_fullscreenerror_34_);
		[[cheerp::interface_name(("get_\"pointerlockchange\""))]]
		Event* get__34_pointerlockchange_34_();
		[[cheerp::interface_name(("set_\"pointerlockchange\""))]]
		void set__34_pointerlockchange_34_(Event* _34_pointerlockchange_34_);
		[[cheerp::interface_name(("get_\"pointerlockerror\""))]]
		Event* get__34_pointerlockerror_34_();
		[[cheerp::interface_name(("set_\"pointerlockerror\""))]]
		void set__34_pointerlockerror_34_(Event* _34_pointerlockerror_34_);
		[[cheerp::interface_name(("get_\"readystatechange\""))]]
		Event* get__34_readystatechange_34_();
		[[cheerp::interface_name(("set_\"readystatechange\""))]]
		void set__34_readystatechange_34_(Event* _34_readystatechange_34_);
		[[cheerp::interface_name(("get_\"visibilitychange\""))]]
		Event* get__34_visibilitychange_34_();
		[[cheerp::interface_name(("set_\"visibilitychange\""))]]
		void set__34_visibilitychange_34_(Event* _34_visibilitychange_34_);
	};
	class HTMLAllCollection;
	class HTMLAnchorElement;
	template<class _T0>
	class HTMLCollectionOf;
	class HTMLCollection;
	class HTMLScriptElement;
	class SVGScriptElement;
	class HTMLEmbedElement;
	class HTMLFormElement;
	class HTMLHeadElement;
	class Location;
	class SVGSVGElement;
	class DocumentTimeline;
	class Range;
	class DocumentFragment;
	class SVGElement;
	class MathMLElement;
	class FontFaceSetLoadEvent;
	class GamepadEvent;
	class HashChangeEvent;
	class IDBVersionChangeEvent;
	class MIDIConnectionEvent;
	class MIDIMessageEvent;
	class MediaEncryptedEvent;
	class MediaKeyMessageEvent;
	class MediaQueryListEvent;
	class MediaStreamTrackEvent;
	class MutationEvent;
	class OfflineAudioCompletionEvent;
	class PageTransitionEvent;
	class PaymentMethodChangeEvent;
	class PaymentRequestUpdateEvent;
	class PictureInPictureEvent;
	class PopStateEvent;
	class PromiseRejectionEvent;
	class RTCDTMFToneChangeEvent;
	class RTCDataChannelEvent;
	class RTCErrorEvent;
	class RTCPeerConnectionIceErrorEvent;
	class RTCPeerConnectionIceEvent;
	class RTCTrackEvent;
	class SpeechSynthesisErrorEvent;
	class SpeechSynthesisEvent;
	class StorageEvent;
	class ToggleEvent;
	class TrackEvent;
	class WebGLContextEvent;
	class NodeIterator;
	class TreeWalker;
	class Selection;
	class StyleSheetList;
	class DocumentOrShadowRoot: public virtual Object {
	public:
		Element* get_activeElement();
		TArray<CSSStyleSheet*>* get_adoptedStyleSheets();
		void set_adoptedStyleSheets(TArray<CSSStyleSheet*>* adoptedStyleSheets);
		Element* get_fullscreenElement();
		Element* get_pictureInPictureElement();
		Element* get_pointerLockElement();
		StyleSheetList* get_styleSheets();
		Element* elementFromPoint(double x, double y);
		TArray<Element*>* elementsFromPoint(double x, double y);
		TArray<Animation*>* getAnimations();
	};
	class FontFaceSet;
	class FontFaceSource: public virtual Object {
	public:
		FontFaceSet* get_fonts();
	};
	class GlobalEventHandlers: public virtual Object {
	public:
		_Function<_Any*(UIEvent*)>* get_onabort();
		void set_onabort(EventListener* onabort);
		void set_onabort(const _Function<_Any*(UIEvent*)>& onabort);
		_Function<_Any*(AnimationEvent*)>* get_onanimationcancel();
		void set_onanimationcancel(EventListener* onanimationcancel);
		void set_onanimationcancel(const _Function<_Any*(AnimationEvent*)>& onanimationcancel);
		_Function<_Any*(AnimationEvent*)>* get_onanimationend();
		void set_onanimationend(EventListener* onanimationend);
		void set_onanimationend(const _Function<_Any*(AnimationEvent*)>& onanimationend);
		_Function<_Any*(AnimationEvent*)>* get_onanimationiteration();
		void set_onanimationiteration(EventListener* onanimationiteration);
		void set_onanimationiteration(const _Function<_Any*(AnimationEvent*)>& onanimationiteration);
		_Function<_Any*(AnimationEvent*)>* get_onanimationstart();
		void set_onanimationstart(EventListener* onanimationstart);
		void set_onanimationstart(const _Function<_Any*(AnimationEvent*)>& onanimationstart);
		_Function<_Any*(MouseEvent*)>* get_onauxclick();
		void set_onauxclick(EventListener* onauxclick);
		void set_onauxclick(const _Function<_Any*(MouseEvent*)>& onauxclick);
		_Function<_Any*(InputEvent*)>* get_onbeforeinput();
		void set_onbeforeinput(EventListener* onbeforeinput);
		void set_onbeforeinput(const _Function<_Any*(InputEvent*)>& onbeforeinput);
		_Function<_Any*(FocusEvent*)>* get_onblur();
		void set_onblur(EventListener* onblur);
		void set_onblur(const _Function<_Any*(FocusEvent*)>& onblur);
		_Function<_Any*(Event*)>* get_oncancel();
		void set_oncancel(EventListener* oncancel);
		void set_oncancel(const _Function<_Any*(Event*)>& oncancel);
		_Function<_Any*(Event*)>* get_oncanplay();
		void set_oncanplay(EventListener* oncanplay);
		void set_oncanplay(const _Function<_Any*(Event*)>& oncanplay);
		_Function<_Any*(Event*)>* get_oncanplaythrough();
		void set_oncanplaythrough(EventListener* oncanplaythrough);
		void set_oncanplaythrough(const _Function<_Any*(Event*)>& oncanplaythrough);
		_Function<_Any*(Event*)>* get_onchange();
		void set_onchange(EventListener* onchange);
		void set_onchange(const _Function<_Any*(Event*)>& onchange);
		_Function<_Any*(MouseEvent*)>* get_onclick();
		void set_onclick(EventListener* onclick);
		void set_onclick(const _Function<_Any*(MouseEvent*)>& onclick);
		_Function<_Any*(Event*)>* get_onclose();
		void set_onclose(EventListener* onclose);
		void set_onclose(const _Function<_Any*(Event*)>& onclose);
		_Function<_Any*(MouseEvent*)>* get_oncontextmenu();
		void set_oncontextmenu(EventListener* oncontextmenu);
		void set_oncontextmenu(const _Function<_Any*(MouseEvent*)>& oncontextmenu);
		_Function<_Any*(ClipboardEvent*)>* get_oncopy();
		void set_oncopy(EventListener* oncopy);
		void set_oncopy(const _Function<_Any*(ClipboardEvent*)>& oncopy);
		_Function<_Any*(Event*)>* get_oncuechange();
		void set_oncuechange(EventListener* oncuechange);
		void set_oncuechange(const _Function<_Any*(Event*)>& oncuechange);
		_Function<_Any*(ClipboardEvent*)>* get_oncut();
		void set_oncut(EventListener* oncut);
		void set_oncut(const _Function<_Any*(ClipboardEvent*)>& oncut);
		_Function<_Any*(MouseEvent*)>* get_ondblclick();
		void set_ondblclick(EventListener* ondblclick);
		void set_ondblclick(const _Function<_Any*(MouseEvent*)>& ondblclick);
		_Function<_Any*(DragEvent*)>* get_ondrag();
		void set_ondrag(EventListener* ondrag);
		void set_ondrag(const _Function<_Any*(DragEvent*)>& ondrag);
		_Function<_Any*(DragEvent*)>* get_ondragend();
		void set_ondragend(EventListener* ondragend);
		void set_ondragend(const _Function<_Any*(DragEvent*)>& ondragend);
		_Function<_Any*(DragEvent*)>* get_ondragenter();
		void set_ondragenter(EventListener* ondragenter);
		void set_ondragenter(const _Function<_Any*(DragEvent*)>& ondragenter);
		_Function<_Any*(DragEvent*)>* get_ondragleave();
		void set_ondragleave(EventListener* ondragleave);
		void set_ondragleave(const _Function<_Any*(DragEvent*)>& ondragleave);
		_Function<_Any*(DragEvent*)>* get_ondragover();
		void set_ondragover(EventListener* ondragover);
		void set_ondragover(const _Function<_Any*(DragEvent*)>& ondragover);
		_Function<_Any*(DragEvent*)>* get_ondragstart();
		void set_ondragstart(EventListener* ondragstart);
		void set_ondragstart(const _Function<_Any*(DragEvent*)>& ondragstart);
		_Function<_Any*(DragEvent*)>* get_ondrop();
		void set_ondrop(EventListener* ondrop);
		void set_ondrop(const _Function<_Any*(DragEvent*)>& ondrop);
		_Function<_Any*(Event*)>* get_ondurationchange();
		void set_ondurationchange(EventListener* ondurationchange);
		void set_ondurationchange(const _Function<_Any*(Event*)>& ondurationchange);
		_Function<_Any*(Event*)>* get_onemptied();
		void set_onemptied(EventListener* onemptied);
		void set_onemptied(const _Function<_Any*(Event*)>& onemptied);
		_Function<_Any*(Event*)>* get_onended();
		void set_onended(EventListener* onended);
		void set_onended(const _Function<_Any*(Event*)>& onended);
		_Function<_Any*(_Union<String*, Event*>*, String*, double, double, Error*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(_Union<String*, Event*>*, String*, double, double, Error*)>& onerror);
		_Function<_Any*(FocusEvent*)>* get_onfocus();
		void set_onfocus(EventListener* onfocus);
		void set_onfocus(const _Function<_Any*(FocusEvent*)>& onfocus);
		_Function<_Any*(FormDataEvent*)>* get_onformdata();
		void set_onformdata(EventListener* onformdata);
		void set_onformdata(const _Function<_Any*(FormDataEvent*)>& onformdata);
		_Function<_Any*(PointerEvent*)>* get_ongotpointercapture();
		void set_ongotpointercapture(EventListener* ongotpointercapture);
		void set_ongotpointercapture(const _Function<_Any*(PointerEvent*)>& ongotpointercapture);
		_Function<_Any*(Event*)>* get_oninput();
		void set_oninput(EventListener* oninput);
		void set_oninput(const _Function<_Any*(Event*)>& oninput);
		_Function<_Any*(Event*)>* get_oninvalid();
		void set_oninvalid(EventListener* oninvalid);
		void set_oninvalid(const _Function<_Any*(Event*)>& oninvalid);
		_Function<_Any*(KeyboardEvent*)>* get_onkeydown();
		void set_onkeydown(EventListener* onkeydown);
		void set_onkeydown(const _Function<_Any*(KeyboardEvent*)>& onkeydown);
		_Function<_Any*(KeyboardEvent*)>* get_onkeypress();
		void set_onkeypress(EventListener* onkeypress);
		void set_onkeypress(const _Function<_Any*(KeyboardEvent*)>& onkeypress);
		_Function<_Any*(KeyboardEvent*)>* get_onkeyup();
		void set_onkeyup(EventListener* onkeyup);
		void set_onkeyup(const _Function<_Any*(KeyboardEvent*)>& onkeyup);
		_Function<_Any*(Event*)>* get_onload();
		void set_onload(EventListener* onload);
		void set_onload(const _Function<_Any*(Event*)>& onload);
		_Function<_Any*(Event*)>* get_onloadeddata();
		void set_onloadeddata(EventListener* onloadeddata);
		void set_onloadeddata(const _Function<_Any*(Event*)>& onloadeddata);
		_Function<_Any*(Event*)>* get_onloadedmetadata();
		void set_onloadedmetadata(EventListener* onloadedmetadata);
		void set_onloadedmetadata(const _Function<_Any*(Event*)>& onloadedmetadata);
		_Function<_Any*(Event*)>* get_onloadstart();
		void set_onloadstart(EventListener* onloadstart);
		void set_onloadstart(const _Function<_Any*(Event*)>& onloadstart);
		_Function<_Any*(PointerEvent*)>* get_onlostpointercapture();
		void set_onlostpointercapture(EventListener* onlostpointercapture);
		void set_onlostpointercapture(const _Function<_Any*(PointerEvent*)>& onlostpointercapture);
		_Function<_Any*(MouseEvent*)>* get_onmousedown();
		void set_onmousedown(EventListener* onmousedown);
		void set_onmousedown(const _Function<_Any*(MouseEvent*)>& onmousedown);
		_Function<_Any*(MouseEvent*)>* get_onmouseenter();
		void set_onmouseenter(EventListener* onmouseenter);
		void set_onmouseenter(const _Function<_Any*(MouseEvent*)>& onmouseenter);
		_Function<_Any*(MouseEvent*)>* get_onmouseleave();
		void set_onmouseleave(EventListener* onmouseleave);
		void set_onmouseleave(const _Function<_Any*(MouseEvent*)>& onmouseleave);
		_Function<_Any*(MouseEvent*)>* get_onmousemove();
		void set_onmousemove(EventListener* onmousemove);
		void set_onmousemove(const _Function<_Any*(MouseEvent*)>& onmousemove);
		_Function<_Any*(MouseEvent*)>* get_onmouseout();
		void set_onmouseout(EventListener* onmouseout);
		void set_onmouseout(const _Function<_Any*(MouseEvent*)>& onmouseout);
		_Function<_Any*(MouseEvent*)>* get_onmouseover();
		void set_onmouseover(EventListener* onmouseover);
		void set_onmouseover(const _Function<_Any*(MouseEvent*)>& onmouseover);
		_Function<_Any*(MouseEvent*)>* get_onmouseup();
		void set_onmouseup(EventListener* onmouseup);
		void set_onmouseup(const _Function<_Any*(MouseEvent*)>& onmouseup);
		_Function<_Any*(ClipboardEvent*)>* get_onpaste();
		void set_onpaste(EventListener* onpaste);
		void set_onpaste(const _Function<_Any*(ClipboardEvent*)>& onpaste);
		_Function<_Any*(Event*)>* get_onpause();
		void set_onpause(EventListener* onpause);
		void set_onpause(const _Function<_Any*(Event*)>& onpause);
		_Function<_Any*(Event*)>* get_onplay();
		void set_onplay(EventListener* onplay);
		void set_onplay(const _Function<_Any*(Event*)>& onplay);
		_Function<_Any*(Event*)>* get_onplaying();
		void set_onplaying(EventListener* onplaying);
		void set_onplaying(const _Function<_Any*(Event*)>& onplaying);
		_Function<_Any*(PointerEvent*)>* get_onpointercancel();
		void set_onpointercancel(EventListener* onpointercancel);
		void set_onpointercancel(const _Function<_Any*(PointerEvent*)>& onpointercancel);
		_Function<_Any*(PointerEvent*)>* get_onpointerdown();
		void set_onpointerdown(EventListener* onpointerdown);
		void set_onpointerdown(const _Function<_Any*(PointerEvent*)>& onpointerdown);
		_Function<_Any*(PointerEvent*)>* get_onpointerenter();
		void set_onpointerenter(EventListener* onpointerenter);
		void set_onpointerenter(const _Function<_Any*(PointerEvent*)>& onpointerenter);
		_Function<_Any*(PointerEvent*)>* get_onpointerleave();
		void set_onpointerleave(EventListener* onpointerleave);
		void set_onpointerleave(const _Function<_Any*(PointerEvent*)>& onpointerleave);
		_Function<_Any*(PointerEvent*)>* get_onpointermove();
		void set_onpointermove(EventListener* onpointermove);
		void set_onpointermove(const _Function<_Any*(PointerEvent*)>& onpointermove);
		_Function<_Any*(PointerEvent*)>* get_onpointerout();
		void set_onpointerout(EventListener* onpointerout);
		void set_onpointerout(const _Function<_Any*(PointerEvent*)>& onpointerout);
		_Function<_Any*(PointerEvent*)>* get_onpointerover();
		void set_onpointerover(EventListener* onpointerover);
		void set_onpointerover(const _Function<_Any*(PointerEvent*)>& onpointerover);
		_Function<_Any*(PointerEvent*)>* get_onpointerup();
		void set_onpointerup(EventListener* onpointerup);
		void set_onpointerup(const _Function<_Any*(PointerEvent*)>& onpointerup);
		_Function<_Any*(ProgressEvent<EventTarget*>*)>* get_onprogress();
		void set_onprogress(EventListener* onprogress);
		void set_onprogress(const _Function<_Any*(ProgressEvent<EventTarget*>*)>& onprogress);
		_Function<_Any*(Event*)>* get_onratechange();
		void set_onratechange(EventListener* onratechange);
		void set_onratechange(const _Function<_Any*(Event*)>& onratechange);
		_Function<_Any*(Event*)>* get_onreset();
		void set_onreset(EventListener* onreset);
		void set_onreset(const _Function<_Any*(Event*)>& onreset);
		_Function<_Any*(UIEvent*)>* get_onresize();
		void set_onresize(EventListener* onresize);
		void set_onresize(const _Function<_Any*(UIEvent*)>& onresize);
		_Function<_Any*(Event*)>* get_onscroll();
		void set_onscroll(EventListener* onscroll);
		void set_onscroll(const _Function<_Any*(Event*)>& onscroll);
		_Function<_Any*(Event*)>* get_onscrollend();
		void set_onscrollend(EventListener* onscrollend);
		void set_onscrollend(const _Function<_Any*(Event*)>& onscrollend);
		_Function<_Any*(SecurityPolicyViolationEvent*)>* get_onsecuritypolicyviolation();
		void set_onsecuritypolicyviolation(EventListener* onsecuritypolicyviolation);
		void set_onsecuritypolicyviolation(const _Function<_Any*(SecurityPolicyViolationEvent*)>& onsecuritypolicyviolation);
		_Function<_Any*(Event*)>* get_onseeked();
		void set_onseeked(EventListener* onseeked);
		void set_onseeked(const _Function<_Any*(Event*)>& onseeked);
		_Function<_Any*(Event*)>* get_onseeking();
		void set_onseeking(EventListener* onseeking);
		void set_onseeking(const _Function<_Any*(Event*)>& onseeking);
		_Function<_Any*(Event*)>* get_onselect();
		void set_onselect(EventListener* onselect);
		void set_onselect(const _Function<_Any*(Event*)>& onselect);
		_Function<_Any*(Event*)>* get_onselectionchange();
		void set_onselectionchange(EventListener* onselectionchange);
		void set_onselectionchange(const _Function<_Any*(Event*)>& onselectionchange);
		_Function<_Any*(Event*)>* get_onselectstart();
		void set_onselectstart(EventListener* onselectstart);
		void set_onselectstart(const _Function<_Any*(Event*)>& onselectstart);
		_Function<_Any*(Event*)>* get_onslotchange();
		void set_onslotchange(EventListener* onslotchange);
		void set_onslotchange(const _Function<_Any*(Event*)>& onslotchange);
		_Function<_Any*(Event*)>* get_onstalled();
		void set_onstalled(EventListener* onstalled);
		void set_onstalled(const _Function<_Any*(Event*)>& onstalled);
		_Function<_Any*(SubmitEvent*)>* get_onsubmit();
		void set_onsubmit(EventListener* onsubmit);
		void set_onsubmit(const _Function<_Any*(SubmitEvent*)>& onsubmit);
		_Function<_Any*(Event*)>* get_onsuspend();
		void set_onsuspend(EventListener* onsuspend);
		void set_onsuspend(const _Function<_Any*(Event*)>& onsuspend);
		_Function<_Any*(Event*)>* get_ontimeupdate();
		void set_ontimeupdate(EventListener* ontimeupdate);
		void set_ontimeupdate(const _Function<_Any*(Event*)>& ontimeupdate);
		_Function<_Any*(Event*)>* get_ontoggle();
		void set_ontoggle(EventListener* ontoggle);
		void set_ontoggle(const _Function<_Any*(Event*)>& ontoggle);
		_Function<_Any*(TouchEvent*)>* get_ontouchcancel();
		void set_ontouchcancel(EventListener* ontouchcancel);
		void set_ontouchcancel(const _Function<_Any*(TouchEvent*)>& ontouchcancel);
		_Function<_Any*(TouchEvent*)>* get_ontouchend();
		void set_ontouchend(EventListener* ontouchend);
		void set_ontouchend(const _Function<_Any*(TouchEvent*)>& ontouchend);
		_Function<_Any*(TouchEvent*)>* get_ontouchmove();
		void set_ontouchmove(EventListener* ontouchmove);
		void set_ontouchmove(const _Function<_Any*(TouchEvent*)>& ontouchmove);
		_Function<_Any*(TouchEvent*)>* get_ontouchstart();
		void set_ontouchstart(EventListener* ontouchstart);
		void set_ontouchstart(const _Function<_Any*(TouchEvent*)>& ontouchstart);
		_Function<_Any*(TransitionEvent*)>* get_ontransitioncancel();
		void set_ontransitioncancel(EventListener* ontransitioncancel);
		void set_ontransitioncancel(const _Function<_Any*(TransitionEvent*)>& ontransitioncancel);
		_Function<_Any*(TransitionEvent*)>* get_ontransitionend();
		void set_ontransitionend(EventListener* ontransitionend);
		void set_ontransitionend(const _Function<_Any*(TransitionEvent*)>& ontransitionend);
		_Function<_Any*(TransitionEvent*)>* get_ontransitionrun();
		void set_ontransitionrun(EventListener* ontransitionrun);
		void set_ontransitionrun(const _Function<_Any*(TransitionEvent*)>& ontransitionrun);
		_Function<_Any*(TransitionEvent*)>* get_ontransitionstart();
		void set_ontransitionstart(EventListener* ontransitionstart);
		void set_ontransitionstart(const _Function<_Any*(TransitionEvent*)>& ontransitionstart);
		_Function<_Any*(Event*)>* get_onvolumechange();
		void set_onvolumechange(EventListener* onvolumechange);
		void set_onvolumechange(const _Function<_Any*(Event*)>& onvolumechange);
		_Function<_Any*(Event*)>* get_onwaiting();
		void set_onwaiting(EventListener* onwaiting);
		void set_onwaiting(const _Function<_Any*(Event*)>& onwaiting);
		_Function<_Any*(Event*)>* get_onwebkitanimationend();
		void set_onwebkitanimationend(EventListener* onwebkitanimationend);
		void set_onwebkitanimationend(const _Function<_Any*(Event*)>& onwebkitanimationend);
		_Function<_Any*(Event*)>* get_onwebkitanimationiteration();
		void set_onwebkitanimationiteration(EventListener* onwebkitanimationiteration);
		void set_onwebkitanimationiteration(const _Function<_Any*(Event*)>& onwebkitanimationiteration);
		_Function<_Any*(Event*)>* get_onwebkitanimationstart();
		void set_onwebkitanimationstart(EventListener* onwebkitanimationstart);
		void set_onwebkitanimationstart(const _Function<_Any*(Event*)>& onwebkitanimationstart);
		_Function<_Any*(Event*)>* get_onwebkittransitionend();
		void set_onwebkittransitionend(EventListener* onwebkittransitionend);
		void set_onwebkittransitionend(const _Function<_Any*(Event*)>& onwebkittransitionend);
		_Function<_Any*(WheelEvent*)>* get_onwheel();
		void set_onwheel(EventListener* onwheel);
		void set_onwheel(const _Function<_Any*(WheelEvent*)>& onwheel);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
	};
	class NonElementParentNode: public virtual Object {
	public:
		Element* getElementById(const String& elementId);
	};
	class ParentNode: public virtual Node {
	public:
		double get_childElementCount();
		HTMLCollection* get_children();
		Element* get_firstElementChild();
		Element* get_lastElementChild();
		template<class... _Args>
		[[gnu::always_inline]]
		void append(_Args... nodes) {
			_append(cheerp::clientCast(nodes)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("append"))]]
		_Any* _append(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void prepend(_Args... nodes) {
			_prepend(cheerp::clientCast(nodes)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("prepend"))]]
		_Any* _prepend(_Args... data);
	public:
		_Union<Object*, Element*>* querySelector(const String& selectors);
		_Union<NodeListOf<Object*>*, NodeListOf<Element*>*>* querySelectorAll(const String& selectors);
		template<class... _Args>
		[[gnu::always_inline]]
		void replaceChildren(_Args... nodes) {
			_replaceChildren(cheerp::clientCast(nodes)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("replaceChildren"))]]
		_Any* _replaceChildren(_Args... data);
	};
	class XPathExpression;
	class XPathResult;
	class XPathEvaluatorBase: public virtual Object {
	public:
		XPathExpression* createExpression(const String& expression);
		XPathExpression* createExpression(const String& expression, EventListener* resolver);
		XPathExpression* createExpression(const String& expression, const _Function<String*(String*)>& resolver);
		XPathExpression* createExpression(const String& expression, Object* resolver);
		Node* createNSResolver(Node* nodeResolver);
		XPathResult* evaluate(const String& expression, Node* contextNode);
		XPathResult* evaluate(const String& expression, Node* contextNode, EventListener* resolver);
		XPathResult* evaluate(const String& expression, Node* contextNode, const _Function<String*(String*)>& resolver);
		XPathResult* evaluate(const String& expression, Node* contextNode, Object* resolver);
		XPathResult* evaluate(const String& expression, Node* contextNode, EventListener* resolver, double type);
		XPathResult* evaluate(const String& expression, Node* contextNode, const _Function<String*(String*)>& resolver, double type);
		XPathResult* evaluate(const String& expression, Node* contextNode, Object* resolver, double type);
		XPathResult* evaluate(const String& expression, Node* contextNode, EventListener* resolver, double type, XPathResult* result);
		XPathResult* evaluate(const String& expression, Node* contextNode, const _Function<String*(String*)>& resolver, double type, XPathResult* result);
		XPathResult* evaluate(const String& expression, Node* contextNode, Object* resolver, double type, XPathResult* result);
	};
	class Document: public virtual Node, public DocumentOrShadowRoot, public FontFaceSource, public GlobalEventHandlers, public NonElementParentNode, public ParentNode, public XPathEvaluatorBase {
	public:
		String* get_URL();
		String* get_alinkColor();
		void set_alinkColor(const String& alinkColor);
		HTMLAllCollection* get_all();
		HTMLCollectionOf<HTMLAnchorElement*>* get_anchors();
		HTMLCollection* get_applets();
		String* get_bgColor();
		void set_bgColor(const String& bgColor);
		HTMLElement* get_body();
		void set_body(HTMLElement* body);
		String* get_characterSet();
		String* get_charset();
		String* get_compatMode();
		String* get_contentType();
		String* get_cookie();
		void set_cookie(const String& cookie);
		_Union<HTMLScriptElement*, SVGScriptElement*>* get_currentScript();
		Window* get_defaultView();
		String* get_designMode();
		void set_designMode(const String& designMode);
		String* get_dir();
		void set_dir(const String& dir);
		DocumentType* get_doctype();
		HTMLElement* get_documentElement();
		String* get_documentURI();
		String* get_domain();
		void set_domain(const String& domain);
		HTMLCollectionOf<HTMLEmbedElement*>* get_embeds();
		String* get_fgColor();
		void set_fgColor(const String& fgColor);
		HTMLCollectionOf<HTMLFormElement*>* get_forms();
		bool get_fullscreen();
		bool get_fullscreenEnabled();
		HTMLHeadElement* get_head();
		bool get_hidden();
		HTMLCollectionOf<HTMLImageElement*>* get_images();
		DOMImplementation* get_implementation();
		String* get_inputEncoding();
		String* get_lastModified();
		String* get_linkColor();
		void set_linkColor(const String& linkColor);
		HTMLCollectionOf<_Any*>* get_links();
		Location* get_location();
		Object* set_location(const String& href);
		Object* set_location(Location* href);
		_Function<_Any*(Event*)>* get_onfullscreenchange();
		void set_onfullscreenchange(EventListener* onfullscreenchange);
		void set_onfullscreenchange(const _Function<_Any*(Event*)>& onfullscreenchange);
		_Function<_Any*(Event*)>* get_onfullscreenerror();
		void set_onfullscreenerror(EventListener* onfullscreenerror);
		void set_onfullscreenerror(const _Function<_Any*(Event*)>& onfullscreenerror);
		_Function<_Any*(Event*)>* get_onpointerlockchange();
		void set_onpointerlockchange(EventListener* onpointerlockchange);
		void set_onpointerlockchange(const _Function<_Any*(Event*)>& onpointerlockchange);
		_Function<_Any*(Event*)>* get_onpointerlockerror();
		void set_onpointerlockerror(EventListener* onpointerlockerror);
		void set_onpointerlockerror(const _Function<_Any*(Event*)>& onpointerlockerror);
		_Function<_Any*(Event*)>* get_onreadystatechange();
		void set_onreadystatechange(EventListener* onreadystatechange);
		void set_onreadystatechange(const _Function<_Any*(Event*)>& onreadystatechange);
		_Function<_Any*(Event*)>* get_onvisibilitychange();
		void set_onvisibilitychange(EventListener* onvisibilitychange);
		void set_onvisibilitychange(const _Function<_Any*(Event*)>& onvisibilitychange);
		Object* get_ownerDocument();
		bool get_pictureInPictureEnabled();
		HTMLCollectionOf<HTMLEmbedElement*>* get_plugins();
		String* get_readyState();
		String* get_referrer();
		SVGSVGElement* get_rootElement();
		HTMLCollectionOf<HTMLScriptElement*>* get_scripts();
		Element* get_scrollingElement();
		DocumentTimeline* get_timeline();
		String* get_title();
		void set_title(const String& title);
		String* get_visibilityState();
		String* get_vlinkColor();
		void set_vlinkColor(const String& vlinkColor);
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Node*>, _T0> adoptNode(_T0 node);
		void captureEvents();
		Range* caretRangeFromPoint(double x, double y);
		void clear();
		void close();
		Attr* createAttribute(const String& localName);
		Attr* createAttributeNS(const String& namespace_, const String& qualifiedName);
		CDATASection* createCDATASection(const String& data);
		Comment* createComment(const String& data);
		DocumentFragment* createDocumentFragment();
		HTMLElement* createElement(const String& tagName);
		HTMLElement* createElement(const String& tagName, ElementCreationOptions* options);
		_Union<HTMLElement*, Object*, SVGElement*, MathMLElement*, Element*>* createElementNS(const String& namespaceURI, const String& qualifiedName);
		Element* createElementNS(const String& namespaceURI, const String& qualifiedName, ElementCreationOptions* options);
		Element* createElementNS(const String& namespace_, const String& qualifiedName, const String& options);
		_Union<AnimationEvent*, AnimationPlaybackEvent*, AudioProcessingEvent*, BeforeUnloadEvent*, BlobEvent*, ClipboardEvent*, CloseEvent*, CompositionEvent*, CustomEvent<_Any*>*, DeviceMotionEvent*, DeviceOrientationEvent*, DragEvent*, ErrorEvent*, Event*, FocusEvent*, FontFaceSetLoadEvent*, FormDataEvent*, GamepadEvent*, HashChangeEvent*, IDBVersionChangeEvent*, InputEvent*, KeyboardEvent*, MIDIConnectionEvent*, MIDIMessageEvent*, MediaEncryptedEvent*, MediaKeyMessageEvent*, MediaQueryListEvent*, MediaStreamTrackEvent*, MessageEvent<_Any*>*, MouseEvent*, MutationEvent*, OfflineAudioCompletionEvent*, PageTransitionEvent*, PaymentMethodChangeEvent*, PaymentRequestUpdateEvent*, PictureInPictureEvent*, PointerEvent*, PopStateEvent*, ProgressEvent<EventTarget*>*, PromiseRejectionEvent*, RTCDTMFToneChangeEvent*, RTCDataChannelEvent*, RTCErrorEvent*, RTCPeerConnectionIceErrorEvent*, RTCPeerConnectionIceEvent*, RTCTrackEvent*, SecurityPolicyViolationEvent*, SpeechSynthesisErrorEvent*, SpeechSynthesisEvent*, StorageEvent*, SubmitEvent*, ToggleEvent*, TouchEvent*, TrackEvent*, TransitionEvent*, UIEvent*, WebGLContextEvent*, WheelEvent*>* createEvent(const String& eventInterface);
		NodeIterator* createNodeIterator(Node* root);
		NodeIterator* createNodeIterator(Node* root, double whatToShow);
		NodeIterator* createNodeIterator(Node* root, double whatToShow, EventListener* filter);
		NodeIterator* createNodeIterator(Node* root, double whatToShow, const _Function<double(Node*)>& filter);
		NodeIterator* createNodeIterator(Node* root, double whatToShow, Object* filter);
		ProcessingInstruction* createProcessingInstruction(const String& target, const String& data);
		Range* createRange();
		Text* createTextNode(const String& data);
		TreeWalker* createTreeWalker(Node* root);
		TreeWalker* createTreeWalker(Node* root, double whatToShow);
		TreeWalker* createTreeWalker(Node* root, double whatToShow, EventListener* filter);
		TreeWalker* createTreeWalker(Node* root, double whatToShow, const _Function<double(Node*)>& filter);
		TreeWalker* createTreeWalker(Node* root, double whatToShow, Object* filter);
		bool execCommand(const String& commandId);
		bool execCommand(const String& commandId, bool showUI);
		bool execCommand(const String& commandId, bool showUI, const String& value);
		Promise<_Any*>* exitFullscreen();
		Promise<_Any*>* exitPictureInPicture();
		void exitPointerLock();
		HTMLElement* getElementById(const String& elementId);
		HTMLCollectionOf<Element*>* getElementsByClassName(const String& classNames);
		NodeListOf<HTMLElement*>* getElementsByName(const String& elementName);
		HTMLCollectionOf<HTMLElement*>* getElementsByTagName(const String& qualifiedName);
		_Union<HTMLCollectionOf<HTMLElement*>*, HTMLCollectionOf<SVGElement*>*, HTMLCollectionOf<MathMLElement*>*, HTMLCollectionOf<Element*>*>* getElementsByTagNameNS(const String& namespaceURI, const String& localName);
		Selection* getSelection();
		bool hasFocus();
		Promise<bool>* hasStorageAccess();
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Node*>, _T0> importNode(_T0 node);
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, Node*>, _T0> importNode(_T0 node, bool deep);
		Document* open();
		Document* open(const String& unused1);
		Document* open(const String& unused1, const String& unused2);
		Window* open(const String& url, const String& name, const String& features);
		Window* open(URL* url, const String& name, const String& features);
		bool queryCommandEnabled(const String& commandId);
		bool queryCommandIndeterm(const String& commandId);
		bool queryCommandState(const String& commandId);
		bool queryCommandSupported(const String& commandId);
		String* queryCommandValue(const String& commandId);
		void releaseEvents();
		Promise<_Any*>* requestStorageAccess();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, String*> && ...), void> write(_Args... text) {
			_write(cheerp::clientCast(text)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("write"))]]
		_Any* _write(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, String*> && ...), void> writeln(_Args... text) {
			_writeln(cheerp::clientCast(text)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("writeln"))]]
		_Any* _writeln(_Args... data);
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static Document* prototype;
		Document();
	};
	class DocumentFragment: public virtual Node, public NonElementParentNode, public ParentNode {
	public:
		Document* get_ownerDocument();
		HTMLElement* getElementById(const String& elementId);
		static DocumentFragment* prototype;
		DocumentFragment();
	};
	class DocumentTimeline: public AnimationTimeline {
	public:
		static DocumentTimeline* prototype;
		DocumentTimeline();
		DocumentTimeline(DocumentTimelineOptions* options);
	};
	class DocumentType: public virtual Node, public ChildNode {
	public:
		String* get_name();
		Document* get_ownerDocument();
		String* get_publicId();
		String* get_systemId();
		static DocumentType* prototype;
		DocumentType();
	};
	class MouseEvent: public UIEvent {
	public:
		bool get_altKey();
		double get_button();
		double get_buttons();
		double get_clientX();
		double get_clientY();
		bool get_ctrlKey();
		bool get_metaKey();
		double get_movementX();
		double get_movementY();
		double get_offsetX();
		double get_offsetY();
		double get_pageX();
		double get_pageY();
		EventTarget* get_relatedTarget();
		double get_screenX();
		double get_screenY();
		bool get_shiftKey();
		double get_x();
		double get_y();
		bool getModifierState(const String& keyArg);
		void initMouseEvent(const String& typeArg, bool canBubbleArg, bool cancelableArg, Window* viewArg, double detailArg, double screenXArg, double screenYArg, double clientXArg, double clientYArg, bool ctrlKeyArg, bool altKeyArg, bool shiftKeyArg, bool metaKeyArg, double buttonArg, EventTarget* relatedTargetArg);
		static MouseEvent* prototype;
		MouseEvent(const String& type);
		MouseEvent(const String& type, MouseEventInit* eventInitDict);
	};
	class DragEvent: public MouseEvent {
	public:
		DataTransfer* get_dataTransfer();
		static DragEvent* prototype;
		DragEvent(const String& type);
		DragEvent(const String& type, DragEventInit* eventInitDict);
	};
	class DynamicsCompressorNode: public AudioNode {
	public:
		AudioParam* get_attack();
		AudioParam* get_knee();
		AudioParam* get_ratio();
		double get_reduction();
		AudioParam* get_release();
		AudioParam* get_threshold();
		static DynamicsCompressorNode* prototype;
		DynamicsCompressorNode(BaseAudioContext* context);
		DynamicsCompressorNode(BaseAudioContext* context, DynamicsCompressorOptions* options);
	};
	class EXT_blend_minmax: public Object {
	public:
		double get_MIN_EXT();
		double get_MAX_EXT();
	};
	class EXT_color_buffer_float: public Object {
	};
	class EXT_color_buffer_half_float: public Object {
	public:
		double get_RGBA16F_EXT();
		double get_RGB16F_EXT();
		double get_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT();
		double get_UNSIGNED_NORMALIZED_EXT();
	};
	class EXT_float_blend: public Object {
	};
	class EXT_frag_depth: public Object {
	};
	class EXT_sRGB: public Object {
	public:
		double get_SRGB_EXT();
		double get_SRGB_ALPHA_EXT();
		double get_SRGB8_ALPHA8_EXT();
		double get_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT();
	};
	class EXT_shader_texture_lod: public Object {
	};
	class EXT_texture_compression_bptc: public Object {
	public:
		double get_COMPRESSED_RGBA_BPTC_UNORM_EXT();
		double get_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT();
		double get_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT();
		double get_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT();
	};
	class EXT_texture_compression_rgtc: public Object {
	public:
		double get_COMPRESSED_RED_RGTC1_EXT();
		double get_COMPRESSED_SIGNED_RED_RGTC1_EXT();
		double get_COMPRESSED_RED_GREEN_RGTC2_EXT();
		double get_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT();
	};
	class EXT_texture_filter_anisotropic: public Object {
	public:
		double get_TEXTURE_MAX_ANISOTROPY_EXT();
		double get_MAX_TEXTURE_MAX_ANISOTROPY_EXT();
	};
	class EXT_texture_norm16: public Object {
	public:
		double get_R16_EXT();
		double get_RG16_EXT();
		double get_RGB16_EXT();
		double get_RGBA16_EXT();
		double get_R16_SNORM_EXT();
		double get_RG16_SNORM_EXT();
		double get_RGB16_SNORM_EXT();
		double get_RGBA16_SNORM_EXT();
	};
	class ElementEventMap: public virtual Object {
	public:
		[[cheerp::interface_name(("get_\"fullscreenchange\""))]]
		Event* get__34_fullscreenchange_34_();
		[[cheerp::interface_name(("set_\"fullscreenchange\""))]]
		void set__34_fullscreenchange_34_(Event* _34_fullscreenchange_34_);
		[[cheerp::interface_name(("get_\"fullscreenerror\""))]]
		Event* get__34_fullscreenerror_34_();
		[[cheerp::interface_name(("set_\"fullscreenerror\""))]]
		void set__34_fullscreenerror_34_(Event* _34_fullscreenerror_34_);
	};
	class NamedNodeMap;
	class ShadowRoot;
	class StylePropertyMapReadOnly;
	class InnerHTML: public virtual Object {
	public:
		String* get_innerHTML();
		void set_innerHTML(const String& innerHTML);
	};
	class Element: public virtual Node, public ARIAMixin, public Animatable, public ChildNode, public InnerHTML, public NonDocumentTypeChildNode, public ParentNode, public Slottable {
	public:
		NamedNodeMap* get_attributes();
		DOMTokenList* get_classList();
		String* get_className();
		void set_className(const String& className);
		double get_clientHeight();
		double get_clientLeft();
		double get_clientTop();
		double get_clientWidth();
		String* get_id();
		void set_id(const String& id);
		String* get_localName();
		String* get_namespaceURI();
		_Function<_Any*(Event*)>* get_onfullscreenchange();
		void set_onfullscreenchange(EventListener* onfullscreenchange);
		void set_onfullscreenchange(const _Function<_Any*(Event*)>& onfullscreenchange);
		_Function<_Any*(Event*)>* get_onfullscreenerror();
		void set_onfullscreenerror(EventListener* onfullscreenerror);
		void set_onfullscreenerror(const _Function<_Any*(Event*)>& onfullscreenerror);
		String* get_outerHTML();
		void set_outerHTML(const String& outerHTML);
		Document* get_ownerDocument();
		DOMTokenList* get_part();
		String* get_prefix();
		double get_scrollHeight();
		double get_scrollLeft();
		void set_scrollLeft(double scrollLeft);
		double get_scrollTop();
		void set_scrollTop(double scrollTop);
		double get_scrollWidth();
		ShadowRoot* get_shadowRoot();
		String* get_slot();
		void set_slot(const String& slot);
		String* get_tagName();
		ShadowRoot* attachShadow(ShadowRootInit* init);
		bool checkVisibility();
		bool checkVisibility(CheckVisibilityOptions* options);
		_Union<Object*, Element*>* closest(const String& selector);
		StylePropertyMapReadOnly* computedStyleMap();
		String* getAttribute(const String& qualifiedName);
		String* getAttributeNS(const String& namespace_, const String& localName);
		TArray<String*>* getAttributeNames();
		Attr* getAttributeNode(const String& qualifiedName);
		Attr* getAttributeNodeNS(const String& namespace_, const String& localName);
		DOMRect* getBoundingClientRect();
		DOMRectList* getClientRects();
		HTMLCollectionOf<Element*>* getElementsByClassName(const String& classNames);
		_Union<HTMLCollectionOf<Object*>*, HTMLCollectionOf<Element*>*>* getElementsByTagName(const String& qualifiedName);
		_Union<HTMLCollectionOf<HTMLElement*>*, HTMLCollectionOf<SVGElement*>*, HTMLCollectionOf<MathMLElement*>*, HTMLCollectionOf<Element*>*>* getElementsByTagNameNS(const String& namespaceURI, const String& localName);
		bool hasAttribute(const String& qualifiedName);
		bool hasAttributeNS(const String& namespace_, const String& localName);
		bool hasAttributes();
		bool hasPointerCapture(double pointerId);
		Element* insertAdjacentElement(const String& where, Element* element);
		void insertAdjacentHTML(const String& position, const String& text);
		void insertAdjacentText(const String& where, const String& data);
		bool matches(const String& selectors);
		void releasePointerCapture(double pointerId);
		void removeAttribute(const String& qualifiedName);
		void removeAttributeNS(const String& namespace_, const String& localName);
		Attr* removeAttributeNode(Attr* attr);
		Promise<_Any*>* requestFullscreen();
		Promise<_Any*>* requestFullscreen(FullscreenOptions* options);
		void requestPointerLock();
		void scroll();
		void scroll(ScrollToOptions* options);
		void scroll(double x, double y);
		void scrollBy();
		void scrollBy(ScrollToOptions* options);
		void scrollBy(double x, double y);
		void scrollIntoView();
		void scrollIntoView(const _Union<bool, ScrollIntoViewOptions*>& arg);
		void scrollTo();
		void scrollTo(ScrollToOptions* options);
		void scrollTo(double x, double y);
		void setAttribute(const String& qualifiedName, const String& value);
		void setAttributeNS(const String& namespace_, const String& qualifiedName, const String& value);
		Attr* setAttributeNode(Attr* attr);
		Attr* setAttributeNodeNS(Attr* attr);
		void setPointerCapture(double pointerId);
		bool toggleAttribute(const String& qualifiedName);
		bool toggleAttribute(const String& qualifiedName, bool force);
		bool webkitMatchesSelector(const String& selectors);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static Element* prototype;
		Element();
	};
	class ElementCSSInlineStyle: public virtual Object {
	public:
		StylePropertyMap* get_attributeStyleMap();
		CSSStyleDeclaration* get_style();
	};
	class ElementContentEditable: public virtual Object {
	public:
		String* get_contentEditable();
		void set_contentEditable(const String& contentEditable);
		String* get_enterKeyHint();
		void set_enterKeyHint(const String& enterKeyHint);
		String* get_inputMode();
		void set_inputMode(const String& inputMode);
		bool get_isContentEditable();
	};
	class NodeList;
	class ValidityState;
	class ElementInternals: public ARIAMixin {
	public:
		HTMLFormElement* get_form();
		NodeList* get_labels();
		ShadowRoot* get_shadowRoot();
		String* get_validationMessage();
		ValidityState* get_validity();
		bool get_willValidate();
		bool checkValidity();
		bool reportValidity();
		void setFormValue(const String& value);
		void setFormValue(const _Union<File*, FormData*>& value);
		void setFormValue(const String& value, const String& state);
		void setFormValue(const _Union<File*, FormData*>& value, const String& state);
		void setFormValue(const String& value, const _Union<File*, FormData*>& state);
		void setFormValue(const _Union<File*, FormData*>& value, const _Union<File*, FormData*>& state);
		void setValidity();
		void setValidity(ValidityStateFlags* flags);
		void setValidity(ValidityStateFlags* flags, const String& message);
		void setValidity(ValidityStateFlags* flags, const String& message, HTMLElement* anchor);
		static ElementInternals* prototype;
		ElementInternals();
	};
	class EncodedVideoChunk: public Object {
	public:
		double get_byteLength();
		double get_duration();
		double get_timestamp();
		String* get_type();
		void copyTo(const _Union<ArrayBuffer*, ArrayBufferView*>& destination);
		static EncodedVideoChunk* prototype;
		EncodedVideoChunk(EncodedVideoChunkInit* init);
	};
	class ErrorEvent: public Event {
	public:
		double get_colno();
		Object* get_error();
		String* get_filename();
		double get_lineno();
		String* get_message();
		static ErrorEvent* prototype;
		ErrorEvent(const String& type);
		ErrorEvent(const String& type, ErrorEventInit* eventInitDict);
	};
	class EventCounts: public Object {
	public:
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(double, String*, EventCounts*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(double, String*, EventCounts*)>& callbackfn, const _Any& thisArg);
		static EventCounts* prototype;
		EventCounts();
	};
	class EventListener: public Object {
	};
	class EventListenerObject: public Object {
	public:
		void handleEvent(Event* object);
	};
	class EventSourceEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"open\""))]]
		Event* get__34_open_34_();
		[[cheerp::interface_name(("set_\"open\""))]]
		void set__34_open_34_(Event* _34_open_34_);
	};
	class EventSource: public EventTarget {
	public:
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(Event*)>* get_onopen();
		void set_onopen(EventListener* onopen);
		void set_onopen(const _Function<_Any*(Event*)>& onopen);
		double get_readyState();
		String* get_url();
		bool get_withCredentials();
		void close();
		double get_CONNECTING();
		double get_OPEN();
		double get_CLOSED();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, MessageEvent<_Any*>*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, MessageEvent<_Any*>*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, MessageEvent<_Any*>*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, MessageEvent<_Any*>*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static EventSource* prototype;
		EventSource(const String& url);
		EventSource(URL* url);
		EventSource(const String& url, EventSourceInit* eventSourceInitDict);
		EventSource(URL* url, EventSourceInit* eventSourceInitDict);
		static double CONNECTING;
		static double OPEN;
		static double CLOSED;
	};
	class External: public Object {
	public:
		void AddSearchProvider();
		void IsSearchProviderInstalled();
		static External* prototype;
		External();
	};
	class File: public Blob {
	public:
		double get_lastModified();
		String* get_name();
		String* get_webkitRelativePath();
		static File* prototype;
		File(Array* fileBits, const String& fileName);
		File(Array* fileBits, const String& fileName, FilePropertyBag* options);
	};
	class FileList: public Object {
	public:
		int get_length() const;
		File* item(double index);
		File* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		File*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::File*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static FileList* prototype;
		FileList();
	public:
		using client::Object::operator[];
	};
	class FileReader;
	class FileReaderEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"abort\""))]]
		ProgressEvent<FileReader*>* get__34_abort_34_();
		[[cheerp::interface_name(("set_\"abort\""))]]
		void set__34_abort_34_(ProgressEvent<FileReader*>* _34_abort_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		ProgressEvent<FileReader*>* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(ProgressEvent<FileReader*>* _34_error_34_);
		[[cheerp::interface_name(("get_\"load\""))]]
		ProgressEvent<FileReader*>* get__34_load_34_();
		[[cheerp::interface_name(("set_\"load\""))]]
		void set__34_load_34_(ProgressEvent<FileReader*>* _34_load_34_);
		[[cheerp::interface_name(("get_\"loadend\""))]]
		ProgressEvent<FileReader*>* get__34_loadend_34_();
		[[cheerp::interface_name(("set_\"loadend\""))]]
		void set__34_loadend_34_(ProgressEvent<FileReader*>* _34_loadend_34_);
		[[cheerp::interface_name(("get_\"loadstart\""))]]
		ProgressEvent<FileReader*>* get__34_loadstart_34_();
		[[cheerp::interface_name(("set_\"loadstart\""))]]
		void set__34_loadstart_34_(ProgressEvent<FileReader*>* _34_loadstart_34_);
		[[cheerp::interface_name(("get_\"progress\""))]]
		ProgressEvent<FileReader*>* get__34_progress_34_();
		[[cheerp::interface_name(("set_\"progress\""))]]
		void set__34_progress_34_(ProgressEvent<FileReader*>* _34_progress_34_);
	};
	class FileReader: public EventTarget {
	public:
		DOMException* get_error();
		_Function<_Any*(ProgressEvent<FileReader*>*)>* get_onabort();
		void set_onabort(EventListener* onabort);
		void set_onabort(const _Function<_Any*(ProgressEvent<FileReader*>*)>& onabort);
		_Function<_Any*(ProgressEvent<FileReader*>*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(ProgressEvent<FileReader*>*)>& onerror);
		_Function<_Any*(ProgressEvent<FileReader*>*)>* get_onload();
		void set_onload(EventListener* onload);
		void set_onload(const _Function<_Any*(ProgressEvent<FileReader*>*)>& onload);
		_Function<_Any*(ProgressEvent<FileReader*>*)>* get_onloadend();
		void set_onloadend(EventListener* onloadend);
		void set_onloadend(const _Function<_Any*(ProgressEvent<FileReader*>*)>& onloadend);
		_Function<_Any*(ProgressEvent<FileReader*>*)>* get_onloadstart();
		void set_onloadstart(EventListener* onloadstart);
		void set_onloadstart(const _Function<_Any*(ProgressEvent<FileReader*>*)>& onloadstart);
		_Function<_Any*(ProgressEvent<FileReader*>*)>* get_onprogress();
		void set_onprogress(EventListener* onprogress);
		void set_onprogress(const _Function<_Any*(ProgressEvent<FileReader*>*)>& onprogress);
		double get_readyState();
		_Union<String*, ArrayBuffer*>* get_result();
		void abort();
		void readAsArrayBuffer(Blob* blob);
		void readAsBinaryString(Blob* blob);
		void readAsDataURL(Blob* blob);
		void readAsText(Blob* blob);
		void readAsText(Blob* blob, const String& encoding);
		double get_EMPTY();
		double get_LOADING();
		double get_DONE();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static FileReader* prototype;
		FileReader();
		static double EMPTY;
		static double LOADING;
		static double DONE;
	};
	class FileSystemDirectoryEntry;
	class FileSystem: public Object {
	public:
		String* get_name();
		FileSystemDirectoryEntry* get_root();
		static FileSystem* prototype;
		FileSystem();
	};
	class FileSystemDirectoryReader;
	class FileSystemEntry: public Object {
	public:
		FileSystem* get_filesystem();
		String* get_fullPath();
		bool get_isDirectory();
		bool get_isFile();
		String* get_name();
		void getParent();
		void getParent(EventListener* successCallback);
		void getParent(const _Function<void(FileSystemEntry*)>& successCallback);
		void getParent(EventListener* successCallback, EventListener* errorCallback);
		void getParent(const _Function<void(FileSystemEntry*)>& successCallback, EventListener* errorCallback);
		void getParent(EventListener* successCallback, const _Function<void(DOMException*)>& errorCallback);
		void getParent(const _Function<void(FileSystemEntry*)>& successCallback, const _Function<void(DOMException*)>& errorCallback);
		static FileSystemEntry* prototype;
		FileSystemEntry();
	};
	class FileSystemDirectoryEntry: public FileSystemEntry {
	public:
		FileSystemDirectoryReader* createReader();
		void getDirectory();
		void getDirectory(const String& path);
		void getDirectory(const String& path, FileSystemFlags* options);
		void getDirectory(const String& path, FileSystemFlags* options, EventListener* successCallback);
		void getDirectory(const String& path, FileSystemFlags* options, const _Function<void(FileSystemEntry*)>& successCallback);
		void getDirectory(const String& path, FileSystemFlags* options, EventListener* successCallback, EventListener* errorCallback);
		void getDirectory(const String& path, FileSystemFlags* options, const _Function<void(FileSystemEntry*)>& successCallback, EventListener* errorCallback);
		void getDirectory(const String& path, FileSystemFlags* options, EventListener* successCallback, const _Function<void(DOMException*)>& errorCallback);
		void getDirectory(const String& path, FileSystemFlags* options, const _Function<void(FileSystemEntry*)>& successCallback, const _Function<void(DOMException*)>& errorCallback);
		void getFile();
		void getFile(const String& path);
		void getFile(const String& path, FileSystemFlags* options);
		void getFile(const String& path, FileSystemFlags* options, EventListener* successCallback);
		void getFile(const String& path, FileSystemFlags* options, const _Function<void(FileSystemEntry*)>& successCallback);
		void getFile(const String& path, FileSystemFlags* options, EventListener* successCallback, EventListener* errorCallback);
		void getFile(const String& path, FileSystemFlags* options, const _Function<void(FileSystemEntry*)>& successCallback, EventListener* errorCallback);
		void getFile(const String& path, FileSystemFlags* options, EventListener* successCallback, const _Function<void(DOMException*)>& errorCallback);
		void getFile(const String& path, FileSystemFlags* options, const _Function<void(FileSystemEntry*)>& successCallback, const _Function<void(DOMException*)>& errorCallback);
		static FileSystemDirectoryEntry* prototype;
		FileSystemDirectoryEntry();
	};
	class FileSystemFileHandle;
	class FileSystemHandle: public Object {
	public:
		String* get_kind();
		String* get_name();
		Promise<bool>* isSameEntry(FileSystemHandle* other);
		static FileSystemHandle* prototype;
		FileSystemHandle();
	};
	class FileSystemDirectoryHandle: public FileSystemHandle {
	public:
		String* get_kind();
		Promise<FileSystemDirectoryHandle*>* getDirectoryHandle(const String& name);
		Promise<FileSystemDirectoryHandle*>* getDirectoryHandle(const String& name, FileSystemGetDirectoryOptions* options);
		Promise<FileSystemFileHandle*>* getFileHandle(const String& name);
		Promise<FileSystemFileHandle*>* getFileHandle(const String& name, FileSystemGetFileOptions* options);
		Promise<_Any*>* removeEntry(const String& name);
		Promise<_Any*>* removeEntry(const String& name, FileSystemRemoveOptions* options);
		Promise<TArray<String*>*>* resolve(FileSystemHandle* possibleDescendant);
		static FileSystemDirectoryHandle* prototype;
		FileSystemDirectoryHandle();
	};
	class FileSystemDirectoryReader: public Object {
	public:
		void readEntries(EventListener* successCallback);
		void readEntries(const _Function<void(TArray<FileSystemEntry*>*)>& successCallback);
		void readEntries(EventListener* successCallback, EventListener* errorCallback);
		void readEntries(const _Function<void(TArray<FileSystemEntry*>*)>& successCallback, EventListener* errorCallback);
		void readEntries(EventListener* successCallback, const _Function<void(DOMException*)>& errorCallback);
		void readEntries(const _Function<void(TArray<FileSystemEntry*>*)>& successCallback, const _Function<void(DOMException*)>& errorCallback);
		static FileSystemDirectoryReader* prototype;
		FileSystemDirectoryReader();
	};
	class FileSystemFileEntry: public FileSystemEntry {
	public:
		void file(EventListener* successCallback);
		void file(const _Function<void(File*)>& successCallback);
		void file(EventListener* successCallback, EventListener* errorCallback);
		void file(const _Function<void(File*)>& successCallback, EventListener* errorCallback);
		void file(EventListener* successCallback, const _Function<void(DOMException*)>& errorCallback);
		void file(const _Function<void(File*)>& successCallback, const _Function<void(DOMException*)>& errorCallback);
		static FileSystemFileEntry* prototype;
		FileSystemFileEntry();
	};
	class FileSystemWritableFileStream;
	class FileSystemSyncAccessHandle;
	class FileSystemFileHandle: public FileSystemHandle {
	public:
		String* get_kind();
		Promise<FileSystemWritableFileStream*>* createWritable();
		Promise<FileSystemWritableFileStream*>* createWritable(FileSystemCreateWritableOptions* options);
		Promise<File*>* getFile();
		Promise<FileSystemSyncAccessHandle*>* createSyncAccessHandle();
		static FileSystemFileHandle* prototype;
		FileSystemFileHandle();
	};
	template<class _T0>
	class WritableStreamDefaultWriter;
	template<class _T0>
	class WritableStream: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool get_locked();
		Promise<_Any*>* abort();
		Promise<_Any*>* abort(const _Any& reason);
		Promise<_Any*>* close();
		WritableStreamDefaultWriter<_T0>* getWriter();
		static WritableStream<_Any*>* prototype;
		WritableStream();
		template<class _T1 = _Any*>
		WritableStream(UnderlyingSink<_T1>* underlyingSink);
		template<class _T1 = _Any*>
		WritableStream(UnderlyingSink<_T1>* underlyingSink, QueuingStrategy<_T1>* strategy);
	};
	class FileSystemWritableFileStream: public WritableStream<_Any*> {
	public:
		Promise<_Any*>* seek(double position);
		Promise<_Any*>* truncate(double size);
		Promise<_Any*>* write(const String& data);
		Promise<_Any*>* write(const _Union<ArrayBuffer*, ArrayBufferView*, WriteParams*, Blob*>& data);
		static FileSystemWritableFileStream* prototype;
		FileSystemWritableFileStream();
	};
	class FocusEvent: public UIEvent {
	public:
		EventTarget* get_relatedTarget();
		static FocusEvent* prototype;
		FocusEvent(const String& type);
		FocusEvent(const String& type, FocusEventInit* eventInitDict);
	};
	class FontFace: public Object {
	public:
		String* get_ascentOverride();
		void set_ascentOverride(const String& ascentOverride);
		String* get_descentOverride();
		void set_descentOverride(const String& descentOverride);
		String* get_display();
		void set_display(const String& display);
		String* get_family();
		void set_family(const String& family);
		String* get_featureSettings();
		void set_featureSettings(const String& featureSettings);
		String* get_lineGapOverride();
		void set_lineGapOverride(const String& lineGapOverride);
		Promise<FontFace*>* get_loaded();
		String* get_status();
		String* get_stretch();
		void set_stretch(const String& stretch);
		String* get_style();
		void set_style(const String& style);
		String* get_unicodeRange();
		void set_unicodeRange(const String& unicodeRange);
		String* get_variant();
		void set_variant(const String& variant);
		String* get_weight();
		void set_weight(const String& weight);
		Promise<FontFace*>* load();
		static FontFace* prototype;
		FontFace(const String& family, const String& source);
		FontFace(const String& family, const _Union<ArrayBuffer*, ArrayBufferView*>& source);
		FontFace(const String& family, const String& source, FontFaceDescriptors* descriptors);
		FontFace(const String& family, const _Union<ArrayBuffer*, ArrayBufferView*>& source, FontFaceDescriptors* descriptors);
	};
	class FontFaceSetEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"loading\""))]]
		Event* get__34_loading_34_();
		[[cheerp::interface_name(("set_\"loading\""))]]
		void set__34_loading_34_(Event* _34_loading_34_);
		[[cheerp::interface_name(("get_\"loadingdone\""))]]
		Event* get__34_loadingdone_34_();
		[[cheerp::interface_name(("set_\"loadingdone\""))]]
		void set__34_loadingdone_34_(Event* _34_loadingdone_34_);
		[[cheerp::interface_name(("get_\"loadingerror\""))]]
		Event* get__34_loadingerror_34_();
		[[cheerp::interface_name(("set_\"loadingerror\""))]]
		void set__34_loadingerror_34_(Event* _34_loadingerror_34_);
	};
	class FontFaceSet: public EventTarget {
	public:
		_Function<_Any*(Event*)>* get_onloading();
		void set_onloading(EventListener* onloading);
		void set_onloading(const _Function<_Any*(Event*)>& onloading);
		_Function<_Any*(Event*)>* get_onloadingdone();
		void set_onloadingdone(EventListener* onloadingdone);
		void set_onloadingdone(const _Function<_Any*(Event*)>& onloadingdone);
		_Function<_Any*(Event*)>* get_onloadingerror();
		void set_onloadingerror(EventListener* onloadingerror);
		void set_onloadingerror(const _Function<_Any*(Event*)>& onloadingerror);
		Promise<FontFaceSet*>* get_ready();
		String* get_status();
		bool check(const String& font);
		bool check(const String& font, const String& text);
		Promise<TArray<FontFace*>*>* load(const String& font);
		Promise<TArray<FontFace*>*>* load(const String& font, const String& text);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(FontFace*, FontFace*, FontFaceSet*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(FontFace*, FontFace*, FontFaceSet*)>& callbackfn, const _Any& thisArg);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static FontFaceSet* prototype;
		FontFaceSet(TArray<FontFace*>* initialFaces);
	};
	class FontFaceSetLoadEvent: public Event {
	public:
		ReadonlyArray<FontFace*>* get_fontfaces();
		static FontFaceSetLoadEvent* prototype;
		FontFaceSetLoadEvent(const String& type);
		FontFaceSetLoadEvent(const String& type, FontFaceSetLoadEventInit* eventInitDict);
	};
	class FormData: public Object {
	public:
		void append(const String& name, const String& value);
		void append(const String& name, Blob* value);
		void append(const String& name, Blob* blobValue, const String& filename);
		[[cheerp::interface_name(("delete"))]]
		void delete_(const String& name);
		_Union<String*, File*>* get(const String& name);
		TArray<_Any*>* getAll(const String& name);
		bool has(const String& name);
		void set(const String& name, const String& value);
		void set(const String& name, Blob* value);
		void set(const String& name, Blob* blobValue, const String& filename);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(_Union<String*, File*>*, String*, FormData*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(_Union<String*, File*>*, String*, FormData*)>& callbackfn, const _Any& thisArg);
		static FormData* prototype;
		FormData();
	};
	class FormDataEvent: public Event {
	public:
		FormData* get_formData();
		static FormDataEvent* prototype;
		FormDataEvent(const String& type, FormDataEventInit* eventInitDict);
	};
	class GainNode: public AudioNode {
	public:
		AudioParam* get_gain();
		static GainNode* prototype;
		GainNode(BaseAudioContext* context);
		GainNode(BaseAudioContext* context, GainOptions* options);
	};
	class GamepadButton;
	class GamepadHapticActuator;
	class Gamepad: public Object {
	public:
		ReadonlyArray<double>* get_axes();
		ReadonlyArray<GamepadButton*>* get_buttons();
		bool get_connected();
		ReadonlyArray<GamepadHapticActuator*>* get_hapticActuators();
		String* get_id();
		double get_index();
		String* get_mapping();
		double get_timestamp();
		GamepadHapticActuator* get_vibrationActuator();
		static Gamepad* prototype;
		Gamepad();
	};
	class GamepadButton: public Object {
	public:
		bool get_pressed();
		bool get_touched();
		double get_value();
		static GamepadButton* prototype;
		GamepadButton();
	};
	class GamepadEvent: public Event {
	public:
		Gamepad* get_gamepad();
		static GamepadEvent* prototype;
		GamepadEvent(const String& type, GamepadEventInit* eventInitDict);
	};
	class GamepadHapticActuator: public Object {
	public:
		String* get_type();
		Promise<String*>* playEffect(const String& type);
		Promise<String*>* playEffect(const String& type, GamepadEffectParameters* params);
		Promise<String*>* reset();
		static GamepadHapticActuator* prototype;
		GamepadHapticActuator();
	};
	class GeolocationPosition;
	class GeolocationPositionError;
	class Geolocation: public Object {
	public:
		void clearWatch(double watchId);
		void getCurrentPosition(EventListener* successCallback);
		void getCurrentPosition(const _Function<void(GeolocationPosition*)>& successCallback);
		void getCurrentPosition(EventListener* successCallback, EventListener* errorCallback);
		void getCurrentPosition(const _Function<void(GeolocationPosition*)>& successCallback, EventListener* errorCallback);
		void getCurrentPosition(EventListener* successCallback, const _Function<void(GeolocationPositionError*)>& errorCallback);
		void getCurrentPosition(const _Function<void(GeolocationPosition*)>& successCallback, const _Function<void(GeolocationPositionError*)>& errorCallback);
		void getCurrentPosition(EventListener* successCallback, EventListener* errorCallback, PositionOptions* options);
		void getCurrentPosition(const _Function<void(GeolocationPosition*)>& successCallback, EventListener* errorCallback, PositionOptions* options);
		void getCurrentPosition(EventListener* successCallback, const _Function<void(GeolocationPositionError*)>& errorCallback, PositionOptions* options);
		void getCurrentPosition(const _Function<void(GeolocationPosition*)>& successCallback, const _Function<void(GeolocationPositionError*)>& errorCallback, PositionOptions* options);
		double watchPosition(EventListener* successCallback);
		double watchPosition(const _Function<void(GeolocationPosition*)>& successCallback);
		double watchPosition(EventListener* successCallback, EventListener* errorCallback);
		double watchPosition(const _Function<void(GeolocationPosition*)>& successCallback, EventListener* errorCallback);
		double watchPosition(EventListener* successCallback, const _Function<void(GeolocationPositionError*)>& errorCallback);
		double watchPosition(const _Function<void(GeolocationPosition*)>& successCallback, const _Function<void(GeolocationPositionError*)>& errorCallback);
		double watchPosition(EventListener* successCallback, EventListener* errorCallback, PositionOptions* options);
		double watchPosition(const _Function<void(GeolocationPosition*)>& successCallback, EventListener* errorCallback, PositionOptions* options);
		double watchPosition(EventListener* successCallback, const _Function<void(GeolocationPositionError*)>& errorCallback, PositionOptions* options);
		double watchPosition(const _Function<void(GeolocationPosition*)>& successCallback, const _Function<void(GeolocationPositionError*)>& errorCallback, PositionOptions* options);
		static Geolocation* prototype;
		Geolocation();
	};
	class GeolocationCoordinates: public Object {
	public:
		double get_accuracy();
		double get_altitude();
		double get_altitudeAccuracy();
		double get_heading();
		double get_latitude();
		double get_longitude();
		double get_speed();
		static GeolocationCoordinates* prototype;
		GeolocationCoordinates();
	};
	class GeolocationPosition: public Object {
	public:
		GeolocationCoordinates* get_coords();
		double get_timestamp();
		static GeolocationPosition* prototype;
		GeolocationPosition();
	};
	class GeolocationPositionError: public Object {
	public:
		double get_code();
		String* get_message();
		double get_PERMISSION_DENIED();
		double get_POSITION_UNAVAILABLE();
		double get_TIMEOUT();
		static GeolocationPositionError* prototype;
		GeolocationPositionError();
		static double PERMISSION_DENIED;
		static double POSITION_UNAVAILABLE;
		static double TIMEOUT;
	};
	class HTMLAllCollection: public Object {
	public:
		int get_length() const;
		_Union<Element*, HTMLCollection*>* item();
		_Union<Element*, HTMLCollection*>* item(const String& nameOrIndex);
		_Union<Element*, HTMLCollection*>* namedItem(const String& name);
		Element* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Element*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::Element*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static HTMLAllCollection* prototype;
		HTMLAllCollection();
	public:
		using client::Object::operator[];
	};
	class HTMLOrSVGElement: public virtual Object {
	public:
		bool get_autofocus();
		void set_autofocus(bool autofocus);
		DOMStringMap* get_dataset();
		String* get_nonce();
		void set_nonce(const String& nonce);
		double get_tabIndex();
		void set_tabIndex(double tabIndex);
		void blur();
		void focus();
		void focus(FocusOptions* options);
	};
	class HTMLElement: public Element, public ElementCSSInlineStyle, public ElementContentEditable, public GlobalEventHandlers, public HTMLOrSVGElement {
	public:
		String* get_accessKey();
		void set_accessKey(const String& accessKey);
		String* get_accessKeyLabel();
		String* get_autocapitalize();
		void set_autocapitalize(const String& autocapitalize);
		String* get_dir();
		void set_dir(const String& dir);
		bool get_draggable();
		void set_draggable(bool draggable);
		bool get_hidden();
		void set_hidden(bool hidden);
		bool get_inert();
		void set_inert(bool inert);
		String* get_innerText();
		void set_innerText(const String& innerText);
		String* get_lang();
		void set_lang(const String& lang);
		double get_offsetHeight();
		double get_offsetLeft();
		Element* get_offsetParent();
		double get_offsetTop();
		double get_offsetWidth();
		String* get_outerText();
		void set_outerText(const String& outerText);
		String* get_popover();
		void set_popover(const String& popover);
		bool get_spellcheck();
		void set_spellcheck(bool spellcheck);
		String* get_title();
		void set_title(const String& title);
		bool get_translate();
		void set_translate(bool translate);
		ElementInternals* attachInternals();
		void click();
		void hidePopover();
		void showPopover();
		void togglePopover();
		void togglePopover(bool force);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLElement* prototype;
		HTMLElement();
	};
	class HTMLHyperlinkElementUtils: public virtual Object {
	public:
		String* get_hash();
		void set_hash(const String& hash);
		String* get_host();
		void set_host(const String& host);
		String* get_hostname();
		void set_hostname(const String& hostname);
		String* get_href();
		void set_href(const String& href);
		String* toString();
		String* get_origin();
		String* get_password();
		void set_password(const String& password);
		String* get_pathname();
		void set_pathname(const String& pathname);
		String* get_port();
		void set_port(const String& port);
		String* get_protocol();
		void set_protocol(const String& protocol);
		String* get_search();
		void set_search(const String& search);
		String* get_username();
		void set_username(const String& username);
	};
	class HTMLAnchorElement: public HTMLElement, public HTMLHyperlinkElementUtils {
	public:
		String* get_charset();
		void set_charset(const String& charset);
		String* get_coords();
		void set_coords(const String& coords);
		String* get_download();
		void set_download(const String& download);
		String* get_hreflang();
		void set_hreflang(const String& hreflang);
		String* get_name();
		void set_name(const String& name);
		String* get_ping();
		void set_ping(const String& ping);
		String* get_referrerPolicy();
		void set_referrerPolicy(const String& referrerPolicy);
		String* get_rel();
		void set_rel(const String& rel);
		DOMTokenList* get_relList();
		String* get_rev();
		void set_rev(const String& rev);
		String* get_shape();
		void set_shape(const String& shape);
		String* get_target();
		void set_target(const String& target);
		String* get_text();
		void set_text(const String& text);
		String* get_type();
		void set_type(const String& type);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLAnchorElement* prototype;
		HTMLAnchorElement();
	};
	class HTMLAreaElement: public HTMLElement, public HTMLHyperlinkElementUtils {
	public:
		String* get_alt();
		void set_alt(const String& alt);
		String* get_coords();
		void set_coords(const String& coords);
		String* get_download();
		void set_download(const String& download);
		bool get_noHref();
		void set_noHref(bool noHref);
		String* get_ping();
		void set_ping(const String& ping);
		String* get_referrerPolicy();
		void set_referrerPolicy(const String& referrerPolicy);
		String* get_rel();
		void set_rel(const String& rel);
		DOMTokenList* get_relList();
		String* get_shape();
		void set_shape(const String& shape);
		String* get_target();
		void set_target(const String& target);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLAreaElement* prototype;
		HTMLAreaElement();
	};
	class TimeRanges;
	class MediaError;
	class MediaKeys;
	class RemotePlayback;
	class MediaSource;
	class TextTrackList;
	class HTMLMediaElement: public HTMLElement {
	public:
		bool get_autoplay();
		void set_autoplay(bool autoplay);
		TimeRanges* get_buffered();
		bool get_controls();
		void set_controls(bool controls);
		String* get_crossOrigin();
		void set_crossOrigin(const String& crossOrigin);
		String* get_currentSrc();
		double get_currentTime();
		void set_currentTime(double currentTime);
		bool get_defaultMuted();
		void set_defaultMuted(bool defaultMuted);
		double get_defaultPlaybackRate();
		void set_defaultPlaybackRate(double defaultPlaybackRate);
		bool get_disableRemotePlayback();
		void set_disableRemotePlayback(bool disableRemotePlayback);
		double get_duration();
		bool get_ended();
		MediaError* get_error();
		bool get_loop();
		void set_loop(bool loop);
		MediaKeys* get_mediaKeys();
		bool get_muted();
		void set_muted(bool muted);
		double get_networkState();
		_Function<_Any*(MediaEncryptedEvent*)>* get_onencrypted();
		void set_onencrypted(EventListener* onencrypted);
		void set_onencrypted(const _Function<_Any*(MediaEncryptedEvent*)>& onencrypted);
		_Function<_Any*(Event*)>* get_onwaitingforkey();
		void set_onwaitingforkey(EventListener* onwaitingforkey);
		void set_onwaitingforkey(const _Function<_Any*(Event*)>& onwaitingforkey);
		bool get_paused();
		double get_playbackRate();
		void set_playbackRate(double playbackRate);
		TimeRanges* get_played();
		String* get_preload();
		void set_preload(const String& preload);
		bool get_preservesPitch();
		void set_preservesPitch(bool preservesPitch);
		double get_readyState();
		RemotePlayback* get_remote();
		TimeRanges* get_seekable();
		bool get_seeking();
		String* get_src();
		void set_src(const String& src);
		_Union<Blob*, MediaSource*, MediaStream*>* get_srcObject();
		void set_srcObject(const _Union<Blob*, MediaSource*, MediaStream*>& srcObject);
		TextTrackList* get_textTracks();
		double get_volume();
		void set_volume(double volume);
		TextTrack* addTextTrack(const String& kind);
		TextTrack* addTextTrack(const String& kind, const String& label);
		TextTrack* addTextTrack(const String& kind, const String& label, const String& language);
		String* canPlayType(const String& type);
		void fastSeek(double time);
		void load();
		void pause();
		Promise<_Any*>* play();
		Promise<_Any*>* setMediaKeys(MediaKeys* mediaKeys);
		double get_NETWORK_EMPTY();
		double get_NETWORK_IDLE();
		double get_NETWORK_LOADING();
		double get_NETWORK_NO_SOURCE();
		double get_HAVE_NOTHING();
		double get_HAVE_METADATA();
		double get_HAVE_CURRENT_DATA();
		double get_HAVE_FUTURE_DATA();
		double get_HAVE_ENOUGH_DATA();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLMediaElement* prototype;
		HTMLMediaElement();
		static double NETWORK_EMPTY;
		static double NETWORK_IDLE;
		static double NETWORK_LOADING;
		static double NETWORK_NO_SOURCE;
		static double HAVE_NOTHING;
		static double HAVE_METADATA;
		static double HAVE_CURRENT_DATA;
		static double HAVE_FUTURE_DATA;
		static double HAVE_ENOUGH_DATA;
	};
	class HTMLAudioElement: public HTMLMediaElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLAudioElement* prototype;
		HTMLAudioElement();
	};
	class HTMLBRElement: public HTMLElement {
	public:
		String* get_clear();
		void set_clear(const String& clear);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLBRElement* prototype;
		HTMLBRElement();
	};
	class HTMLBaseElement: public HTMLElement {
	public:
		String* get_href();
		void set_href(const String& href);
		String* get_target();
		void set_target(const String& target);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLBaseElement* prototype;
		HTMLBaseElement();
	};
	class HTMLElementEventMap: public ElementEventMap, public GlobalEventHandlersEventMap {
	};
	class WindowEventHandlersEventMap: public virtual Object {
	public:
		[[cheerp::interface_name(("get_\"afterprint\""))]]
		Event* get__34_afterprint_34_();
		[[cheerp::interface_name(("set_\"afterprint\""))]]
		void set__34_afterprint_34_(Event* _34_afterprint_34_);
		[[cheerp::interface_name(("get_\"beforeprint\""))]]
		Event* get__34_beforeprint_34_();
		[[cheerp::interface_name(("set_\"beforeprint\""))]]
		void set__34_beforeprint_34_(Event* _34_beforeprint_34_);
		[[cheerp::interface_name(("get_\"beforeunload\""))]]
		BeforeUnloadEvent* get__34_beforeunload_34_();
		[[cheerp::interface_name(("set_\"beforeunload\""))]]
		void set__34_beforeunload_34_(BeforeUnloadEvent* _34_beforeunload_34_);
		[[cheerp::interface_name(("get_\"gamepadconnected\""))]]
		GamepadEvent* get__34_gamepadconnected_34_();
		[[cheerp::interface_name(("set_\"gamepadconnected\""))]]
		void set__34_gamepadconnected_34_(GamepadEvent* _34_gamepadconnected_34_);
		[[cheerp::interface_name(("get_\"gamepaddisconnected\""))]]
		GamepadEvent* get__34_gamepaddisconnected_34_();
		[[cheerp::interface_name(("set_\"gamepaddisconnected\""))]]
		void set__34_gamepaddisconnected_34_(GamepadEvent* _34_gamepaddisconnected_34_);
		[[cheerp::interface_name(("get_\"hashchange\""))]]
		HashChangeEvent* get__34_hashchange_34_();
		[[cheerp::interface_name(("set_\"hashchange\""))]]
		void set__34_hashchange_34_(HashChangeEvent* _34_hashchange_34_);
		[[cheerp::interface_name(("get_\"languagechange\""))]]
		Event* get__34_languagechange_34_();
		[[cheerp::interface_name(("set_\"languagechange\""))]]
		void set__34_languagechange_34_(Event* _34_languagechange_34_);
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"messageerror\""))]]
		MessageEvent<_Any*>* get__34_messageerror_34_();
		[[cheerp::interface_name(("set_\"messageerror\""))]]
		void set__34_messageerror_34_(MessageEvent<_Any*>* _34_messageerror_34_);
		[[cheerp::interface_name(("get_\"offline\""))]]
		Event* get__34_offline_34_();
		[[cheerp::interface_name(("set_\"offline\""))]]
		void set__34_offline_34_(Event* _34_offline_34_);
		[[cheerp::interface_name(("get_\"online\""))]]
		Event* get__34_online_34_();
		[[cheerp::interface_name(("set_\"online\""))]]
		void set__34_online_34_(Event* _34_online_34_);
		[[cheerp::interface_name(("get_\"pagehide\""))]]
		PageTransitionEvent* get__34_pagehide_34_();
		[[cheerp::interface_name(("set_\"pagehide\""))]]
		void set__34_pagehide_34_(PageTransitionEvent* _34_pagehide_34_);
		[[cheerp::interface_name(("get_\"pageshow\""))]]
		PageTransitionEvent* get__34_pageshow_34_();
		[[cheerp::interface_name(("set_\"pageshow\""))]]
		void set__34_pageshow_34_(PageTransitionEvent* _34_pageshow_34_);
		[[cheerp::interface_name(("get_\"popstate\""))]]
		PopStateEvent* get__34_popstate_34_();
		[[cheerp::interface_name(("set_\"popstate\""))]]
		void set__34_popstate_34_(PopStateEvent* _34_popstate_34_);
		[[cheerp::interface_name(("get_\"rejectionhandled\""))]]
		PromiseRejectionEvent* get__34_rejectionhandled_34_();
		[[cheerp::interface_name(("set_\"rejectionhandled\""))]]
		void set__34_rejectionhandled_34_(PromiseRejectionEvent* _34_rejectionhandled_34_);
		[[cheerp::interface_name(("get_\"storage\""))]]
		StorageEvent* get__34_storage_34_();
		[[cheerp::interface_name(("set_\"storage\""))]]
		void set__34_storage_34_(StorageEvent* _34_storage_34_);
		[[cheerp::interface_name(("get_\"unhandledrejection\""))]]
		PromiseRejectionEvent* get__34_unhandledrejection_34_();
		[[cheerp::interface_name(("set_\"unhandledrejection\""))]]
		void set__34_unhandledrejection_34_(PromiseRejectionEvent* _34_unhandledrejection_34_);
		[[cheerp::interface_name(("get_\"unload\""))]]
		Event* get__34_unload_34_();
		[[cheerp::interface_name(("set_\"unload\""))]]
		void set__34_unload_34_(Event* _34_unload_34_);
	};
	class HTMLBodyElementEventMap: public HTMLElementEventMap, public WindowEventHandlersEventMap {
	};
	class WindowEventHandlers: public virtual Object {
	public:
		_Function<_Any*(Event*)>* get_onafterprint();
		void set_onafterprint(EventListener* onafterprint);
		void set_onafterprint(const _Function<_Any*(Event*)>& onafterprint);
		_Function<_Any*(Event*)>* get_onbeforeprint();
		void set_onbeforeprint(EventListener* onbeforeprint);
		void set_onbeforeprint(const _Function<_Any*(Event*)>& onbeforeprint);
		_Function<_Any*(BeforeUnloadEvent*)>* get_onbeforeunload();
		void set_onbeforeunload(EventListener* onbeforeunload);
		void set_onbeforeunload(const _Function<_Any*(BeforeUnloadEvent*)>& onbeforeunload);
		_Function<_Any*(GamepadEvent*)>* get_ongamepadconnected();
		void set_ongamepadconnected(EventListener* ongamepadconnected);
		void set_ongamepadconnected(const _Function<_Any*(GamepadEvent*)>& ongamepadconnected);
		_Function<_Any*(GamepadEvent*)>* get_ongamepaddisconnected();
		void set_ongamepaddisconnected(EventListener* ongamepaddisconnected);
		void set_ongamepaddisconnected(const _Function<_Any*(GamepadEvent*)>& ongamepaddisconnected);
		_Function<_Any*(HashChangeEvent*)>* get_onhashchange();
		void set_onhashchange(EventListener* onhashchange);
		void set_onhashchange(const _Function<_Any*(HashChangeEvent*)>& onhashchange);
		_Function<_Any*(Event*)>* get_onlanguagechange();
		void set_onlanguagechange(EventListener* onlanguagechange);
		void set_onlanguagechange(const _Function<_Any*(Event*)>& onlanguagechange);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessageerror();
		void set_onmessageerror(EventListener* onmessageerror);
		void set_onmessageerror(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessageerror);
		_Function<_Any*(Event*)>* get_onoffline();
		void set_onoffline(EventListener* onoffline);
		void set_onoffline(const _Function<_Any*(Event*)>& onoffline);
		_Function<_Any*(Event*)>* get_ononline();
		void set_ononline(EventListener* ononline);
		void set_ononline(const _Function<_Any*(Event*)>& ononline);
		_Function<_Any*(PageTransitionEvent*)>* get_onpagehide();
		void set_onpagehide(EventListener* onpagehide);
		void set_onpagehide(const _Function<_Any*(PageTransitionEvent*)>& onpagehide);
		_Function<_Any*(PageTransitionEvent*)>* get_onpageshow();
		void set_onpageshow(EventListener* onpageshow);
		void set_onpageshow(const _Function<_Any*(PageTransitionEvent*)>& onpageshow);
		_Function<_Any*(PopStateEvent*)>* get_onpopstate();
		void set_onpopstate(EventListener* onpopstate);
		void set_onpopstate(const _Function<_Any*(PopStateEvent*)>& onpopstate);
		_Function<_Any*(PromiseRejectionEvent*)>* get_onrejectionhandled();
		void set_onrejectionhandled(EventListener* onrejectionhandled);
		void set_onrejectionhandled(const _Function<_Any*(PromiseRejectionEvent*)>& onrejectionhandled);
		_Function<_Any*(StorageEvent*)>* get_onstorage();
		void set_onstorage(EventListener* onstorage);
		void set_onstorage(const _Function<_Any*(StorageEvent*)>& onstorage);
		_Function<_Any*(PromiseRejectionEvent*)>* get_onunhandledrejection();
		void set_onunhandledrejection(EventListener* onunhandledrejection);
		void set_onunhandledrejection(const _Function<_Any*(PromiseRejectionEvent*)>& onunhandledrejection);
		_Function<_Any*(Event*)>* get_onunload();
		void set_onunload(EventListener* onunload);
		void set_onunload(const _Function<_Any*(Event*)>& onunload);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
	};
	class HTMLBodyElement: public HTMLElement, public WindowEventHandlers {
	public:
		String* get_aLink();
		void set_aLink(const String& aLink);
		String* get_background();
		void set_background(const String& background);
		String* get_bgColor();
		void set_bgColor(const String& bgColor);
		String* get_link();
		void set_link(const String& link);
		String* get_text();
		void set_text(const String& text);
		String* get_vLink();
		void set_vLink(const String& vLink);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLBodyElement* prototype;
		HTMLBodyElement();
	};
	class HTMLLabelElement;
	class PopoverInvokerElement: public virtual Object {
	public:
		String* get_popoverTargetAction();
		void set_popoverTargetAction(const String& popoverTargetAction);
		Element* get_popoverTargetElement();
		void set_popoverTargetElement(Element* popoverTargetElement);
	};
	class HTMLButtonElement: public HTMLElement, public PopoverInvokerElement {
	public:
		bool get_disabled();
		void set_disabled(bool disabled);
		HTMLFormElement* get_form();
		String* get_formAction();
		void set_formAction(const String& formAction);
		String* get_formEnctype();
		void set_formEnctype(const String& formEnctype);
		String* get_formMethod();
		void set_formMethod(const String& formMethod);
		bool get_formNoValidate();
		void set_formNoValidate(bool formNoValidate);
		String* get_formTarget();
		void set_formTarget(const String& formTarget);
		NodeListOf<HTMLLabelElement*>* get_labels();
		String* get_name();
		void set_name(const String& name);
		String* get_type();
		void set_type(const String& type);
		String* get_validationMessage();
		ValidityState* get_validity();
		String* get_value();
		void set_value(const String& value);
		bool get_willValidate();
		bool checkValidity();
		bool reportValidity();
		void setCustomValidity(const String& error);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLButtonElement* prototype;
		HTMLButtonElement();
	};
	class ImageBitmapRenderingContext;
	class WebGLRenderingContext;
	class WebGL2RenderingContext;
	class HTMLCanvasElement: public HTMLElement {
	public:
		double get_height();
		void set_height(double height);
		double get_width();
		void set_width(double width);
		MediaStream* captureStream();
		MediaStream* captureStream(double frameRequestRate);
		_Union<CanvasRenderingContext2D*, ImageBitmapRenderingContext*, WebGLRenderingContext*, WebGL2RenderingContext*>* getContext(const String& contextId);
		CanvasRenderingContext2D* getContext(const String& contextId, CanvasRenderingContext2DSettings* options);
		ImageBitmapRenderingContext* getContext(const String& contextId, ImageBitmapRenderingContextSettings* options);
		_Union<WebGLRenderingContext*, WebGL2RenderingContext*>* getContext(const String& contextId, WebGLContextAttributes* options);
		_Union<CanvasRenderingContext2D*, ImageBitmapRenderingContext*, WebGL2RenderingContext*, WebGLRenderingContext*>* getContext(const String& contextId, const _Any& options);
		void toBlob(EventListener* callback);
		void toBlob(const _Function<void(Blob*)>& callback);
		void toBlob(EventListener* callback, const String& type);
		void toBlob(const _Function<void(Blob*)>& callback, const String& type);
		void toBlob(EventListener* callback, const String& type, const _Any& quality);
		void toBlob(const _Function<void(Blob*)>& callback, const String& type, const _Any& quality);
		String* toDataURL();
		String* toDataURL(const String& type);
		String* toDataURL(const String& type, const _Any& quality);
		OffscreenCanvas* transferControlToOffscreen();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLCanvasElement* prototype;
		HTMLCanvasElement();
	};
	class HTMLCollectionBase: public Object {
	public:
		int get_length() const;
		Element* item(double index);
		Element* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Element*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::Element*>(this, 0)[static_cast<int>(index)];
		}
#endif
	public:
		using client::Object::operator[];
	};
	class HTMLCollection: public HTMLCollectionBase {
	public:
		Element* namedItem(const String& name);
		static HTMLCollection* prototype;
		HTMLCollection();
	};
	template<class _T0>
	class HTMLCollectionOf: public HTMLCollectionBase {
		static_assert(cheerp::CanCast<_T0, Element*>);
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_T0 item(double index);
		_T0 namedItem(const String& name);
		_T0 operator[](double index) const;
#ifndef LEAN_CXX_LIB
		_T0& operator[](double index) {
			return __builtin_cheerp_make_regular<_T0>(this, 0)[static_cast<int>(index)];
		}
#endif
	public:
		using client::HTMLCollectionBase::operator[];
		using client::Object::operator[];
	};
	class HTMLDListElement: public HTMLElement {
	public:
		bool get_compact();
		void set_compact(bool compact);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLDListElement* prototype;
		HTMLDListElement();
	};
	class HTMLDataElement: public HTMLElement {
	public:
		String* get_value();
		void set_value(const String& value);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLDataElement* prototype;
		HTMLDataElement();
	};
	class HTMLOptionElement;
	class HTMLDataListElement: public HTMLElement {
	public:
		HTMLCollectionOf<HTMLOptionElement*>* get_options();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLDataListElement* prototype;
		HTMLDataListElement();
	};
	class HTMLDetailsElement: public HTMLElement {
	public:
		bool get_open();
		void set_open(bool open);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLDetailsElement* prototype;
		HTMLDetailsElement();
	};
	class HTMLDialogElement: public HTMLElement {
	public:
		bool get_open();
		void set_open(bool open);
		String* get_returnValue();
		void set_returnValue(const String& returnValue);
		void close();
		void close(const String& returnValue);
		void show();
		void showModal();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLDialogElement* prototype;
		HTMLDialogElement();
	};
	class HTMLDirectoryElement: public HTMLElement {
	public:
		bool get_compact();
		void set_compact(bool compact);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLDirectoryElement* prototype;
		HTMLDirectoryElement();
	};
	class HTMLDivElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLDivElement* prototype;
		HTMLDivElement();
	};
	class HTMLDocument: public Document {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLDocument* prototype;
		HTMLDocument();
	};
	class HTMLEmbedElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_height();
		void set_height(const String& height);
		String* get_name();
		void set_name(const String& name);
		String* get_src();
		void set_src(const String& src);
		String* get_type();
		void set_type(const String& type);
		String* get_width();
		void set_width(const String& width);
		Document* getSVGDocument();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLEmbedElement* prototype;
		HTMLEmbedElement();
	};
	class HTMLFieldSetElement: public HTMLElement {
	public:
		bool get_disabled();
		void set_disabled(bool disabled);
		HTMLCollection* get_elements();
		HTMLFormElement* get_form();
		String* get_name();
		void set_name(const String& name);
		String* get_type();
		String* get_validationMessage();
		ValidityState* get_validity();
		bool get_willValidate();
		bool checkValidity();
		bool reportValidity();
		void setCustomValidity(const String& error);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLFieldSetElement* prototype;
		HTMLFieldSetElement();
	};
	class HTMLFontElement: public HTMLElement {
	public:
		String* get_color();
		void set_color(const String& color);
		String* get_face();
		void set_face(const String& face);
		int get_size() const;
		void set_size(const String& size);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLFontElement* prototype;
		HTMLFontElement();
	};
	class RadioNodeList;
	class HTMLFormControlsCollection: public HTMLCollectionBase {
	public:
		_Union<Element*, RadioNodeList*>* namedItem(const String& name);
		static HTMLFormControlsCollection* prototype;
		HTMLFormControlsCollection();
	};
	class HTMLFormElement: public HTMLElement {
	public:
		String* get_acceptCharset();
		void set_acceptCharset(const String& acceptCharset);
		String* get_action();
		void set_action(const String& action);
		String* get_autocomplete();
		void set_autocomplete(const String& autocomplete);
		HTMLFormControlsCollection* get_elements();
		String* get_encoding();
		void set_encoding(const String& encoding);
		String* get_enctype();
		void set_enctype(const String& enctype);
		int get_length() const;
		String* get_method();
		void set_method(const String& method);
		String* get_name();
		void set_name(const String& name);
		bool get_noValidate();
		void set_noValidate(bool noValidate);
		String* get_rel();
		void set_rel(const String& rel);
		DOMTokenList* get_relList();
		String* get_target();
		void set_target(const String& target);
		bool checkValidity();
		bool reportValidity();
		void requestSubmit();
		void requestSubmit(HTMLElement* submitter);
		void reset();
		void submit();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		Element* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Element*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::Element*>(this, 0)[static_cast<int>(index)];
		}
#endif
		Object* operator[](const String& name) const;
		static HTMLFormElement* prototype;
		HTMLFormElement();
	public:
		using client::Object::operator[];
	};
	class HTMLFrameElement: public HTMLElement {
	public:
		Document* get_contentDocument();
		Window* get_contentWindow();
		String* get_frameBorder();
		void set_frameBorder(const String& frameBorder);
		String* get_longDesc();
		void set_longDesc(const String& longDesc);
		String* get_marginHeight();
		void set_marginHeight(const String& marginHeight);
		String* get_marginWidth();
		void set_marginWidth(const String& marginWidth);
		String* get_name();
		void set_name(const String& name);
		bool get_noResize();
		void set_noResize(bool noResize);
		String* get_scrolling();
		void set_scrolling(const String& scrolling);
		String* get_src();
		void set_src(const String& src);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLFrameElement* prototype;
		HTMLFrameElement();
	};
	class HTMLFrameSetElementEventMap: public HTMLElementEventMap, public WindowEventHandlersEventMap {
	};
	class HTMLFrameSetElement: public HTMLElement, public WindowEventHandlers {
	public:
		String* get_cols();
		void set_cols(const String& cols);
		String* get_rows();
		void set_rows(const String& rows);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLFrameSetElement* prototype;
		HTMLFrameSetElement();
	};
	class HTMLHRElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_color();
		void set_color(const String& color);
		bool get_noShade();
		void set_noShade(bool noShade);
		int get_size() const;
		void set_size(const String& size);
		String* get_width();
		void set_width(const String& width);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLHRElement* prototype;
		HTMLHRElement();
	};
	class HTMLHeadElement: public HTMLElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLHeadElement* prototype;
		HTMLHeadElement();
	};
	class HTMLHeadingElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLHeadingElement* prototype;
		HTMLHeadingElement();
	};
	class HTMLHtmlElement: public HTMLElement {
	public:
		String* get_version();
		void set_version(const String& version);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLHtmlElement* prototype;
		HTMLHtmlElement();
	};
	class HTMLIFrameElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_allow();
		void set_allow(const String& allow);
		bool get_allowFullscreen();
		void set_allowFullscreen(bool allowFullscreen);
		Document* get_contentDocument();
		Window* get_contentWindow();
		String* get_frameBorder();
		void set_frameBorder(const String& frameBorder);
		String* get_height();
		void set_height(const String& height);
		String* get_loading();
		void set_loading(const String& loading);
		String* get_longDesc();
		void set_longDesc(const String& longDesc);
		String* get_marginHeight();
		void set_marginHeight(const String& marginHeight);
		String* get_marginWidth();
		void set_marginWidth(const String& marginWidth);
		String* get_name();
		void set_name(const String& name);
		String* get_referrerPolicy();
		void set_referrerPolicy(const String& referrerPolicy);
		DOMTokenList* get_sandbox();
		String* get_scrolling();
		void set_scrolling(const String& scrolling);
		String* get_src();
		void set_src(const String& src);
		String* get_srcdoc();
		void set_srcdoc(const String& srcdoc);
		String* get_width();
		void set_width(const String& width);
		Document* getSVGDocument();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLIFrameElement* prototype;
		HTMLIFrameElement();
	};
	class HTMLImageElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_alt();
		void set_alt(const String& alt);
		String* get_border();
		void set_border(const String& border);
		bool get_complete();
		String* get_crossOrigin();
		void set_crossOrigin(const String& crossOrigin);
		String* get_currentSrc();
		String* get_decoding();
		void set_decoding(const String& decoding);
		double get_height();
		void set_height(double height);
		double get_hspace();
		void set_hspace(double hspace);
		bool get_isMap();
		void set_isMap(bool isMap);
		String* get_loading();
		void set_loading(const String& loading);
		String* get_longDesc();
		void set_longDesc(const String& longDesc);
		String* get_lowsrc();
		void set_lowsrc(const String& lowsrc);
		String* get_name();
		void set_name(const String& name);
		double get_naturalHeight();
		double get_naturalWidth();
		String* get_referrerPolicy();
		void set_referrerPolicy(const String& referrerPolicy);
		String* get_sizes();
		void set_sizes(const String& sizes);
		String* get_src();
		void set_src(const String& src);
		String* get_srcset();
		void set_srcset(const String& srcset);
		String* get_useMap();
		void set_useMap(const String& useMap);
		double get_vspace();
		void set_vspace(double vspace);
		double get_width();
		void set_width(double width);
		double get_x();
		double get_y();
		Promise<_Any*>* decode();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLImageElement* prototype;
		HTMLImageElement();
	};
	class HTMLInputElement: public HTMLElement, public PopoverInvokerElement {
	public:
		String* get_accept();
		void set_accept(const String& accept);
		String* get_align();
		void set_align(const String& align);
		String* get_alt();
		void set_alt(const String& alt);
		String* get_autocomplete();
		void set_autocomplete(const String& autocomplete);
		String* get_capture();
		void set_capture(const String& capture);
		bool get_checked();
		void set_checked(bool checked);
		bool get_defaultChecked();
		void set_defaultChecked(bool defaultChecked);
		String* get_defaultValue();
		void set_defaultValue(const String& defaultValue);
		String* get_dirName();
		void set_dirName(const String& dirName);
		bool get_disabled();
		void set_disabled(bool disabled);
		FileList* get_files();
		void set_files(FileList* files);
		HTMLFormElement* get_form();
		String* get_formAction();
		void set_formAction(const String& formAction);
		String* get_formEnctype();
		void set_formEnctype(const String& formEnctype);
		String* get_formMethod();
		void set_formMethod(const String& formMethod);
		bool get_formNoValidate();
		void set_formNoValidate(bool formNoValidate);
		String* get_formTarget();
		void set_formTarget(const String& formTarget);
		double get_height();
		void set_height(double height);
		bool get_indeterminate();
		void set_indeterminate(bool indeterminate);
		NodeListOf<HTMLLabelElement*>* get_labels();
		HTMLDataListElement* get_list();
		String* get_max();
		void set_max(const String& max);
		double get_maxLength();
		void set_maxLength(double maxLength);
		String* get_min();
		void set_min(const String& min);
		double get_minLength();
		void set_minLength(double minLength);
		bool get_multiple();
		void set_multiple(bool multiple);
		String* get_name();
		void set_name(const String& name);
		String* get_pattern();
		void set_pattern(const String& pattern);
		String* get_placeholder();
		void set_placeholder(const String& placeholder);
		bool get_readOnly();
		void set_readOnly(bool readOnly);
		bool get_required();
		void set_required(bool required);
		String* get_selectionDirection();
		void set_selectionDirection(const String& selectionDirection);
		double get_selectionEnd();
		void set_selectionEnd(double selectionEnd);
		double get_selectionStart();
		void set_selectionStart(double selectionStart);
		int get_size() const;
		void set_size(double size);
		String* get_src();
		void set_src(const String& src);
		String* get_step();
		void set_step(const String& step);
		String* get_type();
		void set_type(const String& type);
		String* get_useMap();
		void set_useMap(const String& useMap);
		String* get_validationMessage();
		ValidityState* get_validity();
		String* get_value();
		void set_value(const String& value);
		Date* get_valueAsDate();
		void set_valueAsDate(Date* valueAsDate);
		double get_valueAsNumber();
		void set_valueAsNumber(double valueAsNumber);
		ReadonlyArray<FileSystemEntry*>* get_webkitEntries();
		bool get_webkitdirectory();
		void set_webkitdirectory(bool webkitdirectory);
		double get_width();
		void set_width(double width);
		bool get_willValidate();
		bool checkValidity();
		bool reportValidity();
		void select();
		void setCustomValidity(const String& error);
		void setRangeText(const String& replacement);
		void setRangeText(const String& replacement, double start, double end);
		void setRangeText(const String& replacement, double start, double end, const String& selectionMode);
		void setSelectionRange(double start, double end);
		void setSelectionRange(double start, double end, const String& direction);
		void showPicker();
		void stepDown();
		void stepDown(double n);
		void stepUp();
		void stepUp(double n);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLInputElement* prototype;
		HTMLInputElement();
	};
	class HTMLLIElement: public HTMLElement {
	public:
		String* get_type();
		void set_type(const String& type);
		double get_value();
		void set_value(double value);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLLIElement* prototype;
		HTMLLIElement();
	};
	class HTMLLabelElement: public HTMLElement {
	public:
		HTMLElement* get_control();
		HTMLFormElement* get_form();
		String* get_htmlFor();
		void set_htmlFor(const String& htmlFor);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLLabelElement* prototype;
		HTMLLabelElement();
	};
	class HTMLLegendElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		HTMLFormElement* get_form();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLLegendElement* prototype;
		HTMLLegendElement();
	};
	class LinkStyle: public virtual Object {
	public:
		CSSStyleSheet* get_sheet();
	};
	class HTMLLinkElement: public HTMLElement, public LinkStyle {
	public:
		String* get_as();
		void set_as(const String& as);
		String* get_charset();
		void set_charset(const String& charset);
		String* get_crossOrigin();
		void set_crossOrigin(const String& crossOrigin);
		bool get_disabled();
		void set_disabled(bool disabled);
		String* get_href();
		void set_href(const String& href);
		String* get_hreflang();
		void set_hreflang(const String& hreflang);
		String* get_imageSizes();
		void set_imageSizes(const String& imageSizes);
		String* get_imageSrcset();
		void set_imageSrcset(const String& imageSrcset);
		String* get_integrity();
		void set_integrity(const String& integrity);
		String* get_media();
		void set_media(const String& media);
		String* get_referrerPolicy();
		void set_referrerPolicy(const String& referrerPolicy);
		String* get_rel();
		void set_rel(const String& rel);
		DOMTokenList* get_relList();
		String* get_rev();
		void set_rev(const String& rev);
		DOMTokenList* get_sizes();
		String* get_target();
		void set_target(const String& target);
		String* get_type();
		void set_type(const String& type);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLLinkElement* prototype;
		HTMLLinkElement();
	};
	class HTMLMapElement: public HTMLElement {
	public:
		HTMLCollection* get_areas();
		String* get_name();
		void set_name(const String& name);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLMapElement* prototype;
		HTMLMapElement();
	};
	class HTMLMarqueeElement: public HTMLElement {
	public:
		String* get_behavior();
		void set_behavior(const String& behavior);
		String* get_bgColor();
		void set_bgColor(const String& bgColor);
		String* get_direction();
		void set_direction(const String& direction);
		String* get_height();
		void set_height(const String& height);
		double get_hspace();
		void set_hspace(double hspace);
		double get_loop();
		void set_loop(double loop);
		double get_scrollAmount();
		void set_scrollAmount(double scrollAmount);
		double get_scrollDelay();
		void set_scrollDelay(double scrollDelay);
		bool get_trueSpeed();
		void set_trueSpeed(bool trueSpeed);
		double get_vspace();
		void set_vspace(double vspace);
		String* get_width();
		void set_width(const String& width);
		void start();
		void stop();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLMarqueeElement* prototype;
		HTMLMarqueeElement();
	};
	class HTMLMediaElementEventMap: public HTMLElementEventMap {
	public:
		[[cheerp::interface_name(("get_\"encrypted\""))]]
		MediaEncryptedEvent* get__34_encrypted_34_();
		[[cheerp::interface_name(("set_\"encrypted\""))]]
		void set__34_encrypted_34_(MediaEncryptedEvent* _34_encrypted_34_);
		[[cheerp::interface_name(("get_\"waitingforkey\""))]]
		Event* get__34_waitingforkey_34_();
		[[cheerp::interface_name(("set_\"waitingforkey\""))]]
		void set__34_waitingforkey_34_(Event* _34_waitingforkey_34_);
	};
	class HTMLMenuElement: public HTMLElement {
	public:
		bool get_compact();
		void set_compact(bool compact);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLMenuElement* prototype;
		HTMLMenuElement();
	};
	class HTMLMetaElement: public HTMLElement {
	public:
		String* get_content();
		void set_content(const String& content);
		String* get_httpEquiv();
		void set_httpEquiv(const String& httpEquiv);
		String* get_media();
		void set_media(const String& media);
		String* get_name();
		void set_name(const String& name);
		String* get_scheme();
		void set_scheme(const String& scheme);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLMetaElement* prototype;
		HTMLMetaElement();
	};
	class HTMLMeterElement: public HTMLElement {
	public:
		double get_high();
		void set_high(double high);
		NodeListOf<HTMLLabelElement*>* get_labels();
		double get_low();
		void set_low(double low);
		double get_max();
		void set_max(double max);
		double get_min();
		void set_min(double min);
		double get_optimum();
		void set_optimum(double optimum);
		double get_value();
		void set_value(double value);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLMeterElement* prototype;
		HTMLMeterElement();
	};
	class HTMLModElement: public HTMLElement {
	public:
		String* get_cite();
		void set_cite(const String& cite);
		String* get_dateTime();
		void set_dateTime(const String& dateTime);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLModElement* prototype;
		HTMLModElement();
	};
	class HTMLOListElement: public HTMLElement {
	public:
		bool get_compact();
		void set_compact(bool compact);
		bool get_reversed();
		void set_reversed(bool reversed);
		double get_start();
		void set_start(double start);
		String* get_type();
		void set_type(const String& type);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLOListElement* prototype;
		HTMLOListElement();
	};
	class HTMLObjectElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_archive();
		void set_archive(const String& archive);
		String* get_border();
		void set_border(const String& border);
		String* get_code();
		void set_code(const String& code);
		String* get_codeBase();
		void set_codeBase(const String& codeBase);
		String* get_codeType();
		void set_codeType(const String& codeType);
		Document* get_contentDocument();
		Window* get_contentWindow();
		String* get_data();
		void set_data(const String& data);
		bool get_declare();
		void set_declare(bool declare);
		HTMLFormElement* get_form();
		String* get_height();
		void set_height(const String& height);
		double get_hspace();
		void set_hspace(double hspace);
		String* get_name();
		void set_name(const String& name);
		String* get_standby();
		void set_standby(const String& standby);
		String* get_type();
		void set_type(const String& type);
		String* get_useMap();
		void set_useMap(const String& useMap);
		String* get_validationMessage();
		ValidityState* get_validity();
		double get_vspace();
		void set_vspace(double vspace);
		String* get_width();
		void set_width(const String& width);
		bool get_willValidate();
		bool checkValidity();
		Document* getSVGDocument();
		bool reportValidity();
		void setCustomValidity(const String& error);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLObjectElement* prototype;
		HTMLObjectElement();
	};
	class HTMLOptGroupElement: public HTMLElement {
	public:
		bool get_disabled();
		void set_disabled(bool disabled);
		String* get_label();
		void set_label(const String& label);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLOptGroupElement* prototype;
		HTMLOptGroupElement();
	};
	class HTMLOptionElement: public HTMLElement {
	public:
		bool get_defaultSelected();
		void set_defaultSelected(bool defaultSelected);
		bool get_disabled();
		void set_disabled(bool disabled);
		HTMLFormElement* get_form();
		double get_index();
		String* get_label();
		void set_label(const String& label);
		bool get_selected();
		void set_selected(bool selected);
		String* get_text();
		void set_text(const String& text);
		String* get_value();
		void set_value(const String& value);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLOptionElement* prototype;
		HTMLOptionElement();
	};
	class HTMLOptionsCollection: public HTMLCollectionOf<HTMLOptionElement*> {
	public:
		int get_length() const;
		void set_length(double length);
		double get_selectedIndex();
		void set_selectedIndex(double selectedIndex);
		void add(const _Union<HTMLOptGroupElement*, HTMLOptionElement*>& element);
		void add(const _Union<HTMLOptGroupElement*, HTMLOptionElement*>& element, const _Union<double, HTMLElement*>& before);
		void remove(double index);
		static HTMLOptionsCollection* prototype;
		HTMLOptionsCollection();
	};
	class HTMLOutputElement: public HTMLElement {
	public:
		String* get_defaultValue();
		void set_defaultValue(const String& defaultValue);
		HTMLFormElement* get_form();
		DOMTokenList* get_htmlFor();
		NodeListOf<HTMLLabelElement*>* get_labels();
		String* get_name();
		void set_name(const String& name);
		String* get_type();
		String* get_validationMessage();
		ValidityState* get_validity();
		String* get_value();
		void set_value(const String& value);
		bool get_willValidate();
		bool checkValidity();
		bool reportValidity();
		void setCustomValidity(const String& error);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLOutputElement* prototype;
		HTMLOutputElement();
	};
	class HTMLParagraphElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLParagraphElement* prototype;
		HTMLParagraphElement();
	};
	class HTMLParamElement: public HTMLElement {
	public:
		String* get_name();
		void set_name(const String& name);
		String* get_type();
		void set_type(const String& type);
		String* get_value();
		void set_value(const String& value);
		String* get_valueType();
		void set_valueType(const String& valueType);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLParamElement* prototype;
		HTMLParamElement();
	};
	class HTMLPictureElement: public HTMLElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLPictureElement* prototype;
		HTMLPictureElement();
	};
	class HTMLPreElement: public HTMLElement {
	public:
		double get_width();
		void set_width(double width);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLPreElement* prototype;
		HTMLPreElement();
	};
	class HTMLProgressElement: public HTMLElement {
	public:
		NodeListOf<HTMLLabelElement*>* get_labels();
		double get_max();
		void set_max(double max);
		double get_position();
		double get_value();
		void set_value(double value);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLProgressElement* prototype;
		HTMLProgressElement();
	};
	class HTMLQuoteElement: public HTMLElement {
	public:
		String* get_cite();
		void set_cite(const String& cite);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLQuoteElement* prototype;
		HTMLQuoteElement();
	};
	class HTMLScriptElement: public HTMLElement {
	public:
		bool get_async();
		void set_async(bool async);
		String* get_charset();
		void set_charset(const String& charset);
		String* get_crossOrigin();
		void set_crossOrigin(const String& crossOrigin);
		bool get_defer();
		void set_defer(bool defer);
		String* get_event();
		void set_event(const String& event);
		String* get_htmlFor();
		void set_htmlFor(const String& htmlFor);
		String* get_integrity();
		void set_integrity(const String& integrity);
		bool get_noModule();
		void set_noModule(bool noModule);
		String* get_referrerPolicy();
		void set_referrerPolicy(const String& referrerPolicy);
		String* get_src();
		void set_src(const String& src);
		String* get_text();
		void set_text(const String& text);
		String* get_type();
		void set_type(const String& type);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLScriptElement* prototype;
		HTMLScriptElement();
		static bool supports(const String& type);
	};
	class HTMLSelectElement: public HTMLElement {
	public:
		String* get_autocomplete();
		void set_autocomplete(const String& autocomplete);
		bool get_disabled();
		void set_disabled(bool disabled);
		HTMLFormElement* get_form();
		NodeListOf<HTMLLabelElement*>* get_labels();
		int get_length() const;
		void set_length(double length);
		bool get_multiple();
		void set_multiple(bool multiple);
		String* get_name();
		void set_name(const String& name);
		HTMLOptionsCollection* get_options();
		bool get_required();
		void set_required(bool required);
		double get_selectedIndex();
		void set_selectedIndex(double selectedIndex);
		HTMLCollectionOf<HTMLOptionElement*>* get_selectedOptions();
		int get_size() const;
		void set_size(double size);
		String* get_type();
		String* get_validationMessage();
		ValidityState* get_validity();
		String* get_value();
		void set_value(const String& value);
		bool get_willValidate();
		void add(const _Union<HTMLOptGroupElement*, HTMLOptionElement*>& element);
		void add(const _Union<HTMLOptGroupElement*, HTMLOptionElement*>& element, const _Union<double, HTMLElement*>& before);
		bool checkValidity();
		HTMLOptionElement* item(double index);
		HTMLOptionElement* namedItem(const String& name);
		void remove();
		void remove(double index);
		bool reportValidity();
		void setCustomValidity(const String& error);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		_Union<HTMLOptGroupElement*, HTMLOptionElement*>* operator[](double name) const;
#ifndef LEAN_CXX_LIB
		_Union<HTMLOptGroupElement*, HTMLOptionElement*>*& operator[](double name) {
			return __builtin_cheerp_make_regular<_Union<client::HTMLOptGroupElement*, client::HTMLOptionElement*>*>(this, 0)[static_cast<int>(name)];
		}
#endif
		static HTMLSelectElement* prototype;
		HTMLSelectElement();
	public:
		using client::Object::operator[];
	};
	class HTMLSlotElement: public HTMLElement {
	public:
		String* get_name();
		void set_name(const String& name);
		template<class... _Args>
		[[gnu::always_inline]]
		void assign(_Args... nodes) {
			_assign(cheerp::clientCast(nodes)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("assign"))]]
		_Any* _assign(_Args... data);
	public:
		TArray<Element*>* assignedElements();
		TArray<Element*>* assignedElements(AssignedNodesOptions* options);
		TArray<Node*>* assignedNodes();
		TArray<Node*>* assignedNodes(AssignedNodesOptions* options);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLSlotElement* prototype;
		HTMLSlotElement();
	};
	class HTMLSourceElement: public HTMLElement {
	public:
		double get_height();
		void set_height(double height);
		String* get_media();
		void set_media(const String& media);
		String* get_sizes();
		void set_sizes(const String& sizes);
		String* get_src();
		void set_src(const String& src);
		String* get_srcset();
		void set_srcset(const String& srcset);
		String* get_type();
		void set_type(const String& type);
		double get_width();
		void set_width(double width);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLSourceElement* prototype;
		HTMLSourceElement();
	};
	class HTMLSpanElement: public HTMLElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLSpanElement* prototype;
		HTMLSpanElement();
	};
	class HTMLStyleElement: public HTMLElement, public LinkStyle {
	public:
		bool get_disabled();
		void set_disabled(bool disabled);
		String* get_media();
		void set_media(const String& media);
		String* get_type();
		void set_type(const String& type);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLStyleElement* prototype;
		HTMLStyleElement();
	};
	class HTMLTableCaptionElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTableCaptionElement* prototype;
		HTMLTableCaptionElement();
	};
	class HTMLTableCellElement: public HTMLElement {
	public:
		String* get_abbr();
		void set_abbr(const String& abbr);
		String* get_align();
		void set_align(const String& align);
		String* get_axis();
		void set_axis(const String& axis);
		String* get_bgColor();
		void set_bgColor(const String& bgColor);
		double get_cellIndex();
		String* get_ch();
		void set_ch(const String& ch);
		String* get_chOff();
		void set_chOff(const String& chOff);
		double get_colSpan();
		void set_colSpan(double colSpan);
		String* get_headers();
		void set_headers(const String& headers);
		String* get_height();
		void set_height(const String& height);
		bool get_noWrap();
		void set_noWrap(bool noWrap);
		double get_rowSpan();
		void set_rowSpan(double rowSpan);
		String* get_scope();
		void set_scope(const String& scope);
		String* get_vAlign();
		void set_vAlign(const String& vAlign);
		String* get_width();
		void set_width(const String& width);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTableCellElement* prototype;
		HTMLTableCellElement();
	};
	class HTMLTableColElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_ch();
		void set_ch(const String& ch);
		String* get_chOff();
		void set_chOff(const String& chOff);
		double get_span();
		void set_span(double span);
		String* get_vAlign();
		void set_vAlign(const String& vAlign);
		String* get_width();
		void set_width(const String& width);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTableColElement* prototype;
		HTMLTableColElement();
	};
	class HTMLTableDataCellElement: public HTMLTableCellElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
	};
	class HTMLTableRowElement;
	class HTMLTableSectionElement;
	class HTMLTableElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_bgColor();
		void set_bgColor(const String& bgColor);
		String* get_border();
		void set_border(const String& border);
		HTMLTableCaptionElement* get_caption();
		void set_caption(HTMLTableCaptionElement* caption);
		String* get_cellPadding();
		void set_cellPadding(const String& cellPadding);
		String* get_cellSpacing();
		void set_cellSpacing(const String& cellSpacing);
		String* get_frame();
		void set_frame(const String& frame);
		HTMLCollectionOf<HTMLTableRowElement*>* get_rows();
		String* get_rules();
		void set_rules(const String& rules);
		String* get_summary();
		void set_summary(const String& summary);
		HTMLCollectionOf<HTMLTableSectionElement*>* get_tBodies();
		HTMLTableSectionElement* get_tFoot();
		void set_tFoot(HTMLTableSectionElement* tFoot);
		HTMLTableSectionElement* get_tHead();
		void set_tHead(HTMLTableSectionElement* tHead);
		String* get_width();
		void set_width(const String& width);
		HTMLTableCaptionElement* createCaption();
		HTMLTableSectionElement* createTBody();
		HTMLTableSectionElement* createTFoot();
		HTMLTableSectionElement* createTHead();
		void deleteCaption();
		void deleteRow(double index);
		void deleteTFoot();
		void deleteTHead();
		HTMLTableRowElement* insertRow();
		HTMLTableRowElement* insertRow(double index);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTableElement* prototype;
		HTMLTableElement();
	};
	class HTMLTableHeaderCellElement: public HTMLTableCellElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
	};
	class HTMLTableRowElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_bgColor();
		void set_bgColor(const String& bgColor);
		HTMLCollectionOf<HTMLTableCellElement*>* get_cells();
		String* get_ch();
		void set_ch(const String& ch);
		String* get_chOff();
		void set_chOff(const String& chOff);
		double get_rowIndex();
		double get_sectionRowIndex();
		String* get_vAlign();
		void set_vAlign(const String& vAlign);
		void deleteCell(double index);
		HTMLTableCellElement* insertCell();
		HTMLTableCellElement* insertCell(double index);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTableRowElement* prototype;
		HTMLTableRowElement();
	};
	class HTMLTableSectionElement: public HTMLElement {
	public:
		String* get_align();
		void set_align(const String& align);
		String* get_ch();
		void set_ch(const String& ch);
		String* get_chOff();
		void set_chOff(const String& chOff);
		HTMLCollectionOf<HTMLTableRowElement*>* get_rows();
		String* get_vAlign();
		void set_vAlign(const String& vAlign);
		void deleteRow(double index);
		HTMLTableRowElement* insertRow();
		HTMLTableRowElement* insertRow(double index);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTableSectionElement* prototype;
		HTMLTableSectionElement();
	};
	class HTMLTemplateElement: public HTMLElement {
	public:
		DocumentFragment* get_content();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTemplateElement* prototype;
		HTMLTemplateElement();
	};
	class HTMLTextAreaElement: public HTMLElement {
	public:
		String* get_autocomplete();
		void set_autocomplete(const String& autocomplete);
		double get_cols();
		void set_cols(double cols);
		String* get_defaultValue();
		void set_defaultValue(const String& defaultValue);
		String* get_dirName();
		void set_dirName(const String& dirName);
		bool get_disabled();
		void set_disabled(bool disabled);
		HTMLFormElement* get_form();
		NodeListOf<HTMLLabelElement*>* get_labels();
		double get_maxLength();
		void set_maxLength(double maxLength);
		double get_minLength();
		void set_minLength(double minLength);
		String* get_name();
		void set_name(const String& name);
		String* get_placeholder();
		void set_placeholder(const String& placeholder);
		bool get_readOnly();
		void set_readOnly(bool readOnly);
		bool get_required();
		void set_required(bool required);
		double get_rows();
		void set_rows(double rows);
		String* get_selectionDirection();
		void set_selectionDirection(const String& selectionDirection);
		double get_selectionEnd();
		void set_selectionEnd(double selectionEnd);
		double get_selectionStart();
		void set_selectionStart(double selectionStart);
		double get_textLength();
		String* get_type();
		String* get_validationMessage();
		ValidityState* get_validity();
		String* get_value();
		void set_value(const String& value);
		bool get_willValidate();
		String* get_wrap();
		void set_wrap(const String& wrap);
		bool checkValidity();
		bool reportValidity();
		void select();
		void setCustomValidity(const String& error);
		void setRangeText(const String& replacement);
		void setRangeText(const String& replacement, double start, double end);
		void setRangeText(const String& replacement, double start, double end, const String& selectionMode);
		void setSelectionRange(double start, double end);
		void setSelectionRange(double start, double end, const String& direction);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTextAreaElement* prototype;
		HTMLTextAreaElement();
	};
	class HTMLTimeElement: public HTMLElement {
	public:
		String* get_dateTime();
		void set_dateTime(const String& dateTime);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTimeElement* prototype;
		HTMLTimeElement();
	};
	class HTMLTitleElement: public HTMLElement {
	public:
		String* get_text();
		void set_text(const String& text);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTitleElement* prototype;
		HTMLTitleElement();
	};
	class HTMLTrackElement: public HTMLElement {
	public:
		[[cheerp::interface_name(("get_default"))]]
		bool get_default_();
		[[cheerp::interface_name(("set_default"))]]
		void set_default_(bool default_);
		String* get_kind();
		void set_kind(const String& kind);
		String* get_label();
		void set_label(const String& label);
		double get_readyState();
		String* get_src();
		void set_src(const String& src);
		String* get_srclang();
		void set_srclang(const String& srclang);
		TextTrack* get_track();
		double get_NONE();
		double get_LOADING();
		double get_LOADED();
		double get_ERROR();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLTrackElement* prototype;
		HTMLTrackElement();
		static double NONE;
		static double LOADING;
		static double LOADED;
		static double ERROR;
	};
	class HTMLUListElement: public HTMLElement {
	public:
		bool get_compact();
		void set_compact(bool compact);
		String* get_type();
		void set_type(const String& type);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLUListElement* prototype;
		HTMLUListElement();
	};
	class HTMLUnknownElement: public HTMLElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLUnknownElement* prototype;
		HTMLUnknownElement();
	};
	class HTMLVideoElementEventMap: public HTMLMediaElementEventMap {
	public:
		[[cheerp::interface_name(("get_\"enterpictureinpicture\""))]]
		Event* get__34_enterpictureinpicture_34_();
		[[cheerp::interface_name(("set_\"enterpictureinpicture\""))]]
		void set__34_enterpictureinpicture_34_(Event* _34_enterpictureinpicture_34_);
		[[cheerp::interface_name(("get_\"leavepictureinpicture\""))]]
		Event* get__34_leavepictureinpicture_34_();
		[[cheerp::interface_name(("set_\"leavepictureinpicture\""))]]
		void set__34_leavepictureinpicture_34_(Event* _34_leavepictureinpicture_34_);
	};
	class VideoPlaybackQuality;
	class HTMLVideoElement: public HTMLMediaElement {
	public:
		bool get_disablePictureInPicture();
		void set_disablePictureInPicture(bool disablePictureInPicture);
		double get_height();
		void set_height(double height);
		_Function<_Any*(Event*)>* get_onenterpictureinpicture();
		void set_onenterpictureinpicture(EventListener* onenterpictureinpicture);
		void set_onenterpictureinpicture(const _Function<_Any*(Event*)>& onenterpictureinpicture);
		_Function<_Any*(Event*)>* get_onleavepictureinpicture();
		void set_onleavepictureinpicture(EventListener* onleavepictureinpicture);
		void set_onleavepictureinpicture(const _Function<_Any*(Event*)>& onleavepictureinpicture);
		bool get_playsInline();
		void set_playsInline(bool playsInline);
		String* get_poster();
		void set_poster(const String& poster);
		double get_videoHeight();
		double get_videoWidth();
		double get_width();
		void set_width(double width);
		void cancelVideoFrameCallback(double handle);
		VideoPlaybackQuality* getVideoPlaybackQuality();
		Promise<PictureInPictureWindow*>* requestPictureInPicture();
		double requestVideoFrameCallback(EventListener* callback);
		double requestVideoFrameCallback(const _Function<void(double, VideoFrameCallbackMetadata*)>& callback);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static HTMLVideoElement* prototype;
		HTMLVideoElement();
	};
	class HashChangeEvent: public Event {
	public:
		String* get_newURL();
		String* get_oldURL();
		static HashChangeEvent* prototype;
		HashChangeEvent(const String& type);
		HashChangeEvent(const String& type, HashChangeEventInit* eventInitDict);
	};
	class Headers: public Object {
	public:
		void append(const String& name, const String& value);
		[[cheerp::interface_name(("delete"))]]
		void delete_(const String& name);
		String* get(const String& name);
		TArray<String*>* getSetCookie();
		bool has(const String& name);
		void set(const String& name, const String& value);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(String*, String*, Headers*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(String*, String*, Headers*)>& callbackfn, const _Any& thisArg);
		static Headers* prototype;
		Headers();
		Headers(const _Union<Headers*, Object*, TArray<Object*>*>& init);
	};
	class History: public Object {
	public:
		int get_length() const;
		String* get_scrollRestoration();
		void set_scrollRestoration(const String& scrollRestoration);
		Object* get_state();
		void back();
		void forward();
		void go();
		void go(double delta);
		void pushState(const _Any& data, const String& unused);
		void pushState(const _Any& data, const String& unused, const String& url);
		void pushState(const _Any& data, const String& unused, URL* url);
		void replaceState(const _Any& data, const String& unused);
		void replaceState(const _Any& data, const String& unused, const String& url);
		void replaceState(const _Any& data, const String& unused, URL* url);
		static History* prototype;
		History();
	};
	template<class _T0>
	class IDBRequest;
	class IDBIndex;
	class IDBObjectStore;
	class IDBCursor: public Object {
	public:
		String* get_direction();
		_Union<String*, double, Date*, ArrayBuffer*, ArrayBufferView*, TArray<_Any*>*>* get_key();
		_Union<String*, double, Date*, ArrayBuffer*, ArrayBufferView*, TArray<_Any*>*>* get_primaryKey();
		IDBRequest<_Any*>* get_request();
		_Union<IDBIndex*, IDBObjectStore*>* get_source();
		void advance(double count);
		[[cheerp::interface_name(("continue"))]]
		void continue_();
		[[cheerp::interface_name(("continue"))]]
		void continue_(const String& key);
		[[cheerp::interface_name(("continue"))]]
		void continue_(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, Array*>& key);
		void continuePrimaryKey(const String& key, const String& primaryKey);
		void continuePrimaryKey(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, Array*>& key, const String& primaryKey);
		void continuePrimaryKey(const String& key, const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, Array*>& primaryKey);
		void continuePrimaryKey(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, Array*>& key, const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, Array*>& primaryKey);
		[[cheerp::interface_name(("delete"))]]
		IDBRequest<_Any*>* delete_();
		IDBRequest<_Any*>* update(const _Any& value);
		static IDBCursor* prototype;
		IDBCursor();
	};
	class IDBCursorWithValue: public IDBCursor {
	public:
		Object* get_value();
		static IDBCursorWithValue* prototype;
		IDBCursorWithValue();
	};
	class IDBDatabaseEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"abort\""))]]
		Event* get__34_abort_34_();
		[[cheerp::interface_name(("set_\"abort\""))]]
		void set__34_abort_34_(Event* _34_abort_34_);
		[[cheerp::interface_name(("get_\"close\""))]]
		Event* get__34_close_34_();
		[[cheerp::interface_name(("set_\"close\""))]]
		void set__34_close_34_(Event* _34_close_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"versionchange\""))]]
		IDBVersionChangeEvent* get__34_versionchange_34_();
		[[cheerp::interface_name(("set_\"versionchange\""))]]
		void set__34_versionchange_34_(IDBVersionChangeEvent* _34_versionchange_34_);
	};
	class IDBTransaction;
	class IDBDatabase: public EventTarget {
	public:
		String* get_name();
		DOMStringList* get_objectStoreNames();
		_Function<_Any*(Event*)>* get_onabort();
		void set_onabort(EventListener* onabort);
		void set_onabort(const _Function<_Any*(Event*)>& onabort);
		_Function<_Any*(Event*)>* get_onclose();
		void set_onclose(EventListener* onclose);
		void set_onclose(const _Function<_Any*(Event*)>& onclose);
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(IDBVersionChangeEvent*)>* get_onversionchange();
		void set_onversionchange(EventListener* onversionchange);
		void set_onversionchange(const _Function<_Any*(IDBVersionChangeEvent*)>& onversionchange);
		double get_version();
		void close();
		IDBObjectStore* createObjectStore(const String& name);
		IDBObjectStore* createObjectStore(const String& name, IDBObjectStoreParameters* options);
		void deleteObjectStore(const String& name);
		IDBTransaction* transaction(const String& storeNames);
		IDBTransaction* transaction(TArray<String*>* storeNames);
		IDBTransaction* transaction(const String& storeNames, const String& mode);
		IDBTransaction* transaction(TArray<String*>* storeNames, const String& mode);
		IDBTransaction* transaction(const String& storeNames, const String& mode, IDBTransactionOptions* options);
		IDBTransaction* transaction(TArray<String*>* storeNames, const String& mode, IDBTransactionOptions* options);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static IDBDatabase* prototype;
		IDBDatabase();
	};
	class IDBOpenDBRequest;
	class IDBFactory: public Object {
	public:
		double cmp(const _Any& first, const _Any& second);
		Promise<TArray<IDBDatabaseInfo*>*>* databases();
		IDBOpenDBRequest* deleteDatabase(const String& name);
		IDBOpenDBRequest* open(const String& name);
		IDBOpenDBRequest* open(const String& name, double version);
		static IDBFactory* prototype;
		IDBFactory();
	};
	class IDBKeyRange;
	class IDBIndex: public Object {
	public:
		_Union<String*, TArray<String*>*>* get_keyPath();
		bool get_multiEntry();
		String* get_name();
		void set_name(const String& name);
		IDBObjectStore* get_objectStore();
		bool get_unique();
		IDBRequest<double>* count();
		IDBRequest<double>* count(const String& query);
		IDBRequest<double>* count(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<_Any*>* get(const String& query);
		IDBRequest<_Any*>* get(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<TArray<_Any*>*>* getAll();
		IDBRequest<TArray<_Any*>*>* getAll(const String& query);
		IDBRequest<TArray<_Any*>*>* getAll(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<TArray<_Any*>*>* getAll(const String& query, double count);
		IDBRequest<TArray<_Any*>*>* getAll(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query, double count);
		IDBRequest<TArray<_Any*>*>* getAllKeys();
		IDBRequest<TArray<_Any*>*>* getAllKeys(const String& query);
		IDBRequest<TArray<_Any*>*>* getAllKeys(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<TArray<_Any*>*>* getAllKeys(const String& query, double count);
		IDBRequest<TArray<_Any*>*>* getAllKeys(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query, double count);
		IDBRequest<_Any*>* getKey(const String& query);
		IDBRequest<_Any*>* getKey(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<IDBCursorWithValue*>* openCursor();
		IDBRequest<IDBCursorWithValue*>* openCursor(const String& query);
		IDBRequest<IDBCursorWithValue*>* openCursor(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<IDBCursorWithValue*>* openCursor(const String& query, const String& direction);
		IDBRequest<IDBCursorWithValue*>* openCursor(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query, const String& direction);
		IDBRequest<IDBCursor*>* openKeyCursor();
		IDBRequest<IDBCursor*>* openKeyCursor(const String& query);
		IDBRequest<IDBCursor*>* openKeyCursor(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<IDBCursor*>* openKeyCursor(const String& query, const String& direction);
		IDBRequest<IDBCursor*>* openKeyCursor(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query, const String& direction);
		static IDBIndex* prototype;
		IDBIndex();
	};
	class IDBKeyRange: public Object {
	public:
		Object* get_lower();
		bool get_lowerOpen();
		Object* get_upper();
		bool get_upperOpen();
		bool includes(const _Any& key);
		static IDBKeyRange* prototype;
		IDBKeyRange();
		static IDBKeyRange* bound(const _Any& lower, const _Any& upper);
		static IDBKeyRange* bound(const _Any& lower, const _Any& upper, bool lowerOpen);
		static IDBKeyRange* bound(const _Any& lower, const _Any& upper, bool lowerOpen, bool upperOpen);
		static IDBKeyRange* lowerBound(const _Any& lower);
		static IDBKeyRange* lowerBound(const _Any& lower, bool open);
		static IDBKeyRange* only(const _Any& value);
		static IDBKeyRange* upperBound(const _Any& upper);
		static IDBKeyRange* upperBound(const _Any& upper, bool open);
	};
	class IDBObjectStore: public Object {
	public:
		bool get_autoIncrement();
		DOMStringList* get_indexNames();
		_Union<String*, TArray<String*>*>* get_keyPath();
		String* get_name();
		void set_name(const String& name);
		IDBTransaction* get_transaction();
		IDBRequest<_Any*>* add(const _Any& value);
		IDBRequest<_Any*>* add(const _Any& value, const String& key);
		IDBRequest<_Any*>* add(const _Any& value, const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, Array*>& key);
		IDBRequest<_Any*>* clear();
		IDBRequest<double>* count();
		IDBRequest<double>* count(const String& query);
		IDBRequest<double>* count(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBIndex* createIndex(const String& name, const String& keyPath);
		IDBIndex* createIndex(const String& name, TArray<String*>* keyPath);
		IDBIndex* createIndex(const String& name, const String& keyPath, IDBIndexParameters* options);
		IDBIndex* createIndex(const String& name, TArray<String*>* keyPath, IDBIndexParameters* options);
		[[cheerp::interface_name(("delete"))]]
		IDBRequest<_Any*>* delete_(const String& query);
		[[cheerp::interface_name(("delete"))]]
		IDBRequest<_Any*>* delete_(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		void deleteIndex(const String& name);
		IDBRequest<_Any*>* get(const String& query);
		IDBRequest<_Any*>* get(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<TArray<_Any*>*>* getAll();
		IDBRequest<TArray<_Any*>*>* getAll(const String& query);
		IDBRequest<TArray<_Any*>*>* getAll(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<TArray<_Any*>*>* getAll(const String& query, double count);
		IDBRequest<TArray<_Any*>*>* getAll(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query, double count);
		IDBRequest<TArray<_Any*>*>* getAllKeys();
		IDBRequest<TArray<_Any*>*>* getAllKeys(const String& query);
		IDBRequest<TArray<_Any*>*>* getAllKeys(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<TArray<_Any*>*>* getAllKeys(const String& query, double count);
		IDBRequest<TArray<_Any*>*>* getAllKeys(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query, double count);
		IDBRequest<_Any*>* getKey(const String& query);
		IDBRequest<_Any*>* getKey(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBIndex* index(const String& name);
		IDBRequest<IDBCursorWithValue*>* openCursor();
		IDBRequest<IDBCursorWithValue*>* openCursor(const String& query);
		IDBRequest<IDBCursorWithValue*>* openCursor(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<IDBCursorWithValue*>* openCursor(const String& query, const String& direction);
		IDBRequest<IDBCursorWithValue*>* openCursor(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query, const String& direction);
		IDBRequest<IDBCursor*>* openKeyCursor();
		IDBRequest<IDBCursor*>* openKeyCursor(const String& query);
		IDBRequest<IDBCursor*>* openKeyCursor(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query);
		IDBRequest<IDBCursor*>* openKeyCursor(const String& query, const String& direction);
		IDBRequest<IDBCursor*>* openKeyCursor(const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, IDBKeyRange*, Array*>& query, const String& direction);
		IDBRequest<_Any*>* put(const _Any& value);
		IDBRequest<_Any*>* put(const _Any& value, const String& key);
		IDBRequest<_Any*>* put(const _Any& value, const _Union<double, Date*, ArrayBuffer*, ArrayBufferView*, Array*>& key);
		static IDBObjectStore* prototype;
		IDBObjectStore();
	};
	class IDBRequestEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"success\""))]]
		Event* get__34_success_34_();
		[[cheerp::interface_name(("set_\"success\""))]]
		void set__34_success_34_(Event* _34_success_34_);
	};
	class IDBOpenDBRequestEventMap: public IDBRequestEventMap {
	public:
		[[cheerp::interface_name(("get_\"blocked\""))]]
		IDBVersionChangeEvent* get__34_blocked_34_();
		[[cheerp::interface_name(("set_\"blocked\""))]]
		void set__34_blocked_34_(IDBVersionChangeEvent* _34_blocked_34_);
		[[cheerp::interface_name(("get_\"upgradeneeded\""))]]
		IDBVersionChangeEvent* get__34_upgradeneeded_34_();
		[[cheerp::interface_name(("set_\"upgradeneeded\""))]]
		void set__34_upgradeneeded_34_(IDBVersionChangeEvent* _34_upgradeneeded_34_);
	};
	template<class _T0>
	class IDBRequest: public EventTarget {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		DOMException* get_error();
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(Event*)>* get_onsuccess();
		void set_onsuccess(EventListener* onsuccess);
		void set_onsuccess(const _Function<_Any*(Event*)>& onsuccess);
		String* get_readyState();
		_T0 get_result();
		_Union<IDBCursor*, IDBIndex*, IDBObjectStore*>* get_source();
		IDBTransaction* get_transaction();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static IDBRequest<_Any*>* prototype;
		IDBRequest();
	};
	class IDBOpenDBRequest: public IDBRequest<IDBDatabase*> {
	public:
		_Function<_Any*(IDBVersionChangeEvent*)>* get_onblocked();
		void set_onblocked(EventListener* onblocked);
		void set_onblocked(const _Function<_Any*(IDBVersionChangeEvent*)>& onblocked);
		_Function<_Any*(IDBVersionChangeEvent*)>* get_onupgradeneeded();
		void set_onupgradeneeded(EventListener* onupgradeneeded);
		void set_onupgradeneeded(const _Function<_Any*(IDBVersionChangeEvent*)>& onupgradeneeded);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static IDBOpenDBRequest* prototype;
		IDBOpenDBRequest();
	};
	class IDBTransactionEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"abort\""))]]
		Event* get__34_abort_34_();
		[[cheerp::interface_name(("set_\"abort\""))]]
		void set__34_abort_34_(Event* _34_abort_34_);
		[[cheerp::interface_name(("get_\"complete\""))]]
		Event* get__34_complete_34_();
		[[cheerp::interface_name(("set_\"complete\""))]]
		void set__34_complete_34_(Event* _34_complete_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
	};
	class IDBTransaction: public EventTarget {
	public:
		IDBDatabase* get_db();
		String* get_durability();
		DOMException* get_error();
		String* get_mode();
		DOMStringList* get_objectStoreNames();
		_Function<_Any*(Event*)>* get_onabort();
		void set_onabort(EventListener* onabort);
		void set_onabort(const _Function<_Any*(Event*)>& onabort);
		_Function<_Any*(Event*)>* get_oncomplete();
		void set_oncomplete(EventListener* oncomplete);
		void set_oncomplete(const _Function<_Any*(Event*)>& oncomplete);
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		void abort();
		void commit();
		IDBObjectStore* objectStore(const String& name);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static IDBTransaction* prototype;
		IDBTransaction();
	};
	class IDBVersionChangeEvent: public Event {
	public:
		double get_newVersion();
		double get_oldVersion();
		static IDBVersionChangeEvent* prototype;
		IDBVersionChangeEvent(const String& type);
		IDBVersionChangeEvent(const String& type, IDBVersionChangeEventInit* eventInitDict);
	};
	class IIRFilterNode: public AudioNode {
	public:
		void getFrequencyResponse(Float32Array* frequencyHz, Float32Array* magResponse, Float32Array* phaseResponse);
		static IIRFilterNode* prototype;
		IIRFilterNode(BaseAudioContext* context, IIRFilterOptions* options);
	};
	class IdleDeadline: public Object {
	public:
		bool get_didTimeout();
		double timeRemaining();
		static IdleDeadline* prototype;
		IdleDeadline();
	};
	class ImageBitmap: public Object {
	public:
		double get_height();
		double get_width();
		void close();
		static ImageBitmap* prototype;
		ImageBitmap();
	};
	class ImageBitmapRenderingContext: public Object {
	public:
		_Union<HTMLCanvasElement*, OffscreenCanvas*>* get_canvas();
		void transferFromImageBitmap(ImageBitmap* bitmap);
		static ImageBitmapRenderingContext* prototype;
		ImageBitmapRenderingContext();
	};
	class ImageData: public Object {
	public:
		String* get_colorSpace();
		Uint8ClampedArray* get_data();
		double get_height();
		double get_width();
		static ImageData* prototype;
		ImageData(double sw, double sh);
		ImageData(double sw, double sh, ImageDataSettings* settings);
		ImageData(Uint8ClampedArray* data, double sw);
		ImageData(Uint8ClampedArray* data, double sw, double sh);
		ImageData(Uint8ClampedArray* data, double sw, double sh, ImageDataSettings* settings);
	};
	class MediaDeviceInfo: public Object {
	public:
		String* get_deviceId();
		String* get_groupId();
		String* get_kind();
		String* get_label();
		Object* toJSON();
		static MediaDeviceInfo* prototype;
		MediaDeviceInfo();
	};
	class InputDeviceInfo: public MediaDeviceInfo {
	public:
		MediaTrackCapabilities* getCapabilities();
		static InputDeviceInfo* prototype;
		InputDeviceInfo();
	};
	class InputEvent: public UIEvent {
	public:
		String* get_data();
		DataTransfer* get_dataTransfer();
		String* get_inputType();
		bool get_isComposing();
		TArray<StaticRange*>* getTargetRanges();
		static InputEvent* prototype;
		InputEvent(const String& type);
		InputEvent(const String& type, InputEventInit* eventInitDict);
	};
	class IntersectionObserverEntry;
	class IntersectionObserver: public Object {
	public:
		_Union<Document*, Element*>* get_root();
		String* get_rootMargin();
		ReadonlyArray<double>* get_thresholds();
		void disconnect();
		void observe(Element* target);
		TArray<IntersectionObserverEntry*>* takeRecords();
		void unobserve(Element* target);
		static IntersectionObserver* prototype;
		IntersectionObserver(EventListener* callback);
		IntersectionObserver(const _Function<void(TArray<IntersectionObserverEntry*>*, IntersectionObserver*)>& callback);
		IntersectionObserver(EventListener* callback, IntersectionObserverInit* options);
		IntersectionObserver(const _Function<void(TArray<IntersectionObserverEntry*>*, IntersectionObserver*)>& callback, IntersectionObserverInit* options);
	};
	class IntersectionObserverEntry: public Object {
	public:
		DOMRectReadOnly* get_boundingClientRect();
		double get_intersectionRatio();
		DOMRectReadOnly* get_intersectionRect();
		bool get_isIntersecting();
		DOMRectReadOnly* get_rootBounds();
		Element* get_target();
		double get_time();
		static IntersectionObserverEntry* prototype;
		IntersectionObserverEntry(IntersectionObserverEntryInit* intersectionObserverEntryInit);
	};
	class KHR_parallel_shader_compile: public Object {
	public:
		double get_COMPLETION_STATUS_KHR();
	};
	class KeyboardEvent: public UIEvent {
	public:
		bool get_altKey();
		double get_charCode();
		String* get_code();
		bool get_ctrlKey();
		bool get_isComposing();
		String* get_key();
		double get_keyCode();
		double get_location();
		bool get_metaKey();
		bool get_repeat();
		bool get_shiftKey();
		bool getModifierState(const String& keyArg);
		void initKeyboardEvent(const String& typeArg);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg, bool cancelableArg);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg, const String& keyArg);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg, const String& keyArg, double locationArg);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg, const String& keyArg, double locationArg, bool ctrlKey);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg, const String& keyArg, double locationArg, bool ctrlKey, bool altKey);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg, const String& keyArg, double locationArg, bool ctrlKey, bool altKey, bool shiftKey);
		void initKeyboardEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Window* viewArg, const String& keyArg, double locationArg, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);
		double get_DOM_KEY_LOCATION_STANDARD();
		double get_DOM_KEY_LOCATION_LEFT();
		double get_DOM_KEY_LOCATION_RIGHT();
		double get_DOM_KEY_LOCATION_NUMPAD();
		static KeyboardEvent* prototype;
		KeyboardEvent(const String& type);
		KeyboardEvent(const String& type, KeyboardEventInit* eventInitDict);
		static double DOM_KEY_LOCATION_STANDARD;
		static double DOM_KEY_LOCATION_LEFT;
		static double DOM_KEY_LOCATION_RIGHT;
		static double DOM_KEY_LOCATION_NUMPAD;
	};
	class KeyframeEffect: public AnimationEffect {
	public:
		String* get_composite();
		void set_composite(const String& composite);
		String* get_iterationComposite();
		void set_iterationComposite(const String& iterationComposite);
		String* get_pseudoElement();
		void set_pseudoElement(const String& pseudoElement);
		Element* get_target();
		void set_target(Element* target);
		TArray<ComputedKeyframe*>* getKeyframes();
		void setKeyframes(const _Union<PropertyIndexedKeyframes*, TArray<Keyframe*>*>& keyframes);
		static KeyframeEffect* prototype;
		KeyframeEffect(Element* target, const _Union<PropertyIndexedKeyframes*, TArray<Keyframe*>*>& keyframes);
		KeyframeEffect(Element* target, const _Union<PropertyIndexedKeyframes*, TArray<Keyframe*>*>& keyframes, const _Union<double, KeyframeEffectOptions*>& options);
		KeyframeEffect(KeyframeEffect* source);
	};
	class Location: public Object {
	public:
		DOMStringList* get_ancestorOrigins();
		String* get_hash();
		void set_hash(const String& hash);
		String* get_host();
		void set_host(const String& host);
		String* get_hostname();
		void set_hostname(const String& hostname);
		String* get_href();
		void set_href(const String& href);
		String* toString();
		String* get_origin();
		String* get_pathname();
		void set_pathname(const String& pathname);
		String* get_port();
		void set_port(const String& port);
		String* get_protocol();
		void set_protocol(const String& protocol);
		String* get_search();
		void set_search(const String& search);
		void assign(const String& url);
		void assign(URL* url);
		void reload();
		void replace(const String& url) const;
		void replace(URL* url) const;
		static Location* prototype;
		Location();
	};
	class Lock: public Object {
	public:
		String* get_mode();
		String* get_name();
		static Lock* prototype;
		Lock();
	};
	class LockManager: public Object {
	public:
		Promise<LockManagerSnapshot*>* query();
		Promise<_Any*>* request(const String& name, EventListener* callback);
		Promise<_Any*>* request(const String& name, const _Function<_Any*(Lock*)>& callback);
		Promise<_Any*>* request(const String& name, LockOptions* options, EventListener* callback);
		Promise<_Any*>* request(const String& name, LockOptions* options, const _Function<_Any*(Lock*)>& callback);
		static LockManager* prototype;
		LockManager();
	};
	class MIDIAccessEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"statechange\""))]]
		Event* get__34_statechange_34_();
		[[cheerp::interface_name(("set_\"statechange\""))]]
		void set__34_statechange_34_(Event* _34_statechange_34_);
	};
	class MIDIInputMap;
	class MIDIOutputMap;
	class MIDIAccess: public EventTarget {
	public:
		MIDIInputMap* get_inputs();
		_Function<_Any*(Event*)>* get_onstatechange();
		void set_onstatechange(EventListener* onstatechange);
		void set_onstatechange(const _Function<_Any*(Event*)>& onstatechange);
		MIDIOutputMap* get_outputs();
		bool get_sysexEnabled();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MIDIAccess* prototype;
		MIDIAccess();
	};
	class MIDIConnectionEvent: public Event {
	public:
		MIDIPort* get_port();
		static MIDIConnectionEvent* prototype;
		MIDIConnectionEvent(const String& type);
		MIDIConnectionEvent(const String& type, MIDIConnectionEventInit* eventInitDict);
	};
	class MIDIPortEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"statechange\""))]]
		Event* get__34_statechange_34_();
		[[cheerp::interface_name(("set_\"statechange\""))]]
		void set__34_statechange_34_(Event* _34_statechange_34_);
	};
	class MIDIInputEventMap: public MIDIPortEventMap {
	public:
		[[cheerp::interface_name(("get_\"midimessage\""))]]
		Event* get__34_midimessage_34_();
		[[cheerp::interface_name(("set_\"midimessage\""))]]
		void set__34_midimessage_34_(Event* _34_midimessage_34_);
	};
	class MIDIPort: public EventTarget {
	public:
		String* get_connection();
		String* get_id();
		String* get_manufacturer();
		String* get_name();
		_Function<_Any*(Event*)>* get_onstatechange();
		void set_onstatechange(EventListener* onstatechange);
		void set_onstatechange(const _Function<_Any*(Event*)>& onstatechange);
		String* get_state();
		String* get_type();
		String* get_version();
		Promise<MIDIPort*>* close();
		Promise<MIDIPort*>* open();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MIDIPort* prototype;
		MIDIPort();
	};
	class MIDIInput: public MIDIPort {
	public:
		_Function<_Any*(Event*)>* get_onmidimessage();
		void set_onmidimessage(EventListener* onmidimessage);
		void set_onmidimessage(const _Function<_Any*(Event*)>& onmidimessage);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MIDIInput* prototype;
		MIDIInput();
	};
	class MIDIInputMap: public Object {
	public:
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(MIDIInput*, String*, MIDIInputMap*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(MIDIInput*, String*, MIDIInputMap*)>& callbackfn, const _Any& thisArg);
		static MIDIInputMap* prototype;
		MIDIInputMap();
	};
	class MIDIMessageEvent: public Event {
	public:
		Uint8Array* get_data();
		static MIDIMessageEvent* prototype;
		MIDIMessageEvent(const String& type);
		MIDIMessageEvent(const String& type, MIDIMessageEventInit* eventInitDict);
	};
	class MIDIOutput: public MIDIPort {
	public:
		void send(TArray<double>* data);
		void send(TArray<double>* data, double timestamp);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MIDIOutput* prototype;
		MIDIOutput();
	};
	class MIDIOutputMap: public Object {
	public:
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(MIDIOutput*, String*, MIDIOutputMap*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(MIDIOutput*, String*, MIDIOutputMap*)>& callbackfn, const _Any& thisArg);
		static MIDIOutputMap* prototype;
		MIDIOutputMap();
	};
	class MathMLElementEventMap: public ElementEventMap, public GlobalEventHandlersEventMap {
	};
	class MathMLElement: public Element, public ElementCSSInlineStyle, public GlobalEventHandlers, public HTMLOrSVGElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MathMLElement* prototype;
		MathMLElement();
	};
	class MediaCapabilities: public Object {
	public:
		Promise<MediaCapabilitiesDecodingInfo*>* decodingInfo(MediaDecodingConfiguration* configuration);
		Promise<MediaCapabilitiesEncodingInfo*>* encodingInfo(MediaEncodingConfiguration* configuration);
		static MediaCapabilities* prototype;
		MediaCapabilities();
	};
	class MediaDevicesEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"devicechange\""))]]
		Event* get__34_devicechange_34_();
		[[cheerp::interface_name(("set_\"devicechange\""))]]
		void set__34_devicechange_34_(Event* _34_devicechange_34_);
	};
	class MediaDevices: public EventTarget {
	public:
		_Function<_Any*(Event*)>* get_ondevicechange();
		void set_ondevicechange(EventListener* ondevicechange);
		void set_ondevicechange(const _Function<_Any*(Event*)>& ondevicechange);
		Promise<TArray<MediaDeviceInfo*>*>* enumerateDevices();
		Promise<MediaStream*>* getDisplayMedia();
		Promise<MediaStream*>* getDisplayMedia(DisplayMediaStreamOptions* options);
		MediaTrackSupportedConstraints* getSupportedConstraints();
		Promise<MediaStream*>* getUserMedia();
		Promise<MediaStream*>* getUserMedia(MediaStreamConstraints* constraints);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MediaDevices* prototype;
		MediaDevices();
	};
	class MediaElementAudioSourceNode: public AudioNode {
	public:
		HTMLMediaElement* get_mediaElement();
		static MediaElementAudioSourceNode* prototype;
		MediaElementAudioSourceNode(AudioContext* context, MediaElementAudioSourceOptions* options);
	};
	class MediaEncryptedEvent: public Event {
	public:
		ArrayBuffer* get_initData();
		String* get_initDataType();
		static MediaEncryptedEvent* prototype;
		MediaEncryptedEvent(const String& type);
		MediaEncryptedEvent(const String& type, MediaEncryptedEventInit* eventInitDict);
	};
	class MediaError: public Object {
	public:
		double get_code();
		String* get_message();
		double get_MEDIA_ERR_ABORTED();
		double get_MEDIA_ERR_NETWORK();
		double get_MEDIA_ERR_DECODE();
		double get_MEDIA_ERR_SRC_NOT_SUPPORTED();
		static MediaError* prototype;
		MediaError();
		static double MEDIA_ERR_ABORTED;
		static double MEDIA_ERR_NETWORK;
		static double MEDIA_ERR_DECODE;
		static double MEDIA_ERR_SRC_NOT_SUPPORTED;
	};
	class MediaKeyMessageEvent: public Event {
	public:
		ArrayBuffer* get_message();
		String* get_messageType();
		static MediaKeyMessageEvent* prototype;
		MediaKeyMessageEvent(const String& type, MediaKeyMessageEventInit* eventInitDict);
	};
	class MediaKeySessionEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"keystatuseschange\""))]]
		Event* get__34_keystatuseschange_34_();
		[[cheerp::interface_name(("set_\"keystatuseschange\""))]]
		void set__34_keystatuseschange_34_(Event* _34_keystatuseschange_34_);
		[[cheerp::interface_name(("get_\"message\""))]]
		MediaKeyMessageEvent* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MediaKeyMessageEvent* _34_message_34_);
	};
	class MediaKeyStatusMap;
	class MediaKeySession: public EventTarget {
	public:
		Promise<String*>* get_closed();
		double get_expiration();
		MediaKeyStatusMap* get_keyStatuses();
		_Function<_Any*(Event*)>* get_onkeystatuseschange();
		void set_onkeystatuseschange(EventListener* onkeystatuseschange);
		void set_onkeystatuseschange(const _Function<_Any*(Event*)>& onkeystatuseschange);
		_Function<_Any*(MediaKeyMessageEvent*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MediaKeyMessageEvent*)>& onmessage);
		String* get_sessionId();
		Promise<_Any*>* close();
		Promise<_Any*>* generateRequest(const String& initDataType, const _Union<ArrayBuffer*, ArrayBufferView*>& initData);
		Promise<bool>* load(const String& sessionId);
		Promise<_Any*>* remove();
		Promise<_Any*>* update(const _Union<ArrayBuffer*, ArrayBufferView*>& response);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MediaKeySession* prototype;
		MediaKeySession();
	};
	class MediaKeyStatusMap: public Object {
	public:
		int get_size() const;
		String* get(const _Union<ArrayBuffer*, ArrayBufferView*>& keyId);
		bool has(const _Union<ArrayBuffer*, ArrayBufferView*>& keyId);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(String*, _Union<ArrayBuffer*, ArrayBufferView*>*, MediaKeyStatusMap*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(String*, _Union<ArrayBuffer*, ArrayBufferView*>*, MediaKeyStatusMap*)>& callbackfn, const _Any& thisArg);
		static MediaKeyStatusMap* prototype;
		MediaKeyStatusMap();
	};
	class MediaKeySystemAccess: public Object {
	public:
		String* get_keySystem();
		Promise<MediaKeys*>* createMediaKeys();
		MediaKeySystemConfiguration* getConfiguration();
		static MediaKeySystemAccess* prototype;
		MediaKeySystemAccess();
	};
	class MediaKeys: public Object {
	public:
		MediaKeySession* createSession();
		MediaKeySession* createSession(const String& sessionType);
		Promise<bool>* setServerCertificate(const _Union<ArrayBuffer*, ArrayBufferView*>& serverCertificate);
		static MediaKeys* prototype;
		MediaKeys();
	};
	class MediaList: public Object {
	public:
		int get_length() const;
		String* get_mediaText();
		void set_mediaText(const String& mediaText);
		String* toString();
		void appendMedium(const String& medium);
		void deleteMedium(const String& medium);
		String* item(double index);
		String* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		String*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::String*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static MediaList* prototype;
		MediaList();
	public:
		using client::Object::operator[];
	};
	class MediaMetadata: public Object {
	public:
		String* get_album();
		void set_album(const String& album);
		String* get_artist();
		void set_artist(const String& artist);
		ReadonlyArray<MediaImage*>* get_artwork();
		void set_artwork(ReadonlyArray<MediaImage*>* artwork);
		String* get_title();
		void set_title(const String& title);
		static MediaMetadata* prototype;
		MediaMetadata();
		MediaMetadata(MediaMetadataInit* init);
	};
	class MediaQueryListEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"change\""))]]
		MediaQueryListEvent* get__34_change_34_();
		[[cheerp::interface_name(("set_\"change\""))]]
		void set__34_change_34_(MediaQueryListEvent* _34_change_34_);
	};
	class MediaQueryList: public EventTarget {
	public:
		bool get_matches();
		String* get_media();
		_Function<_Any*(MediaQueryListEvent*)>* get_onchange();
		void set_onchange(EventListener* onchange);
		void set_onchange(const _Function<_Any*(MediaQueryListEvent*)>& onchange);
		void addListener(EventListener* callback);
		void addListener(const _Function<_Any*(MediaQueryListEvent*)>& callback);
		void removeListener(EventListener* callback);
		void removeListener(const _Function<_Any*(MediaQueryListEvent*)>& callback);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MediaQueryList* prototype;
		MediaQueryList();
	};
	class MediaQueryListEvent: public Event {
	public:
		bool get_matches();
		String* get_media();
		static MediaQueryListEvent* prototype;
		MediaQueryListEvent(const String& type);
		MediaQueryListEvent(const String& type, MediaQueryListEventInit* eventInitDict);
	};
	class MediaRecorderEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"dataavailable\""))]]
		BlobEvent* get__34_dataavailable_34_();
		[[cheerp::interface_name(("set_\"dataavailable\""))]]
		void set__34_dataavailable_34_(BlobEvent* _34_dataavailable_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"pause\""))]]
		Event* get__34_pause_34_();
		[[cheerp::interface_name(("set_\"pause\""))]]
		void set__34_pause_34_(Event* _34_pause_34_);
		[[cheerp::interface_name(("get_\"resume\""))]]
		Event* get__34_resume_34_();
		[[cheerp::interface_name(("set_\"resume\""))]]
		void set__34_resume_34_(Event* _34_resume_34_);
		[[cheerp::interface_name(("get_\"start\""))]]
		Event* get__34_start_34_();
		[[cheerp::interface_name(("set_\"start\""))]]
		void set__34_start_34_(Event* _34_start_34_);
		[[cheerp::interface_name(("get_\"stop\""))]]
		Event* get__34_stop_34_();
		[[cheerp::interface_name(("set_\"stop\""))]]
		void set__34_stop_34_(Event* _34_stop_34_);
	};
	class MediaRecorder: public EventTarget {
	public:
		double get_audioBitsPerSecond();
		String* get_mimeType();
		_Function<_Any*(BlobEvent*)>* get_ondataavailable();
		void set_ondataavailable(EventListener* ondataavailable);
		void set_ondataavailable(const _Function<_Any*(BlobEvent*)>& ondataavailable);
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(Event*)>* get_onpause();
		void set_onpause(EventListener* onpause);
		void set_onpause(const _Function<_Any*(Event*)>& onpause);
		_Function<_Any*(Event*)>* get_onresume();
		void set_onresume(EventListener* onresume);
		void set_onresume(const _Function<_Any*(Event*)>& onresume);
		_Function<_Any*(Event*)>* get_onstart();
		void set_onstart(EventListener* onstart);
		void set_onstart(const _Function<_Any*(Event*)>& onstart);
		_Function<_Any*(Event*)>* get_onstop();
		void set_onstop(EventListener* onstop);
		void set_onstop(const _Function<_Any*(Event*)>& onstop);
		String* get_state();
		MediaStream* get_stream();
		double get_videoBitsPerSecond();
		void pause();
		void requestData();
		void resume();
		void start();
		void start(double timeslice);
		void stop();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MediaRecorder* prototype;
		MediaRecorder(MediaStream* stream);
		MediaRecorder(MediaStream* stream, MediaRecorderOptions* options);
		static bool isTypeSupported(const String& type);
	};
	class MediaSession: public Object {
	public:
		MediaMetadata* get_metadata();
		void set_metadata(MediaMetadata* metadata);
		String* get_playbackState();
		void set_playbackState(const String& playbackState);
		void setActionHandler(const String& action, EventListener* handler);
		void setActionHandler(const String& action, const _Function<void(MediaSessionActionDetails*)>& handler);
		void setPositionState();
		void setPositionState(MediaPositionState* state);
		static MediaSession* prototype;
		MediaSession();
	};
	class MediaSourceEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"sourceclose\""))]]
		Event* get__34_sourceclose_34_();
		[[cheerp::interface_name(("set_\"sourceclose\""))]]
		void set__34_sourceclose_34_(Event* _34_sourceclose_34_);
		[[cheerp::interface_name(("get_\"sourceended\""))]]
		Event* get__34_sourceended_34_();
		[[cheerp::interface_name(("set_\"sourceended\""))]]
		void set__34_sourceended_34_(Event* _34_sourceended_34_);
		[[cheerp::interface_name(("get_\"sourceopen\""))]]
		Event* get__34_sourceopen_34_();
		[[cheerp::interface_name(("set_\"sourceopen\""))]]
		void set__34_sourceopen_34_(Event* _34_sourceopen_34_);
	};
	class SourceBufferList;
	class SourceBuffer;
	class MediaSource: public EventTarget {
	public:
		SourceBufferList* get_activeSourceBuffers();
		double get_duration();
		void set_duration(double duration);
		_Function<_Any*(Event*)>* get_onsourceclose();
		void set_onsourceclose(EventListener* onsourceclose);
		void set_onsourceclose(const _Function<_Any*(Event*)>& onsourceclose);
		_Function<_Any*(Event*)>* get_onsourceended();
		void set_onsourceended(EventListener* onsourceended);
		void set_onsourceended(const _Function<_Any*(Event*)>& onsourceended);
		_Function<_Any*(Event*)>* get_onsourceopen();
		void set_onsourceopen(EventListener* onsourceopen);
		void set_onsourceopen(const _Function<_Any*(Event*)>& onsourceopen);
		String* get_readyState();
		SourceBufferList* get_sourceBuffers();
		SourceBuffer* addSourceBuffer(const String& type);
		void clearLiveSeekableRange();
		void endOfStream();
		void endOfStream(const String& error);
		void removeSourceBuffer(SourceBuffer* sourceBuffer);
		void setLiveSeekableRange(double start, double end);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MediaSource* prototype;
		MediaSource();
		static bool isTypeSupported(const String& type);
	};
	class MediaStreamEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"addtrack\""))]]
		MediaStreamTrackEvent* get__34_addtrack_34_();
		[[cheerp::interface_name(("set_\"addtrack\""))]]
		void set__34_addtrack_34_(MediaStreamTrackEvent* _34_addtrack_34_);
		[[cheerp::interface_name(("get_\"removetrack\""))]]
		MediaStreamTrackEvent* get__34_removetrack_34_();
		[[cheerp::interface_name(("set_\"removetrack\""))]]
		void set__34_removetrack_34_(MediaStreamTrackEvent* _34_removetrack_34_);
	};
	class MediaStream: public EventTarget {
	public:
		bool get_active();
		String* get_id();
		_Function<_Any*(MediaStreamTrackEvent*)>* get_onaddtrack();
		void set_onaddtrack(EventListener* onaddtrack);
		void set_onaddtrack(const _Function<_Any*(MediaStreamTrackEvent*)>& onaddtrack);
		_Function<_Any*(MediaStreamTrackEvent*)>* get_onremovetrack();
		void set_onremovetrack(EventListener* onremovetrack);
		void set_onremovetrack(const _Function<_Any*(MediaStreamTrackEvent*)>& onremovetrack);
		void addTrack(MediaStreamTrack* track);
		MediaStream* clone();
		TArray<MediaStreamTrack*>* getAudioTracks();
		MediaStreamTrack* getTrackById(const String& trackId);
		TArray<MediaStreamTrack*>* getTracks();
		TArray<MediaStreamTrack*>* getVideoTracks();
		void removeTrack(MediaStreamTrack* track);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MediaStream* prototype;
		MediaStream();
		MediaStream(MediaStream* stream);
		MediaStream(TArray<MediaStreamTrack*>* tracks);
	};
	class MediaStreamAudioDestinationNode: public AudioNode {
	public:
		MediaStream* get_stream();
		static MediaStreamAudioDestinationNode* prototype;
		MediaStreamAudioDestinationNode(AudioContext* context);
		MediaStreamAudioDestinationNode(AudioContext* context, AudioNodeOptions* options);
	};
	class MediaStreamAudioSourceNode: public AudioNode {
	public:
		MediaStream* get_mediaStream();
		static MediaStreamAudioSourceNode* prototype;
		MediaStreamAudioSourceNode(AudioContext* context, MediaStreamAudioSourceOptions* options);
	};
	class MediaStreamTrackEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"ended\""))]]
		Event* get__34_ended_34_();
		[[cheerp::interface_name(("set_\"ended\""))]]
		void set__34_ended_34_(Event* _34_ended_34_);
		[[cheerp::interface_name(("get_\"mute\""))]]
		Event* get__34_mute_34_();
		[[cheerp::interface_name(("set_\"mute\""))]]
		void set__34_mute_34_(Event* _34_mute_34_);
		[[cheerp::interface_name(("get_\"unmute\""))]]
		Event* get__34_unmute_34_();
		[[cheerp::interface_name(("set_\"unmute\""))]]
		void set__34_unmute_34_(Event* _34_unmute_34_);
	};
	class MediaStreamTrackEvent: public Event {
	public:
		MediaStreamTrack* get_track();
		static MediaStreamTrackEvent* prototype;
		MediaStreamTrackEvent(const String& type, MediaStreamTrackEventInit* eventInitDict);
	};
	class MessageChannel: public Object {
	public:
		MessagePort* get_port1();
		MessagePort* get_port2();
		static MessageChannel* prototype;
		MessageChannel();
	};
	template<class _T0>
	class MessageEvent: public Event {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_T0 get_data();
		String* get_lastEventId();
		String* get_origin();
		ReadonlyArray<MessagePort*>* get_ports();
		_Union<MessagePort*, ServiceWorker*, Window*>* get_source();
		void initMessageEvent(const String& type);
		void initMessageEvent(const String& type, bool bubbles);
		void initMessageEvent(const String& type, bool bubbles, bool cancelable);
		void initMessageEvent(const String& type, bool bubbles, bool cancelable, const _Any& data);
		void initMessageEvent(const String& type, bool bubbles, bool cancelable, const _Any& data, const String& origin);
		void initMessageEvent(const String& type, bool bubbles, bool cancelable, const _Any& data, const String& origin, const String& lastEventId);
		void initMessageEvent(const String& type, bool bubbles, bool cancelable, const _Any& data, const String& origin, const String& lastEventId, const _Union<MessagePort*, ServiceWorker*, Window*>& source);
		void initMessageEvent(const String& type, bool bubbles, bool cancelable, const _Any& data, const String& origin, const String& lastEventId, const _Union<MessagePort*, ServiceWorker*, Window*>& source, TArray<MessagePort*>* ports);
		static MessageEvent<_Any*>* prototype;
		MessageEvent(const String& type);
		template<class _T1>
		MessageEvent(const String& type, MessageEventInit<_T1>* eventInitDict);
	};
	class MessagePortEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"messageerror\""))]]
		MessageEvent<_Any*>* get__34_messageerror_34_();
		[[cheerp::interface_name(("set_\"messageerror\""))]]
		void set__34_messageerror_34_(MessageEvent<_Any*>* _34_messageerror_34_);
	};
	class MessagePort: public EventTarget {
	public:
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessageerror();
		void set_onmessageerror(EventListener* onmessageerror);
		void set_onmessageerror(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessageerror);
		void close();
		void postMessage(const _Any& message, Array* transfer);
		void postMessage(const _Any& message);
		void postMessage(const _Any& message, StructuredSerializeOptions* options);
		void start();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static MessagePort* prototype;
		MessagePort();
	};
	class Plugin;
	class MimeType: public Object {
	public:
		String* get_description();
		Plugin* get_enabledPlugin();
		String* get_suffixes();
		String* get_type();
		static MimeType* prototype;
		MimeType();
	};
	class MimeTypeArray: public Object {
	public:
		int get_length() const;
		MimeType* item(double index);
		MimeType* namedItem(const String& name);
		MimeType* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		MimeType*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::MimeType*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static MimeTypeArray* prototype;
		MimeTypeArray();
	public:
		using client::Object::operator[];
	};
	class MutationEvent: public Event {
	public:
		double get_attrChange();
		String* get_attrName();
		String* get_newValue();
		String* get_prevValue();
		Node* get_relatedNode();
		void initMutationEvent(const String& typeArg);
		void initMutationEvent(const String& typeArg, bool bubblesArg);
		void initMutationEvent(const String& typeArg, bool bubblesArg, bool cancelableArg);
		void initMutationEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Node* relatedNodeArg);
		void initMutationEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Node* relatedNodeArg, const String& prevValueArg);
		void initMutationEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Node* relatedNodeArg, const String& prevValueArg, const String& newValueArg);
		void initMutationEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Node* relatedNodeArg, const String& prevValueArg, const String& newValueArg, const String& attrNameArg);
		void initMutationEvent(const String& typeArg, bool bubblesArg, bool cancelableArg, Node* relatedNodeArg, const String& prevValueArg, const String& newValueArg, const String& attrNameArg, double attrChangeArg);
		double get_MODIFICATION();
		double get_ADDITION();
		double get_REMOVAL();
		static MutationEvent* prototype;
		MutationEvent();
		static double MODIFICATION;
		static double ADDITION;
		static double REMOVAL;
	};
	class MutationRecord;
	class MutationObserver: public Object {
	public:
		void disconnect();
		void observe(Node* target);
		void observe(Node* target, MutationObserverInit* options);
		TArray<MutationRecord*>* takeRecords();
		static MutationObserver* prototype;
		MutationObserver(EventListener* callback);
		MutationObserver(const _Function<void(TArray<MutationRecord*>*, MutationObserver*)>& callback);
	};
	class MutationRecord: public Object {
	public:
		NodeList* get_addedNodes();
		String* get_attributeName();
		String* get_attributeNamespace();
		Node* get_nextSibling();
		String* get_oldValue();
		Node* get_previousSibling();
		NodeList* get_removedNodes();
		Node* get_target();
		String* get_type();
		static MutationRecord* prototype;
		MutationRecord();
	};
	class NamedNodeMap: public Object {
	public:
		int get_length() const;
		Attr* getNamedItem(const String& qualifiedName);
		Attr* getNamedItemNS(const String& namespace_, const String& localName);
		Attr* item(double index);
		Attr* removeNamedItem(const String& qualifiedName);
		Attr* removeNamedItemNS(const String& namespace_, const String& localName);
		Attr* setNamedItem(Attr* attr);
		Attr* setNamedItemNS(Attr* attr);
		Attr* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Attr*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::Attr*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static NamedNodeMap* prototype;
		NamedNodeMap();
	public:
		using client::Object::operator[];
	};
	class NavigationPreloadManager: public Object {
	public:
		Promise<_Any*>* disable();
		Promise<_Any*>* enable();
		Promise<NavigationPreloadState*>* getState();
		Promise<_Any*>* setHeaderValue(const String& value);
		static NavigationPreloadManager* prototype;
		NavigationPreloadManager();
	};
	class Permissions;
	class ServiceWorkerContainer;
	class UserActivation;
	class WakeLock;
	class NavigatorAutomationInformation: public virtual Object {
	public:
		bool get_webdriver();
	};
	class NavigatorBadge: public virtual Object {
	public:
		Promise<_Any*>* clearAppBadge();
		Promise<_Any*>* setAppBadge();
		Promise<_Any*>* setAppBadge(double contents);
	};
	class NavigatorConcurrentHardware: public virtual Object {
	public:
		double get_hardwareConcurrency();
	};
	class NavigatorContentUtils: public virtual Object {
	public:
		void registerProtocolHandler(const String& scheme, const String& url);
		void registerProtocolHandler(const String& scheme, URL* url);
	};
	class NavigatorCookies: public virtual Object {
	public:
		bool get_cookieEnabled();
	};
	class NavigatorID: public virtual Object {
	public:
		String* get_appCodeName();
		String* get_appName();
		String* get_appVersion();
		String* get_platform();
		String* get_product();
		String* get_productSub();
		String* get_userAgent();
		String* get_vendor();
		String* get_vendorSub();
	};
	class NavigatorLanguage: public virtual Object {
	public:
		String* get_language();
		ReadonlyArray<String*>* get_languages();
	};
	class NavigatorLocks: public virtual Object {
	public:
		LockManager* get_locks();
	};
	class NavigatorOnLine: public virtual Object {
	public:
		bool get_onLine();
	};
	class PluginArray;
	class NavigatorPlugins: public virtual Object {
	public:
		MimeTypeArray* get_mimeTypes();
		bool get_pdfViewerEnabled();
		PluginArray* get_plugins();
		bool javaEnabled();
	};
	class StorageManager;
	class NavigatorStorage: public virtual Object {
	public:
		StorageManager* get_storage();
	};
	class Navigator: public NavigatorAutomationInformation, public NavigatorBadge, public NavigatorConcurrentHardware, public NavigatorContentUtils, public NavigatorCookies, public NavigatorID, public NavigatorLanguage, public NavigatorLocks, public NavigatorOnLine, public NavigatorPlugins, public NavigatorStorage {
	public:
		Clipboard* get_clipboard();
		CredentialsContainer* get_credentials();
		String* get_doNotTrack();
		Geolocation* get_geolocation();
		double get_maxTouchPoints();
		MediaCapabilities* get_mediaCapabilities();
		MediaDevices* get_mediaDevices();
		MediaSession* get_mediaSession();
		Permissions* get_permissions();
		ServiceWorkerContainer* get_serviceWorker();
		UserActivation* get_userActivation();
		WakeLock* get_wakeLock();
		bool canShare();
		bool canShare(ShareData* data);
		TArray<Gamepad*>* getGamepads();
		Promise<MIDIAccess*>* requestMIDIAccess();
		Promise<MIDIAccess*>* requestMIDIAccess(MIDIOptions* options);
		Promise<MediaKeySystemAccess*>* requestMediaKeySystemAccess(const String& keySystem, TArray<MediaKeySystemConfiguration*>* supportedConfigurations);
		bool sendBeacon(const String& url);
		bool sendBeacon(URL* url);
		bool sendBeacon(const String& url, const String& data);
		bool sendBeacon(URL* url, const String& data);
		bool sendBeacon(const String& url, const _Union<ArrayBuffer*, ArrayBufferView*, Blob*, FormData*, URLSearchParams*, ReadableStream<_Any*>*>& data);
		bool sendBeacon(URL* url, const _Union<ArrayBuffer*, ArrayBufferView*, Blob*, FormData*, URLSearchParams*, ReadableStream<_Any*>*>& data);
		Promise<_Any*>* share();
		Promise<_Any*>* share(ShareData* data);
		bool vibrate(const _Union<double, TArray<double>*>& pattern);
		static Navigator* prototype;
		Navigator();
	};
	class NodeIterator: public Object {
	public:
		_Union<_Function<double(Node*)>*, Object*>* get_filter();
		bool get_pointerBeforeReferenceNode();
		Node* get_referenceNode();
		Node* get_root();
		double get_whatToShow();
		void detach();
		Node* nextNode();
		Node* previousNode();
		static NodeIterator* prototype;
		NodeIterator();
	};
	class NodeList: public Object {
	public:
		int get_length() const;
		Node* item(double index);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(Node*, double, NodeList*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(Node*, double, NodeList*)>& callbackfn, const _Any& thisArg);
		Node* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Node*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::Node*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static NodeList* prototype;
		NodeList();
	public:
		using client::Object::operator[];
	};
	template<class _T0>
	class NodeListOf: public NodeList {
		static_assert(cheerp::CanCast<_T0, Node*>);
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		_T0 item(double index);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(_T0, double, NodeListOf<_T0>*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(_T0, double, NodeListOf<_T0>*)>& callbackfn, const _Any& thisArg);
		_T0 operator[](double index) const;
#ifndef LEAN_CXX_LIB
		_T0& operator[](double index) {
			return __builtin_cheerp_make_regular<_T0>(this, 0)[static_cast<int>(index)];
		}
#endif
	public:
		using client::NodeList::operator[];
		using client::Object::operator[];
	};
	class NotificationEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"click\""))]]
		Event* get__34_click_34_();
		[[cheerp::interface_name(("set_\"click\""))]]
		void set__34_click_34_(Event* _34_click_34_);
		[[cheerp::interface_name(("get_\"close\""))]]
		Event* get__34_close_34_();
		[[cheerp::interface_name(("set_\"close\""))]]
		void set__34_close_34_(Event* _34_close_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"show\""))]]
		Event* get__34_show_34_();
		[[cheerp::interface_name(("set_\"show\""))]]
		void set__34_show_34_(Event* _34_show_34_);
	};
	class Notification: public EventTarget {
	public:
		String* get_body();
		Object* get_data();
		String* get_dir();
		String* get_icon();
		String* get_lang();
		_Function<_Any*(Event*)>* get_onclick();
		void set_onclick(EventListener* onclick);
		void set_onclick(const _Function<_Any*(Event*)>& onclick);
		_Function<_Any*(Event*)>* get_onclose();
		void set_onclose(EventListener* onclose);
		void set_onclose(const _Function<_Any*(Event*)>& onclose);
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(Event*)>* get_onshow();
		void set_onshow(EventListener* onshow);
		void set_onshow(const _Function<_Any*(Event*)>& onshow);
		bool get_silent();
		String* get_tag();
		String* get_title();
		void close();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static Notification* prototype;
		Notification(const String& title);
		Notification(const String& title, NotificationOptions* options);
		static String* permission;
	};
	class OES_draw_buffers_indexed: public Object {
	public:
		void blendEquationSeparateiOES(double buf, double modeRGB, double modeAlpha);
		void blendEquationiOES(double buf, double mode);
		void blendFuncSeparateiOES(double buf, double srcRGB, double dstRGB, double srcAlpha, double dstAlpha);
		void blendFunciOES(double buf, double src, double dst);
		void colorMaskiOES(double buf, bool r, bool g, bool b, bool a);
		void disableiOES(double target, double index);
		void enableiOES(double target, double index);
	};
	class OES_element_index_uint: public Object {
	};
	class OES_fbo_render_mipmap: public Object {
	};
	class OES_standard_derivatives: public Object {
	public:
		double get_FRAGMENT_SHADER_DERIVATIVE_HINT_OES();
	};
	class OES_texture_float: public Object {
	};
	class OES_texture_float_linear: public Object {
	};
	class OES_texture_half_float: public Object {
	public:
		double get_HALF_FLOAT_OES();
	};
	class OES_texture_half_float_linear: public Object {
	};
	class WebGLVertexArrayObjectOES;
	class OES_vertex_array_object: public Object {
	public:
		void bindVertexArrayOES(WebGLVertexArrayObjectOES* arrayObject);
		WebGLVertexArrayObjectOES* createVertexArrayOES();
		void deleteVertexArrayOES(WebGLVertexArrayObjectOES* arrayObject);
		bool isVertexArrayOES(WebGLVertexArrayObjectOES* arrayObject);
		double get_VERTEX_ARRAY_BINDING_OES();
	};
	class WebGLTexture;
	class OVR_multiview2: public Object {
	public:
		void framebufferTextureMultiviewOVR(double target, double attachment, WebGLTexture* texture, double level, double baseViewIndex, double numViews);
		double get_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR();
		double get_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR();
		double get_MAX_VIEWS_OVR();
		double get_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR();
	};
	class OfflineAudioCompletionEvent: public Event {
	public:
		AudioBuffer* get_renderedBuffer();
		static OfflineAudioCompletionEvent* prototype;
		OfflineAudioCompletionEvent(const String& type, OfflineAudioCompletionEventInit* eventInitDict);
	};
	class OfflineAudioContextEventMap: public BaseAudioContextEventMap {
	public:
		[[cheerp::interface_name(("get_\"complete\""))]]
		OfflineAudioCompletionEvent* get__34_complete_34_();
		[[cheerp::interface_name(("set_\"complete\""))]]
		void set__34_complete_34_(OfflineAudioCompletionEvent* _34_complete_34_);
	};
	class OfflineAudioContext: public BaseAudioContext {
	public:
		int get_length() const;
		_Function<_Any*(OfflineAudioCompletionEvent*)>* get_oncomplete();
		void set_oncomplete(EventListener* oncomplete);
		void set_oncomplete(const _Function<_Any*(OfflineAudioCompletionEvent*)>& oncomplete);
		Promise<_Any*>* resume();
		Promise<AudioBuffer*>* startRendering();
		Promise<_Any*>* suspend(double suspendTime);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static OfflineAudioContext* prototype;
		OfflineAudioContext(OfflineAudioContextOptions* contextOptions);
		OfflineAudioContext(double numberOfChannels, double length, double sampleRate);
	};
	class OffscreenCanvasEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"contextlost\""))]]
		Event* get__34_contextlost_34_();
		[[cheerp::interface_name(("set_\"contextlost\""))]]
		void set__34_contextlost_34_(Event* _34_contextlost_34_);
		[[cheerp::interface_name(("get_\"contextrestored\""))]]
		Event* get__34_contextrestored_34_();
		[[cheerp::interface_name(("set_\"contextrestored\""))]]
		void set__34_contextrestored_34_(Event* _34_contextrestored_34_);
	};
	class OffscreenCanvasRenderingContext2D;
	class OffscreenCanvas: public EventTarget {
	public:
		double get_height();
		void set_height(double height);
		_Function<_Any*(Event*)>* get_oncontextlost();
		void set_oncontextlost(EventListener* oncontextlost);
		void set_oncontextlost(const _Function<_Any*(Event*)>& oncontextlost);
		_Function<_Any*(Event*)>* get_oncontextrestored();
		void set_oncontextrestored(EventListener* oncontextrestored);
		void set_oncontextrestored(const _Function<_Any*(Event*)>& oncontextrestored);
		double get_width();
		void set_width(double width);
		Promise<Blob*>* convertToBlob();
		Promise<Blob*>* convertToBlob(ImageEncodeOptions* options);
		_Union<OffscreenCanvasRenderingContext2D*, ImageBitmapRenderingContext*, WebGLRenderingContext*, WebGL2RenderingContext*>* getContext(const String& contextId);
		_Union<OffscreenCanvasRenderingContext2D*, ImageBitmapRenderingContext*, WebGLRenderingContext*, WebGL2RenderingContext*>* getContext(const String& contextId, const _Any& options);
		ImageBitmap* transferToImageBitmap();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static OffscreenCanvas* prototype;
		OffscreenCanvas(double width, double height);
	};
	class OffscreenCanvasRenderingContext2D: public CanvasCompositing, public CanvasDrawImage, public CanvasDrawPath, public CanvasFillStrokeStyles, public CanvasFilters, public CanvasImageData, public CanvasImageSmoothing, public CanvasPath, public CanvasPathDrawingStyles, public CanvasRect, public CanvasShadowStyles, public CanvasState, public CanvasText, public CanvasTextDrawingStyles, public CanvasTransform {
	public:
		OffscreenCanvas* get_canvas();
		void commit();
		static OffscreenCanvasRenderingContext2D* prototype;
		OffscreenCanvasRenderingContext2D();
	};
	class OscillatorNode: public AudioScheduledSourceNode {
	public:
		AudioParam* get_detune();
		AudioParam* get_frequency();
		String* get_type();
		void set_type(const String& type);
		void setPeriodicWave(PeriodicWave* periodicWave);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static OscillatorNode* prototype;
		OscillatorNode(BaseAudioContext* context);
		OscillatorNode(BaseAudioContext* context, OscillatorOptions* options);
	};
	class OverconstrainedError: public Error {
	public:
		String* get_constraint();
		static OverconstrainedError* prototype;
		OverconstrainedError(const String& constraint);
		OverconstrainedError(const String& constraint, const String& message);
	};
	class PageTransitionEvent: public Event {
	public:
		bool get_persisted();
		static PageTransitionEvent* prototype;
		PageTransitionEvent(const String& type);
		PageTransitionEvent(const String& type, PageTransitionEventInit* eventInitDict);
	};
	class PannerNode: public AudioNode {
	public:
		double get_coneInnerAngle();
		void set_coneInnerAngle(double coneInnerAngle);
		double get_coneOuterAngle();
		void set_coneOuterAngle(double coneOuterAngle);
		double get_coneOuterGain();
		void set_coneOuterGain(double coneOuterGain);
		String* get_distanceModel();
		void set_distanceModel(const String& distanceModel);
		double get_maxDistance();
		void set_maxDistance(double maxDistance);
		AudioParam* get_orientationX();
		AudioParam* get_orientationY();
		AudioParam* get_orientationZ();
		String* get_panningModel();
		void set_panningModel(const String& panningModel);
		AudioParam* get_positionX();
		AudioParam* get_positionY();
		AudioParam* get_positionZ();
		double get_refDistance();
		void set_refDistance(double refDistance);
		double get_rolloffFactor();
		void set_rolloffFactor(double rolloffFactor);
		void setOrientation(double x, double y, double z);
		void setPosition(double x, double y, double z);
		static PannerNode* prototype;
		PannerNode(BaseAudioContext* context);
		PannerNode(BaseAudioContext* context, PannerOptions* options);
	};
	class Path2D: public CanvasPath {
	public:
		void addPath(Path2D* path);
		void addPath(Path2D* path, DOMMatrix2DInit* transform);
		static Path2D* prototype;
		Path2D();
		Path2D(const String& path);
		Path2D(Path2D* path);
	};
	class PaymentRequestUpdateEvent: public Event {
	public:
		void updateWith(const _Union<PaymentDetailsUpdate*, PromiseLike<PaymentDetailsUpdate*>*>& detailsPromise);
		static PaymentRequestUpdateEvent* prototype;
		PaymentRequestUpdateEvent(const String& type);
		PaymentRequestUpdateEvent(const String& type, PaymentRequestUpdateEventInit* eventInitDict);
	};
	class PaymentMethodChangeEvent: public PaymentRequestUpdateEvent {
	public:
		Object* get_methodDetails();
		String* get_methodName();
		static PaymentMethodChangeEvent* prototype;
		PaymentMethodChangeEvent(const String& type);
		PaymentMethodChangeEvent(const String& type, PaymentMethodChangeEventInit* eventInitDict);
	};
	class PaymentRequestEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"paymentmethodchange\""))]]
		Event* get__34_paymentmethodchange_34_();
		[[cheerp::interface_name(("set_\"paymentmethodchange\""))]]
		void set__34_paymentmethodchange_34_(Event* _34_paymentmethodchange_34_);
	};
	class PaymentResponse;
	class PaymentRequest: public EventTarget {
	public:
		String* get_id();
		_Function<_Any*(Event*)>* get_onpaymentmethodchange();
		void set_onpaymentmethodchange(EventListener* onpaymentmethodchange);
		void set_onpaymentmethodchange(const _Function<_Any*(Event*)>& onpaymentmethodchange);
		Promise<_Any*>* abort();
		Promise<bool>* canMakePayment();
		Promise<PaymentResponse*>* show();
		Promise<PaymentResponse*>* show(const _Union<PaymentDetailsUpdate*, PromiseLike<PaymentDetailsUpdate*>*>& detailsPromise);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static PaymentRequest* prototype;
		PaymentRequest(TArray<PaymentMethodData*>* methodData, PaymentDetailsInit* details);
	};
	class PaymentResponse: public EventTarget {
	public:
		Object* get_details();
		String* get_methodName();
		String* get_requestId();
		Promise<_Any*>* complete();
		Promise<_Any*>* complete(const String& result);
		Promise<_Any*>* retry();
		Promise<_Any*>* retry(PaymentValidationErrors* errorFields);
		Object* toJSON();
		static PaymentResponse* prototype;
		PaymentResponse();
	};
	class PerformanceEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"resourcetimingbufferfull\""))]]
		Event* get__34_resourcetimingbufferfull_34_();
		[[cheerp::interface_name(("set_\"resourcetimingbufferfull\""))]]
		void set__34_resourcetimingbufferfull_34_(Event* _34_resourcetimingbufferfull_34_);
	};
	class PerformanceNavigation;
	class PerformanceTiming;
	class PerformanceEntry;
	class PerformanceMark;
	class PerformanceMeasure;
	class Performance: public EventTarget {
	public:
		EventCounts* get_eventCounts();
		PerformanceNavigation* get_navigation();
		_Function<_Any*(Event*)>* get_onresourcetimingbufferfull();
		void set_onresourcetimingbufferfull(EventListener* onresourcetimingbufferfull);
		void set_onresourcetimingbufferfull(const _Function<_Any*(Event*)>& onresourcetimingbufferfull);
		double get_timeOrigin();
		PerformanceTiming* get_timing();
		void clearMarks();
		void clearMarks(const String& markName);
		void clearMeasures();
		void clearMeasures(const String& measureName);
		void clearResourceTimings();
		TArray<PerformanceEntry*>* getEntries();
		TArray<PerformanceEntry*>* getEntriesByName(const String& name);
		TArray<PerformanceEntry*>* getEntriesByName(const String& name, const String& type);
		TArray<PerformanceEntry*>* getEntriesByType(const String& type);
		PerformanceMark* mark(const String& markName);
		PerformanceMark* mark(const String& markName, PerformanceMarkOptions* markOptions);
		PerformanceMeasure* measure(const String& measureName);
		PerformanceMeasure* measure(const String& measureName, const String& startOrMeasureOptions);
		PerformanceMeasure* measure(const String& measureName, PerformanceMeasureOptions* startOrMeasureOptions);
		PerformanceMeasure* measure(const String& measureName, const String& startOrMeasureOptions, const String& endMark);
		PerformanceMeasure* measure(const String& measureName, PerformanceMeasureOptions* startOrMeasureOptions, const String& endMark);
		double now();
		void setResourceTimingBufferSize(double maxSize);
		Object* toJSON();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static Performance* prototype;
		Performance();
	};
	class PerformanceEntry: public Object {
	public:
		double get_duration();
		String* get_entryType();
		String* get_name();
		double get_startTime();
		Object* toJSON();
		static PerformanceEntry* prototype;
		PerformanceEntry();
	};
	class PerformanceEventTiming: public PerformanceEntry {
	public:
		bool get_cancelable();
		double get_processingEnd();
		double get_processingStart();
		Node* get_target();
		Object* toJSON();
		static PerformanceEventTiming* prototype;
		PerformanceEventTiming();
	};
	class PerformanceMark: public PerformanceEntry {
	public:
		Object* get_detail();
		static PerformanceMark* prototype;
		PerformanceMark(const String& markName);
		PerformanceMark(const String& markName, PerformanceMarkOptions* markOptions);
	};
	class PerformanceMeasure: public PerformanceEntry {
	public:
		Object* get_detail();
		static PerformanceMeasure* prototype;
		PerformanceMeasure();
	};
	class PerformanceNavigation: public Object {
	public:
		double get_redirectCount();
		double get_type();
		Object* toJSON();
		double get_TYPE_NAVIGATE();
		double get_TYPE_RELOAD();
		double get_TYPE_BACK_FORWARD();
		double get_TYPE_RESERVED();
		static PerformanceNavigation* prototype;
		PerformanceNavigation();
		static double TYPE_NAVIGATE;
		static double TYPE_RELOAD;
		static double TYPE_BACK_FORWARD;
		static double TYPE_RESERVED;
	};
	class PerformanceServerTiming;
	class PerformanceResourceTiming: public PerformanceEntry {
	public:
		double get_connectEnd();
		double get_connectStart();
		double get_decodedBodySize();
		double get_domainLookupEnd();
		double get_domainLookupStart();
		double get_encodedBodySize();
		double get_fetchStart();
		String* get_initiatorType();
		String* get_nextHopProtocol();
		double get_redirectEnd();
		double get_redirectStart();
		double get_requestStart();
		double get_responseEnd();
		double get_responseStart();
		double get_secureConnectionStart();
		ReadonlyArray<PerformanceServerTiming*>* get_serverTiming();
		double get_transferSize();
		double get_workerStart();
		Object* toJSON();
		static PerformanceResourceTiming* prototype;
		PerformanceResourceTiming();
	};
	class PerformanceNavigationTiming: public PerformanceResourceTiming {
	public:
		double get_domComplete();
		double get_domContentLoadedEventEnd();
		double get_domContentLoadedEventStart();
		double get_domInteractive();
		double get_loadEventEnd();
		double get_loadEventStart();
		double get_redirectCount();
		String* get_type();
		double get_unloadEventEnd();
		double get_unloadEventStart();
		Object* toJSON();
		static PerformanceNavigationTiming* prototype;
		PerformanceNavigationTiming();
	};
	class PerformanceObserverEntryList;
	class PerformanceObserver: public Object {
	public:
		void disconnect();
		void observe();
		void observe(PerformanceObserverInit* options);
		TArray<PerformanceEntry*>* takeRecords();
		static PerformanceObserver* prototype;
		PerformanceObserver(EventListener* callback);
		PerformanceObserver(const _Function<void(PerformanceObserverEntryList*, PerformanceObserver*)>& callback);
		static ReadonlyArray<String*>* supportedEntryTypes;
	};
	class PerformanceObserverEntryList: public Object {
	public:
		TArray<PerformanceEntry*>* getEntries();
		TArray<PerformanceEntry*>* getEntriesByName(const String& name);
		TArray<PerformanceEntry*>* getEntriesByName(const String& name, const String& type);
		TArray<PerformanceEntry*>* getEntriesByType(const String& type);
		static PerformanceObserverEntryList* prototype;
		PerformanceObserverEntryList();
	};
	class PerformancePaintTiming: public PerformanceEntry {
	public:
		static PerformancePaintTiming* prototype;
		PerformancePaintTiming();
	};
	class PerformanceServerTiming: public Object {
	public:
		String* get_description();
		double get_duration();
		String* get_name();
		Object* toJSON();
		static PerformanceServerTiming* prototype;
		PerformanceServerTiming();
	};
	class PerformanceTiming: public Object {
	public:
		double get_connectEnd();
		double get_connectStart();
		double get_domComplete();
		double get_domContentLoadedEventEnd();
		double get_domContentLoadedEventStart();
		double get_domInteractive();
		double get_domLoading();
		double get_domainLookupEnd();
		double get_domainLookupStart();
		double get_fetchStart();
		double get_loadEventEnd();
		double get_loadEventStart();
		double get_navigationStart();
		double get_redirectEnd();
		double get_redirectStart();
		double get_requestStart();
		double get_responseEnd();
		double get_responseStart();
		double get_secureConnectionStart();
		double get_unloadEventEnd();
		double get_unloadEventStart();
		Object* toJSON();
		static PerformanceTiming* prototype;
		PerformanceTiming();
	};
	class PeriodicWave: public Object {
	public:
		static PeriodicWave* prototype;
		PeriodicWave(BaseAudioContext* context);
		PeriodicWave(BaseAudioContext* context, PeriodicWaveOptions* options);
	};
	class PermissionStatusEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"change\""))]]
		Event* get__34_change_34_();
		[[cheerp::interface_name(("set_\"change\""))]]
		void set__34_change_34_(Event* _34_change_34_);
	};
	class PermissionStatus: public EventTarget {
	public:
		String* get_name();
		_Function<_Any*(Event*)>* get_onchange();
		void set_onchange(EventListener* onchange);
		void set_onchange(const _Function<_Any*(Event*)>& onchange);
		String* get_state();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static PermissionStatus* prototype;
		PermissionStatus();
	};
	class Permissions: public Object {
	public:
		Promise<PermissionStatus*>* query(PermissionDescriptor* permissionDesc);
		static Permissions* prototype;
		Permissions();
	};
	class PictureInPictureEvent: public Event {
	public:
		PictureInPictureWindow* get_pictureInPictureWindow();
		static PictureInPictureEvent* prototype;
		PictureInPictureEvent(const String& type, PictureInPictureEventInit* eventInitDict);
	};
	class PictureInPictureWindowEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"resize\""))]]
		Event* get__34_resize_34_();
		[[cheerp::interface_name(("set_\"resize\""))]]
		void set__34_resize_34_(Event* _34_resize_34_);
	};
	class PictureInPictureWindow: public EventTarget {
	public:
		double get_height();
		_Function<_Any*(Event*)>* get_onresize();
		void set_onresize(EventListener* onresize);
		void set_onresize(const _Function<_Any*(Event*)>& onresize);
		double get_width();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static PictureInPictureWindow* prototype;
		PictureInPictureWindow();
	};
	class Plugin: public Object {
	public:
		String* get_description();
		String* get_filename();
		int get_length() const;
		String* get_name();
		MimeType* item(double index);
		MimeType* namedItem(const String& name);
		MimeType* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		MimeType*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::MimeType*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static Plugin* prototype;
		Plugin();
	public:
		using client::Object::operator[];
	};
	class PluginArray: public Object {
	public:
		int get_length() const;
		Plugin* item(double index);
		Plugin* namedItem(const String& name);
		void refresh();
		Plugin* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Plugin*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::Plugin*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static PluginArray* prototype;
		PluginArray();
	public:
		using client::Object::operator[];
	};
	class PointerEvent: public MouseEvent {
	public:
		double get_height();
		bool get_isPrimary();
		double get_pointerId();
		String* get_pointerType();
		double get_pressure();
		double get_tangentialPressure();
		double get_tiltX();
		double get_tiltY();
		double get_twist();
		double get_width();
		TArray<PointerEvent*>* getCoalescedEvents();
		TArray<PointerEvent*>* getPredictedEvents();
		static PointerEvent* prototype;
		PointerEvent(const String& type);
		PointerEvent(const String& type, PointerEventInit* eventInitDict);
	};
	class PopStateEvent: public Event {
	public:
		Object* get_state();
		static PopStateEvent* prototype;
		PopStateEvent(const String& type);
		PopStateEvent(const String& type, PopStateEventInit* eventInitDict);
	};
	class ProcessingInstruction: public CharacterData, public LinkStyle {
	public:
		Document* get_ownerDocument();
		String* get_target();
		static ProcessingInstruction* prototype;
		ProcessingInstruction();
	};
	template<class _T0>
	class ProgressEvent: public Event {
		static_assert(cheerp::CanCast<_T0, EventTarget*>);
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool get_lengthComputable();
		double get_loaded();
		_T0 get_target();
		double get_total();
		static ProgressEvent<EventTarget*>* prototype;
		ProgressEvent(const String& type);
		ProgressEvent(const String& type, ProgressEventInit* eventInitDict);
	};
	class PromiseRejectionEvent: public Event {
	public:
		Promise<_Any*>* get_promise();
		Object* get_reason();
		static PromiseRejectionEvent* prototype;
		PromiseRejectionEvent(const String& type, PromiseRejectionEventInit* eventInitDict);
	};
	class PublicKeyCredential: public Credential {
	public:
		String* get_authenticatorAttachment();
		ArrayBuffer* get_rawId();
		AuthenticatorResponse* get_response();
		AuthenticationExtensionsClientOutputs* getClientExtensionResults();
		static PublicKeyCredential* prototype;
		PublicKeyCredential();
		static Promise<bool>* isConditionalMediationAvailable();
		static Promise<bool>* isUserVerifyingPlatformAuthenticatorAvailable();
	};
	class PushSubscription;
	class PushManager: public Object {
	public:
		Promise<PushSubscription*>* getSubscription();
		Promise<String*>* permissionState();
		Promise<String*>* permissionState(PushSubscriptionOptionsInit* options);
		Promise<PushSubscription*>* subscribe();
		Promise<PushSubscription*>* subscribe(PushSubscriptionOptionsInit* options);
		static PushManager* prototype;
		PushManager();
		static ReadonlyArray<String*>* supportedContentEncodings;
	};
	class PushSubscriptionOptions;
	class PushSubscription: public Object {
	public:
		String* get_endpoint();
		double get_expirationTime();
		PushSubscriptionOptions* get_options();
		ArrayBuffer* getKey(const String& name);
		PushSubscriptionJSON* toJSON();
		Promise<bool>* unsubscribe();
		static PushSubscription* prototype;
		PushSubscription();
	};
	class PushSubscriptionOptions: public Object {
	public:
		ArrayBuffer* get_applicationServerKey();
		bool get_userVisibleOnly();
		static PushSubscriptionOptions* prototype;
		PushSubscriptionOptions();
	};
	class RTCCertificate: public Object {
	public:
		double get_expires();
		TArray<RTCDtlsFingerprint*>* getFingerprints();
		static RTCCertificate* prototype;
		RTCCertificate();
	};
	class RTCDTMFSenderEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"tonechange\""))]]
		RTCDTMFToneChangeEvent* get__34_tonechange_34_();
		[[cheerp::interface_name(("set_\"tonechange\""))]]
		void set__34_tonechange_34_(RTCDTMFToneChangeEvent* _34_tonechange_34_);
	};
	class RTCDTMFSender: public EventTarget {
	public:
		bool get_canInsertDTMF();
		_Function<_Any*(RTCDTMFToneChangeEvent*)>* get_ontonechange();
		void set_ontonechange(EventListener* ontonechange);
		void set_ontonechange(const _Function<_Any*(RTCDTMFToneChangeEvent*)>& ontonechange);
		String* get_toneBuffer();
		void insertDTMF(const String& tones);
		void insertDTMF(const String& tones, double duration);
		void insertDTMF(const String& tones, double duration, double interToneGap);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static RTCDTMFSender* prototype;
		RTCDTMFSender();
	};
	class RTCDTMFToneChangeEvent: public Event {
	public:
		String* get_tone();
		static RTCDTMFToneChangeEvent* prototype;
		RTCDTMFToneChangeEvent(const String& type);
		RTCDTMFToneChangeEvent(const String& type, RTCDTMFToneChangeEventInit* eventInitDict);
	};
	class RTCDataChannelEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"bufferedamountlow\""))]]
		Event* get__34_bufferedamountlow_34_();
		[[cheerp::interface_name(("set_\"bufferedamountlow\""))]]
		void set__34_bufferedamountlow_34_(Event* _34_bufferedamountlow_34_);
		[[cheerp::interface_name(("get_\"close\""))]]
		Event* get__34_close_34_();
		[[cheerp::interface_name(("set_\"close\""))]]
		void set__34_close_34_(Event* _34_close_34_);
		[[cheerp::interface_name(("get_\"closing\""))]]
		Event* get__34_closing_34_();
		[[cheerp::interface_name(("set_\"closing\""))]]
		void set__34_closing_34_(Event* _34_closing_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"open\""))]]
		Event* get__34_open_34_();
		[[cheerp::interface_name(("set_\"open\""))]]
		void set__34_open_34_(Event* _34_open_34_);
	};
	class RTCDataChannel: public EventTarget {
	public:
		String* get_binaryType();
		void set_binaryType(const String& binaryType);
		double get_bufferedAmount();
		double get_bufferedAmountLowThreshold();
		void set_bufferedAmountLowThreshold(double bufferedAmountLowThreshold);
		double get_id();
		String* get_label();
		double get_maxPacketLifeTime();
		double get_maxRetransmits();
		bool get_negotiated();
		_Function<_Any*(Event*)>* get_onbufferedamountlow();
		void set_onbufferedamountlow(EventListener* onbufferedamountlow);
		void set_onbufferedamountlow(const _Function<_Any*(Event*)>& onbufferedamountlow);
		_Function<_Any*(Event*)>* get_onclose();
		void set_onclose(EventListener* onclose);
		void set_onclose(const _Function<_Any*(Event*)>& onclose);
		_Function<_Any*(Event*)>* get_onclosing();
		void set_onclosing(EventListener* onclosing);
		void set_onclosing(const _Function<_Any*(Event*)>& onclosing);
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(Event*)>* get_onopen();
		void set_onopen(EventListener* onopen);
		void set_onopen(const _Function<_Any*(Event*)>& onopen);
		bool get_ordered();
		String* get_protocol();
		String* get_readyState();
		void close();
		void send(const String& data);
		void send(Blob* data);
		void send(ArrayBuffer* data);
		void send(ArrayBufferView* data);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static RTCDataChannel* prototype;
		RTCDataChannel();
	};
	class RTCDataChannelEvent: public Event {
	public:
		RTCDataChannel* get_channel();
		static RTCDataChannelEvent* prototype;
		RTCDataChannelEvent(const String& type, RTCDataChannelEventInit* eventInitDict);
	};
	class RTCDtlsTransportEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"statechange\""))]]
		Event* get__34_statechange_34_();
		[[cheerp::interface_name(("set_\"statechange\""))]]
		void set__34_statechange_34_(Event* _34_statechange_34_);
	};
	class RTCIceTransport;
	class RTCDtlsTransport: public EventTarget {
	public:
		RTCIceTransport* get_iceTransport();
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(Event*)>* get_onstatechange();
		void set_onstatechange(EventListener* onstatechange);
		void set_onstatechange(const _Function<_Any*(Event*)>& onstatechange);
		String* get_state();
		TArray<ArrayBuffer*>* getRemoteCertificates();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static RTCDtlsTransport* prototype;
		RTCDtlsTransport();
	};
	class RTCEncodedAudioFrame: public Object {
	public:
		ArrayBuffer* get_data();
		void set_data(ArrayBuffer* data);
		double get_timestamp();
		RTCEncodedAudioFrameMetadata* getMetadata();
		static RTCEncodedAudioFrame* prototype;
		RTCEncodedAudioFrame();
	};
	class RTCEncodedVideoFrame: public Object {
	public:
		ArrayBuffer* get_data();
		void set_data(ArrayBuffer* data);
		double get_timestamp();
		String* get_type();
		RTCEncodedVideoFrameMetadata* getMetadata();
		static RTCEncodedVideoFrame* prototype;
		RTCEncodedVideoFrame();
	};
	class RTCError: public DOMException {
	public:
		String* get_errorDetail();
		double get_receivedAlert();
		double get_sctpCauseCode();
		double get_sdpLineNumber();
		double get_sentAlert();
		static RTCError* prototype;
		RTCError(RTCErrorInit* init);
		RTCError(RTCErrorInit* init, const String& message);
	};
	class RTCErrorEvent: public Event {
	public:
		RTCError* get_error();
		static RTCErrorEvent* prototype;
		RTCErrorEvent(const String& type, RTCErrorEventInit* eventInitDict);
	};
	class RTCIceCandidate: public Object {
	public:
		String* get_address();
		String* get_candidate();
		String* get_component();
		String* get_foundation();
		double get_port();
		double get_priority();
		String* get_protocol();
		String* get_relatedAddress();
		double get_relatedPort();
		double get_sdpMLineIndex();
		String* get_sdpMid();
		String* get_tcpType();
		String* get_type();
		String* get_usernameFragment();
		RTCIceCandidateInit* toJSON();
		static RTCIceCandidate* prototype;
		RTCIceCandidate();
		RTCIceCandidate(RTCIceCandidateInit* candidateInitDict);
	};
	class RTCIceTransportEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"gatheringstatechange\""))]]
		Event* get__34_gatheringstatechange_34_();
		[[cheerp::interface_name(("set_\"gatheringstatechange\""))]]
		void set__34_gatheringstatechange_34_(Event* _34_gatheringstatechange_34_);
		[[cheerp::interface_name(("get_\"selectedcandidatepairchange\""))]]
		Event* get__34_selectedcandidatepairchange_34_();
		[[cheerp::interface_name(("set_\"selectedcandidatepairchange\""))]]
		void set__34_selectedcandidatepairchange_34_(Event* _34_selectedcandidatepairchange_34_);
		[[cheerp::interface_name(("get_\"statechange\""))]]
		Event* get__34_statechange_34_();
		[[cheerp::interface_name(("set_\"statechange\""))]]
		void set__34_statechange_34_(Event* _34_statechange_34_);
	};
	class RTCIceTransport: public EventTarget {
	public:
		String* get_gatheringState();
		_Function<_Any*(Event*)>* get_ongatheringstatechange();
		void set_ongatheringstatechange(EventListener* ongatheringstatechange);
		void set_ongatheringstatechange(const _Function<_Any*(Event*)>& ongatheringstatechange);
		_Function<_Any*(Event*)>* get_onselectedcandidatepairchange();
		void set_onselectedcandidatepairchange(EventListener* onselectedcandidatepairchange);
		void set_onselectedcandidatepairchange(const _Function<_Any*(Event*)>& onselectedcandidatepairchange);
		_Function<_Any*(Event*)>* get_onstatechange();
		void set_onstatechange(EventListener* onstatechange);
		void set_onstatechange(const _Function<_Any*(Event*)>& onstatechange);
		String* get_state();
		RTCIceCandidatePair* getSelectedCandidatePair();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static RTCIceTransport* prototype;
		RTCIceTransport();
	};
	class RTCPeerConnectionEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"connectionstatechange\""))]]
		Event* get__34_connectionstatechange_34_();
		[[cheerp::interface_name(("set_\"connectionstatechange\""))]]
		void set__34_connectionstatechange_34_(Event* _34_connectionstatechange_34_);
		[[cheerp::interface_name(("get_\"datachannel\""))]]
		RTCDataChannelEvent* get__34_datachannel_34_();
		[[cheerp::interface_name(("set_\"datachannel\""))]]
		void set__34_datachannel_34_(RTCDataChannelEvent* _34_datachannel_34_);
		[[cheerp::interface_name(("get_\"icecandidate\""))]]
		RTCPeerConnectionIceEvent* get__34_icecandidate_34_();
		[[cheerp::interface_name(("set_\"icecandidate\""))]]
		void set__34_icecandidate_34_(RTCPeerConnectionIceEvent* _34_icecandidate_34_);
		[[cheerp::interface_name(("get_\"icecandidateerror\""))]]
		Event* get__34_icecandidateerror_34_();
		[[cheerp::interface_name(("set_\"icecandidateerror\""))]]
		void set__34_icecandidateerror_34_(Event* _34_icecandidateerror_34_);
		[[cheerp::interface_name(("get_\"iceconnectionstatechange\""))]]
		Event* get__34_iceconnectionstatechange_34_();
		[[cheerp::interface_name(("set_\"iceconnectionstatechange\""))]]
		void set__34_iceconnectionstatechange_34_(Event* _34_iceconnectionstatechange_34_);
		[[cheerp::interface_name(("get_\"icegatheringstatechange\""))]]
		Event* get__34_icegatheringstatechange_34_();
		[[cheerp::interface_name(("set_\"icegatheringstatechange\""))]]
		void set__34_icegatheringstatechange_34_(Event* _34_icegatheringstatechange_34_);
		[[cheerp::interface_name(("get_\"negotiationneeded\""))]]
		Event* get__34_negotiationneeded_34_();
		[[cheerp::interface_name(("set_\"negotiationneeded\""))]]
		void set__34_negotiationneeded_34_(Event* _34_negotiationneeded_34_);
		[[cheerp::interface_name(("get_\"signalingstatechange\""))]]
		Event* get__34_signalingstatechange_34_();
		[[cheerp::interface_name(("set_\"signalingstatechange\""))]]
		void set__34_signalingstatechange_34_(Event* _34_signalingstatechange_34_);
		[[cheerp::interface_name(("get_\"track\""))]]
		RTCTrackEvent* get__34_track_34_();
		[[cheerp::interface_name(("set_\"track\""))]]
		void set__34_track_34_(RTCTrackEvent* _34_track_34_);
	};
	class RTCSessionDescription;
	class RTCSctpTransport;
	class RTCRtpSender;
	class RTCStatsReport;
	class RTCPeerConnection: public EventTarget {
	public:
		bool get_canTrickleIceCandidates();
		String* get_connectionState();
		RTCSessionDescription* get_currentLocalDescription();
		RTCSessionDescription* get_currentRemoteDescription();
		String* get_iceConnectionState();
		String* get_iceGatheringState();
		RTCSessionDescription* get_localDescription();
		_Function<_Any*(Event*)>* get_onconnectionstatechange();
		void set_onconnectionstatechange(EventListener* onconnectionstatechange);
		void set_onconnectionstatechange(const _Function<_Any*(Event*)>& onconnectionstatechange);
		_Function<_Any*(RTCDataChannelEvent*)>* get_ondatachannel();
		void set_ondatachannel(EventListener* ondatachannel);
		void set_ondatachannel(const _Function<_Any*(RTCDataChannelEvent*)>& ondatachannel);
		_Function<_Any*(RTCPeerConnectionIceEvent*)>* get_onicecandidate();
		void set_onicecandidate(EventListener* onicecandidate);
		void set_onicecandidate(const _Function<_Any*(RTCPeerConnectionIceEvent*)>& onicecandidate);
		_Function<_Any*(Event*)>* get_onicecandidateerror();
		void set_onicecandidateerror(EventListener* onicecandidateerror);
		void set_onicecandidateerror(const _Function<_Any*(Event*)>& onicecandidateerror);
		_Function<_Any*(Event*)>* get_oniceconnectionstatechange();
		void set_oniceconnectionstatechange(EventListener* oniceconnectionstatechange);
		void set_oniceconnectionstatechange(const _Function<_Any*(Event*)>& oniceconnectionstatechange);
		_Function<_Any*(Event*)>* get_onicegatheringstatechange();
		void set_onicegatheringstatechange(EventListener* onicegatheringstatechange);
		void set_onicegatheringstatechange(const _Function<_Any*(Event*)>& onicegatheringstatechange);
		_Function<_Any*(Event*)>* get_onnegotiationneeded();
		void set_onnegotiationneeded(EventListener* onnegotiationneeded);
		void set_onnegotiationneeded(const _Function<_Any*(Event*)>& onnegotiationneeded);
		_Function<_Any*(Event*)>* get_onsignalingstatechange();
		void set_onsignalingstatechange(EventListener* onsignalingstatechange);
		void set_onsignalingstatechange(const _Function<_Any*(Event*)>& onsignalingstatechange);
		_Function<_Any*(RTCTrackEvent*)>* get_ontrack();
		void set_ontrack(EventListener* ontrack);
		void set_ontrack(const _Function<_Any*(RTCTrackEvent*)>& ontrack);
		RTCSessionDescription* get_pendingLocalDescription();
		RTCSessionDescription* get_pendingRemoteDescription();
		RTCSessionDescription* get_remoteDescription();
		RTCSctpTransport* get_sctp();
		String* get_signalingState();
		Promise<_Any*>* addIceCandidate();
		Promise<_Any*>* addIceCandidate(RTCIceCandidateInit* candidate);
		Promise<_Any*>* addIceCandidate(RTCIceCandidateInit* candidate, EventListener* successCallback, EventListener* failureCallback);
		Promise<_Any*>* addIceCandidate(RTCIceCandidateInit* candidate, const _Function<void()>& successCallback, EventListener* failureCallback);
		Promise<_Any*>* addIceCandidate(RTCIceCandidateInit* candidate, EventListener* successCallback, const _Function<void(DOMException*)>& failureCallback);
		Promise<_Any*>* addIceCandidate(RTCIceCandidateInit* candidate, const _Function<void()>& successCallback, const _Function<void(DOMException*)>& failureCallback);
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, MediaStream*> && ...), RTCRtpSender*> addTrack(MediaStreamTrack* track, _Args... streams) {
			return _addTrack(cheerp::clientCast(track), cheerp::clientCast(streams)...)->template cast<RTCRtpSender*>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("addTrack"))]]
		_Any* _addTrack(_Args... data);
	public:
		RTCRtpTransceiver* addTransceiver(const String& trackOrKind);
		RTCRtpTransceiver* addTransceiver(MediaStreamTrack* trackOrKind);
		RTCRtpTransceiver* addTransceiver(const String& trackOrKind, RTCRtpTransceiverInit* init);
		RTCRtpTransceiver* addTransceiver(MediaStreamTrack* trackOrKind, RTCRtpTransceiverInit* init);
		void close();
		Promise<RTCSessionDescriptionInit*>* createAnswer();
		Promise<RTCSessionDescriptionInit*>* createAnswer(RTCAnswerOptions* options);
		Promise<_Any*>* createAnswer(EventListener* successCallback, EventListener* failureCallback);
		Promise<_Any*>* createAnswer(const _Function<void(RTCSessionDescriptionInit*)>& successCallback, EventListener* failureCallback);
		Promise<_Any*>* createAnswer(EventListener* successCallback, const _Function<void(DOMException*)>& failureCallback);
		Promise<_Any*>* createAnswer(const _Function<void(RTCSessionDescriptionInit*)>& successCallback, const _Function<void(DOMException*)>& failureCallback);
		RTCDataChannel* createDataChannel(const String& label);
		RTCDataChannel* createDataChannel(const String& label, RTCDataChannelInit* dataChannelDict);
		Promise<RTCSessionDescriptionInit*>* createOffer();
		Promise<RTCSessionDescriptionInit*>* createOffer(RTCOfferOptions* options);
		Promise<_Any*>* createOffer(EventListener* successCallback, EventListener* failureCallback);
		Promise<_Any*>* createOffer(const _Function<void(RTCSessionDescriptionInit*)>& successCallback, EventListener* failureCallback);
		Promise<_Any*>* createOffer(EventListener* successCallback, const _Function<void(DOMException*)>& failureCallback);
		Promise<_Any*>* createOffer(const _Function<void(RTCSessionDescriptionInit*)>& successCallback, const _Function<void(DOMException*)>& failureCallback);
		Promise<_Any*>* createOffer(EventListener* successCallback, EventListener* failureCallback, RTCOfferOptions* options);
		Promise<_Any*>* createOffer(const _Function<void(RTCSessionDescriptionInit*)>& successCallback, EventListener* failureCallback, RTCOfferOptions* options);
		Promise<_Any*>* createOffer(EventListener* successCallback, const _Function<void(DOMException*)>& failureCallback, RTCOfferOptions* options);
		Promise<_Any*>* createOffer(const _Function<void(RTCSessionDescriptionInit*)>& successCallback, const _Function<void(DOMException*)>& failureCallback, RTCOfferOptions* options);
		RTCConfiguration* getConfiguration();
		TArray<RTCRtpReceiver*>* getReceivers();
		TArray<RTCRtpSender*>* getSenders();
		Promise<RTCStatsReport*>* getStats();
		Promise<RTCStatsReport*>* getStats(MediaStreamTrack* selector);
		TArray<RTCRtpTransceiver*>* getTransceivers();
		void removeTrack(RTCRtpSender* sender);
		void restartIce();
		void setConfiguration();
		void setConfiguration(RTCConfiguration* configuration);
		Promise<_Any*>* setLocalDescription();
		Promise<_Any*>* setLocalDescription(RTCLocalSessionDescriptionInit* description);
		Promise<_Any*>* setLocalDescription(RTCLocalSessionDescriptionInit* description, EventListener* successCallback, EventListener* failureCallback);
		Promise<_Any*>* setLocalDescription(RTCLocalSessionDescriptionInit* description, const _Function<void()>& successCallback, EventListener* failureCallback);
		Promise<_Any*>* setLocalDescription(RTCLocalSessionDescriptionInit* description, EventListener* successCallback, const _Function<void(DOMException*)>& failureCallback);
		Promise<_Any*>* setLocalDescription(RTCLocalSessionDescriptionInit* description, const _Function<void()>& successCallback, const _Function<void(DOMException*)>& failureCallback);
		Promise<_Any*>* setRemoteDescription(RTCSessionDescriptionInit* description);
		Promise<_Any*>* setRemoteDescription(RTCSessionDescriptionInit* description, EventListener* successCallback, EventListener* failureCallback);
		Promise<_Any*>* setRemoteDescription(RTCSessionDescriptionInit* description, const _Function<void()>& successCallback, EventListener* failureCallback);
		Promise<_Any*>* setRemoteDescription(RTCSessionDescriptionInit* description, EventListener* successCallback, const _Function<void(DOMException*)>& failureCallback);
		Promise<_Any*>* setRemoteDescription(RTCSessionDescriptionInit* description, const _Function<void()>& successCallback, const _Function<void(DOMException*)>& failureCallback);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static RTCPeerConnection* prototype;
		RTCPeerConnection();
		RTCPeerConnection(RTCConfiguration* configuration);
		static Promise<RTCCertificate*>* generateCertificate(const String& keygenAlgorithm);
		static Promise<RTCCertificate*>* generateCertificate(Algorithm* keygenAlgorithm);
	};
	class RTCPeerConnectionIceErrorEvent: public Event {
	public:
		String* get_address();
		double get_errorCode();
		String* get_errorText();
		double get_port();
		String* get_url();
		static RTCPeerConnectionIceErrorEvent* prototype;
		RTCPeerConnectionIceErrorEvent(const String& type, RTCPeerConnectionIceErrorEventInit* eventInitDict);
	};
	class RTCPeerConnectionIceEvent: public Event {
	public:
		RTCIceCandidate* get_candidate();
		static RTCPeerConnectionIceEvent* prototype;
		RTCPeerConnectionIceEvent(const String& type);
		RTCPeerConnectionIceEvent(const String& type, RTCPeerConnectionIceEventInit* eventInitDict);
	};
	class RTCRtpReceiver: public Object {
	public:
		MediaStreamTrack* get_track();
		RTCDtlsTransport* get_transport();
		TArray<RTCRtpContributingSource*>* getContributingSources();
		RTCRtpReceiveParameters* getParameters();
		Promise<RTCStatsReport*>* getStats();
		TArray<RTCRtpSynchronizationSource*>* getSynchronizationSources();
		static RTCRtpReceiver* prototype;
		RTCRtpReceiver();
		static RTCRtpCapabilities* getCapabilities(const String& kind);
	};
	class RTCRtpSender: public Object {
	public:
		RTCDTMFSender* get_dtmf();
		MediaStreamTrack* get_track();
		RTCDtlsTransport* get_transport();
		RTCRtpSendParameters* getParameters();
		Promise<RTCStatsReport*>* getStats();
		Promise<_Any*>* replaceTrack(MediaStreamTrack* withTrack);
		Promise<_Any*>* setParameters(RTCRtpSendParameters* parameters);
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, MediaStream*> && ...), void> setStreams(_Args... streams) {
			_setStreams(cheerp::clientCast(streams)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("setStreams"))]]
		_Any* _setStreams(_Args... data);
	public:
		static RTCRtpSender* prototype;
		RTCRtpSender();
		static RTCRtpCapabilities* getCapabilities(const String& kind);
	};
	class RTCRtpTransceiver: public Object {
	public:
		String* get_currentDirection();
		String* get_direction();
		void set_direction(const String& direction);
		String* get_mid();
		RTCRtpReceiver* get_receiver();
		RTCRtpSender* get_sender();
		void setCodecPreferences(TArray<RTCRtpCodecCapability*>* codecs);
		void stop();
		static RTCRtpTransceiver* prototype;
		RTCRtpTransceiver();
	};
	class RTCSctpTransportEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"statechange\""))]]
		Event* get__34_statechange_34_();
		[[cheerp::interface_name(("set_\"statechange\""))]]
		void set__34_statechange_34_(Event* _34_statechange_34_);
	};
	class RTCSctpTransport: public EventTarget {
	public:
		double get_maxChannels();
		double get_maxMessageSize();
		_Function<_Any*(Event*)>* get_onstatechange();
		void set_onstatechange(EventListener* onstatechange);
		void set_onstatechange(const _Function<_Any*(Event*)>& onstatechange);
		String* get_state();
		RTCDtlsTransport* get_transport();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static RTCSctpTransport* prototype;
		RTCSctpTransport();
	};
	class RTCSessionDescription: public Object {
	public:
		String* get_sdp();
		String* get_type();
		Object* toJSON();
		static RTCSessionDescription* prototype;
		RTCSessionDescription(RTCSessionDescriptionInit* descriptionInitDict);
	};
	class RTCStatsReport: public Object {
	public:
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(_Any*, String*, RTCStatsReport*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(_Any*, String*, RTCStatsReport*)>& callbackfn, const _Any& thisArg);
		static RTCStatsReport* prototype;
		RTCStatsReport();
	};
	class RTCTrackEvent: public Event {
	public:
		RTCRtpReceiver* get_receiver();
		ReadonlyArray<MediaStream*>* get_streams();
		MediaStreamTrack* get_track();
		RTCRtpTransceiver* get_transceiver();
		static RTCTrackEvent* prototype;
		RTCTrackEvent(const String& type, RTCTrackEventInit* eventInitDict);
	};
	class RadioNodeList: public NodeList {
	public:
		String* get_value();
		void set_value(const String& value);
		static RadioNodeList* prototype;
		RadioNodeList();
	};
	class Range: public AbstractRange {
	public:
		Node* get_commonAncestorContainer();
		DocumentFragment* cloneContents();
		Range* cloneRange();
		void collapse();
		void collapse(bool toStart);
		double compareBoundaryPoints(double how, Range* sourceRange);
		double comparePoint(Node* node, double offset);
		DocumentFragment* createContextualFragment(const String& fragment);
		void deleteContents();
		void detach();
		DocumentFragment* extractContents();
		DOMRect* getBoundingClientRect();
		DOMRectList* getClientRects();
		void insertNode(Node* node);
		bool intersectsNode(Node* node);
		bool isPointInRange(Node* node, double offset);
		void selectNode(Node* node);
		void selectNodeContents(Node* node);
		void setEnd(Node* node, double offset);
		void setEndAfter(Node* node);
		void setEndBefore(Node* node);
		void setStart(Node* node, double offset);
		void setStartAfter(Node* node);
		void setStartBefore(Node* node);
		void surroundContents(Node* newParent);
		String* toString();
		double get_START_TO_START();
		double get_START_TO_END();
		double get_END_TO_END();
		double get_END_TO_START();
		static Range* prototype;
		Range();
		static double START_TO_START;
		static double START_TO_END;
		static double END_TO_END;
		static double END_TO_START;
	};
	class ReadableStreamBYOBRequest;
	class ReadableByteStreamController: public Object {
	public:
		ReadableStreamBYOBRequest* get_byobRequest();
		double get_desiredSize();
		void close();
		void enqueue(ArrayBufferView* chunk);
		void error();
		void error(const _Any& e);
		static ReadableByteStreamController* prototype;
		ReadableByteStreamController();
	};
	class ReadableStreamBYOBReader;
	template<class _T0>
	class ReadableStreamDefaultReader;
	template<class _T0>
	class ReadableStream: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool get_locked();
		Promise<_Any*>* cancel();
		Promise<_Any*>* cancel(const _Any& reason);
		ReadableStreamBYOBReader* getReader(Object* options);
		_Union<ReadableStreamDefaultReader<_T0>*, ReadableStreamBYOBReader*>* getReader();
		_Union<ReadableStreamBYOBReader*, ReadableStreamDefaultReader<_T0>*>* getReader(ReadableStreamGetReaderOptions* options);
		template<class _T1>
		ReadableStream<_T1>* pipeThrough(ReadableWritablePair<_T1, _T0>* transform);
		template<class _T1>
		ReadableStream<_T1>* pipeThrough(ReadableWritablePair<_T1, _T0>* transform, StreamPipeOptions* options);
		Promise<_Any*>* pipeTo(WritableStream<_T0>* destination);
		Promise<_Any*>* pipeTo(WritableStream<_T0>* destination, StreamPipeOptions* options);
		Object* tee();
		static ReadableStream<_Any*>* prototype;
		ReadableStream(UnderlyingByteSource* underlyingSource);
		ReadableStream(UnderlyingByteSource* underlyingSource, Object* strategy);
		template<class _T1 = _Any*>
		ReadableStream(UnderlyingDefaultSource<_T1>* underlyingSource);
		template<class _T1 = _Any*>
		ReadableStream(UnderlyingDefaultSource<_T1>* underlyingSource, QueuingStrategy<_T1>* strategy);
		ReadableStream();
		template<class _T1 = _Any*>
		ReadableStream(UnderlyingSource<_T1>* underlyingSource);
		template<class _T1 = _Any*>
		ReadableStream(UnderlyingSource<_T1>* underlyingSource, QueuingStrategy<_T1>* strategy);
	};
	class ReadableStreamGenericReader: public Object {
	public:
		Promise<_Any*>* get_closed();
		Promise<_Any*>* cancel();
		Promise<_Any*>* cancel(const _Any& reason);
	};
	class ReadableStreamBYOBReader: public ReadableStreamGenericReader {
	public:
		template<class _T0>
		cheerp::EnableIf<cheerp::CanCast<_T0, ArrayBufferView*>, Promise<_Any*>*> read(_T0 view);
		void releaseLock();
		static ReadableStreamBYOBReader* prototype;
		ReadableStreamBYOBReader(ReadableStream<_Any*>* stream);
	};
	class ReadableStreamBYOBRequest: public Object {
	public:
		ArrayBufferView* get_view();
		void respond(double bytesWritten);
		void respondWithNewView(ArrayBufferView* view);
		static ReadableStreamBYOBRequest* prototype;
		ReadableStreamBYOBRequest();
	};
	template<class _T0>
	class ReadableStreamDefaultController: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		double get_desiredSize();
		void close();
		void enqueue();
		void enqueue(_T0 chunk);
		void error();
		void error(const _Any& e);
		static ReadableStreamDefaultController<_Any*>* prototype;
		ReadableStreamDefaultController();
	};
	template<class _T0>
	class ReadableStreamDefaultReader: public ReadableStreamGenericReader {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		Promise<_Any*>* read();
		void releaseLock();
		static ReadableStreamDefaultReader<_Any*>* prototype;
		template<class _T1 = _Any*>
		ReadableStreamDefaultReader(ReadableStream<_T1>* stream);
	};
	class RemotePlaybackEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"connect\""))]]
		Event* get__34_connect_34_();
		[[cheerp::interface_name(("set_\"connect\""))]]
		void set__34_connect_34_(Event* _34_connect_34_);
		[[cheerp::interface_name(("get_\"connecting\""))]]
		Event* get__34_connecting_34_();
		[[cheerp::interface_name(("set_\"connecting\""))]]
		void set__34_connecting_34_(Event* _34_connecting_34_);
		[[cheerp::interface_name(("get_\"disconnect\""))]]
		Event* get__34_disconnect_34_();
		[[cheerp::interface_name(("set_\"disconnect\""))]]
		void set__34_disconnect_34_(Event* _34_disconnect_34_);
	};
	class RemotePlayback: public EventTarget {
	public:
		_Function<_Any*(Event*)>* get_onconnect();
		void set_onconnect(EventListener* onconnect);
		void set_onconnect(const _Function<_Any*(Event*)>& onconnect);
		_Function<_Any*(Event*)>* get_onconnecting();
		void set_onconnecting(EventListener* onconnecting);
		void set_onconnecting(const _Function<_Any*(Event*)>& onconnecting);
		_Function<_Any*(Event*)>* get_ondisconnect();
		void set_ondisconnect(EventListener* ondisconnect);
		void set_ondisconnect(const _Function<_Any*(Event*)>& ondisconnect);
		String* get_state();
		Promise<_Any*>* cancelWatchAvailability();
		Promise<_Any*>* cancelWatchAvailability(double id);
		Promise<_Any*>* prompt();
		Promise<double>* watchAvailability(EventListener* callback);
		Promise<double>* watchAvailability(const _Function<void(bool)>& callback);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static RemotePlayback* prototype;
		RemotePlayback();
	};
	class ReportBody;
	class Report: public Object {
	public:
		ReportBody* get_body();
		String* get_type();
		String* get_url();
		Object* toJSON();
		static Report* prototype;
		Report();
	};
	class ReportBody: public Object {
	public:
		Object* toJSON();
		static ReportBody* prototype;
		ReportBody();
	};
	class ReportingObserver: public Object {
	public:
		void disconnect();
		void observe();
		TArray<Report*>* takeRecords();
		static ReportingObserver* prototype;
		ReportingObserver(EventListener* callback);
		ReportingObserver(const _Function<void(TArray<Report*>*, ReportingObserver*)>& callback);
		ReportingObserver(EventListener* callback, ReportingObserverOptions* options);
		ReportingObserver(const _Function<void(TArray<Report*>*, ReportingObserver*)>& callback, ReportingObserverOptions* options);
	};
	class Request: public Body {
	public:
		String* get_cache();
		String* get_credentials();
		String* get_destination();
		Headers* get_headers();
		String* get_integrity();
		bool get_keepalive();
		String* get_method();
		String* get_mode();
		String* get_redirect();
		String* get_referrer();
		String* get_referrerPolicy();
		AbortSignal* get_signal();
		String* get_url();
		Request* clone();
		static Request* prototype;
		Request(const String& input);
		Request(const _Union<Request*, URL*>& input);
		Request(const String& input, RequestInit* init);
		Request(const _Union<Request*, URL*>& input, RequestInit* init);
	};
	class ResizeObserverEntry;
	class ResizeObserver: public Object {
	public:
		void disconnect();
		void observe(Element* target);
		void observe(Element* target, ResizeObserverOptions* options);
		void unobserve(Element* target);
		static ResizeObserver* prototype;
		ResizeObserver(EventListener* callback);
		ResizeObserver(const _Function<void(TArray<ResizeObserverEntry*>*, ResizeObserver*)>& callback);
	};
	class ResizeObserverSize;
	class ResizeObserverEntry: public Object {
	public:
		ReadonlyArray<ResizeObserverSize*>* get_borderBoxSize();
		ReadonlyArray<ResizeObserverSize*>* get_contentBoxSize();
		DOMRectReadOnly* get_contentRect();
		ReadonlyArray<ResizeObserverSize*>* get_devicePixelContentBoxSize();
		Element* get_target();
		static ResizeObserverEntry* prototype;
		ResizeObserverEntry();
	};
	class ResizeObserverSize: public Object {
	public:
		double get_blockSize();
		double get_inlineSize();
		static ResizeObserverSize* prototype;
		ResizeObserverSize();
	};
	class Response: public Body {
	public:
		Headers* get_headers();
		bool get_ok();
		bool get_redirected();
		double get_status();
		String* get_statusText();
		String* get_type();
		String* get_url();
		Response* clone();
		static Response* prototype;
		Response();
		Response(const String& body);
		Response(const _Union<ArrayBuffer*, ArrayBufferView*, Blob*, FormData*, URLSearchParams*, ReadableStream<_Any*>*>& body);
		Response(const String& body, ResponseInit* init);
		Response(const _Union<ArrayBuffer*, ArrayBufferView*, Blob*, FormData*, URLSearchParams*, ReadableStream<_Any*>*>& body, ResponseInit* init);
		static Response* error();
		static Response* json(const _Any& data);
		static Response* json(const _Any& data, ResponseInit* init);
		static Response* redirect(const String& url);
		static Response* redirect(URL* url);
		static Response* redirect(const String& url, double status);
		static Response* redirect(URL* url, double status);
	};
	class SVGAnimatedString;
	class SVGAnimatedTransformList;
	class SVGElement: public Element, public ElementCSSInlineStyle, public GlobalEventHandlers, public HTMLOrSVGElement {
	public:
		Object* get_className();
		SVGSVGElement* get_ownerSVGElement();
		SVGElement* get_viewportElement();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGElement* prototype;
		SVGElement();
	};
	class SVGStringList;
	class SVGTests: public virtual Object {
	public:
		SVGStringList* get_requiredExtensions();
		SVGStringList* get_systemLanguage();
	};
	class SVGGraphicsElement: public SVGElement, public SVGTests {
	public:
		SVGAnimatedTransformList* get_transform();
		DOMRect* getBBox();
		DOMRect* getBBox(SVGBoundingBoxOptions* options);
		DOMMatrix* getCTM();
		DOMMatrix* getScreenCTM();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGGraphicsElement* prototype;
		SVGGraphicsElement();
	};
	class SVGURIReference: public virtual Object {
	public:
		SVGAnimatedString* get_href();
	};
	class SVGAElement: public SVGGraphicsElement, public SVGURIReference {
	public:
		String* get_rel();
		void set_rel(const String& rel);
		DOMTokenList* get_relList();
		SVGAnimatedString* get_target();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGAElement* prototype;
		SVGAElement();
	};
	class SVGAngle: public Object {
	public:
		double get_unitType();
		double get_value();
		void set_value(double value);
		String* get_valueAsString();
		void set_valueAsString(const String& valueAsString);
		double get_valueInSpecifiedUnits();
		void set_valueInSpecifiedUnits(double valueInSpecifiedUnits);
		void convertToSpecifiedUnits(double unitType);
		void newValueSpecifiedUnits(double unitType, double valueInSpecifiedUnits);
		double get_SVG_ANGLETYPE_UNKNOWN();
		double get_SVG_ANGLETYPE_UNSPECIFIED();
		double get_SVG_ANGLETYPE_DEG();
		double get_SVG_ANGLETYPE_RAD();
		double get_SVG_ANGLETYPE_GRAD();
		static SVGAngle* prototype;
		SVGAngle();
		static double SVG_ANGLETYPE_UNKNOWN;
		static double SVG_ANGLETYPE_UNSPECIFIED;
		static double SVG_ANGLETYPE_DEG;
		static double SVG_ANGLETYPE_RAD;
		static double SVG_ANGLETYPE_GRAD;
	};
	class SVGAnimationElement: public SVGElement, public SVGTests {
	public:
		SVGElement* get_targetElement();
		void beginElement();
		void beginElementAt(double offset);
		void endElement();
		void endElementAt(double offset);
		double getCurrentTime();
		double getSimpleDuration();
		double getStartTime();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGAnimationElement* prototype;
		SVGAnimationElement();
	};
	class SVGAnimateElement: public SVGAnimationElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGAnimateElement* prototype;
		SVGAnimateElement();
	};
	class SVGAnimateMotionElement: public SVGAnimationElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGAnimateMotionElement* prototype;
		SVGAnimateMotionElement();
	};
	class SVGAnimateTransformElement: public SVGAnimationElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGAnimateTransformElement* prototype;
		SVGAnimateTransformElement();
	};
	class SVGAnimatedAngle: public Object {
	public:
		SVGAngle* get_animVal();
		SVGAngle* get_baseVal();
		static SVGAnimatedAngle* prototype;
		SVGAnimatedAngle();
	};
	class SVGAnimatedBoolean: public Object {
	public:
		bool get_animVal();
		bool get_baseVal();
		void set_baseVal(bool baseVal);
		static SVGAnimatedBoolean* prototype;
		SVGAnimatedBoolean();
	};
	class SVGAnimatedEnumeration: public Object {
	public:
		double get_animVal();
		double get_baseVal();
		void set_baseVal(double baseVal);
		static SVGAnimatedEnumeration* prototype;
		SVGAnimatedEnumeration();
	};
	class SVGAnimatedInteger: public Object {
	public:
		double get_animVal();
		double get_baseVal();
		void set_baseVal(double baseVal);
		static SVGAnimatedInteger* prototype;
		SVGAnimatedInteger();
	};
	class SVGLength;
	class SVGAnimatedLength: public Object {
	public:
		SVGLength* get_animVal();
		SVGLength* get_baseVal();
		static SVGAnimatedLength* prototype;
		SVGAnimatedLength();
	};
	class SVGLengthList;
	class SVGAnimatedLengthList: public Object {
	public:
		SVGLengthList* get_animVal();
		SVGLengthList* get_baseVal();
		static SVGAnimatedLengthList* prototype;
		SVGAnimatedLengthList();
	};
	class SVGAnimatedNumber: public Object {
	public:
		double get_animVal();
		double get_baseVal();
		void set_baseVal(double baseVal);
		static SVGAnimatedNumber* prototype;
		SVGAnimatedNumber();
	};
	class SVGNumberList;
	class SVGAnimatedNumberList: public Object {
	public:
		SVGNumberList* get_animVal();
		SVGNumberList* get_baseVal();
		static SVGAnimatedNumberList* prototype;
		SVGAnimatedNumberList();
	};
	class SVGPointList;
	class SVGAnimatedPoints: public virtual Object {
	public:
		SVGPointList* get_animatedPoints();
		SVGPointList* get_points();
	};
	class SVGPreserveAspectRatio;
	class SVGAnimatedPreserveAspectRatio: public Object {
	public:
		SVGPreserveAspectRatio* get_animVal();
		SVGPreserveAspectRatio* get_baseVal();
		static SVGAnimatedPreserveAspectRatio* prototype;
		SVGAnimatedPreserveAspectRatio();
	};
	class SVGAnimatedRect: public Object {
	public:
		DOMRectReadOnly* get_animVal();
		DOMRect* get_baseVal();
		static SVGAnimatedRect* prototype;
		SVGAnimatedRect();
	};
	class SVGAnimatedString: public Object {
	public:
		String* get_animVal();
		String* get_baseVal();
		void set_baseVal(const String& baseVal);
		static SVGAnimatedString* prototype;
		SVGAnimatedString();
	};
	class SVGTransformList;
	class SVGAnimatedTransformList: public Object {
	public:
		SVGTransformList* get_animVal();
		SVGTransformList* get_baseVal();
		static SVGAnimatedTransformList* prototype;
		SVGAnimatedTransformList();
	};
	class SVGGeometryElement: public SVGGraphicsElement {
	public:
		SVGAnimatedNumber* get_pathLength();
		DOMPoint* getPointAtLength(double distance);
		double getTotalLength();
		bool isPointInFill();
		bool isPointInFill(DOMPointInit* point);
		bool isPointInStroke();
		bool isPointInStroke(DOMPointInit* point);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGGeometryElement* prototype;
		SVGGeometryElement();
	};
	class SVGCircleElement: public SVGGeometryElement {
	public:
		SVGAnimatedLength* get_cx();
		SVGAnimatedLength* get_cy();
		SVGAnimatedLength* get_r();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGCircleElement* prototype;
		SVGCircleElement();
	};
	class SVGClipPathElement: public SVGElement {
	public:
		SVGAnimatedEnumeration* get_clipPathUnits();
		SVGAnimatedTransformList* get_transform();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGClipPathElement* prototype;
		SVGClipPathElement();
	};
	class SVGComponentTransferFunctionElement: public SVGElement {
	public:
		SVGAnimatedNumber* get_amplitude();
		SVGAnimatedNumber* get_exponent();
		SVGAnimatedNumber* get_intercept();
		SVGAnimatedNumber* get_offset();
		SVGAnimatedNumber* get_slope();
		SVGAnimatedNumberList* get_tableValues();
		SVGAnimatedEnumeration* get_type();
		double get_SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN();
		double get_SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY();
		double get_SVG_FECOMPONENTTRANSFER_TYPE_TABLE();
		double get_SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE();
		double get_SVG_FECOMPONENTTRANSFER_TYPE_LINEAR();
		double get_SVG_FECOMPONENTTRANSFER_TYPE_GAMMA();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGComponentTransferFunctionElement* prototype;
		SVGComponentTransferFunctionElement();
		static double SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN;
		static double SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY;
		static double SVG_FECOMPONENTTRANSFER_TYPE_TABLE;
		static double SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE;
		static double SVG_FECOMPONENTTRANSFER_TYPE_LINEAR;
		static double SVG_FECOMPONENTTRANSFER_TYPE_GAMMA;
	};
	class SVGDefsElement: public SVGGraphicsElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGDefsElement* prototype;
		SVGDefsElement();
	};
	class SVGDescElement: public SVGElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGDescElement* prototype;
		SVGDescElement();
	};
	class SVGElementEventMap: public ElementEventMap, public GlobalEventHandlersEventMap {
	};
	class SVGEllipseElement: public SVGGeometryElement {
	public:
		SVGAnimatedLength* get_cx();
		SVGAnimatedLength* get_cy();
		SVGAnimatedLength* get_rx();
		SVGAnimatedLength* get_ry();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGEllipseElement* prototype;
		SVGEllipseElement();
	};
	class SVGFilterPrimitiveStandardAttributes: public virtual Object {
	public:
		SVGAnimatedLength* get_height();
		SVGAnimatedString* get_result();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
	};
	class SVGFEBlendElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		SVGAnimatedString* get_in2();
		SVGAnimatedEnumeration* get_mode();
		double get_SVG_FEBLEND_MODE_UNKNOWN();
		double get_SVG_FEBLEND_MODE_NORMAL();
		double get_SVG_FEBLEND_MODE_MULTIPLY();
		double get_SVG_FEBLEND_MODE_SCREEN();
		double get_SVG_FEBLEND_MODE_DARKEN();
		double get_SVG_FEBLEND_MODE_LIGHTEN();
		double get_SVG_FEBLEND_MODE_OVERLAY();
		double get_SVG_FEBLEND_MODE_COLOR_DODGE();
		double get_SVG_FEBLEND_MODE_COLOR_BURN();
		double get_SVG_FEBLEND_MODE_HARD_LIGHT();
		double get_SVG_FEBLEND_MODE_SOFT_LIGHT();
		double get_SVG_FEBLEND_MODE_DIFFERENCE();
		double get_SVG_FEBLEND_MODE_EXCLUSION();
		double get_SVG_FEBLEND_MODE_HUE();
		double get_SVG_FEBLEND_MODE_SATURATION();
		double get_SVG_FEBLEND_MODE_COLOR();
		double get_SVG_FEBLEND_MODE_LUMINOSITY();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEBlendElement* prototype;
		SVGFEBlendElement();
		static double SVG_FEBLEND_MODE_UNKNOWN;
		static double SVG_FEBLEND_MODE_NORMAL;
		static double SVG_FEBLEND_MODE_MULTIPLY;
		static double SVG_FEBLEND_MODE_SCREEN;
		static double SVG_FEBLEND_MODE_DARKEN;
		static double SVG_FEBLEND_MODE_LIGHTEN;
		static double SVG_FEBLEND_MODE_OVERLAY;
		static double SVG_FEBLEND_MODE_COLOR_DODGE;
		static double SVG_FEBLEND_MODE_COLOR_BURN;
		static double SVG_FEBLEND_MODE_HARD_LIGHT;
		static double SVG_FEBLEND_MODE_SOFT_LIGHT;
		static double SVG_FEBLEND_MODE_DIFFERENCE;
		static double SVG_FEBLEND_MODE_EXCLUSION;
		static double SVG_FEBLEND_MODE_HUE;
		static double SVG_FEBLEND_MODE_SATURATION;
		static double SVG_FEBLEND_MODE_COLOR;
		static double SVG_FEBLEND_MODE_LUMINOSITY;
	};
	class SVGFEColorMatrixElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		SVGAnimatedEnumeration* get_type();
		SVGAnimatedNumberList* get_values();
		double get_SVG_FECOLORMATRIX_TYPE_UNKNOWN();
		double get_SVG_FECOLORMATRIX_TYPE_MATRIX();
		double get_SVG_FECOLORMATRIX_TYPE_SATURATE();
		double get_SVG_FECOLORMATRIX_TYPE_HUEROTATE();
		double get_SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEColorMatrixElement* prototype;
		SVGFEColorMatrixElement();
		static double SVG_FECOLORMATRIX_TYPE_UNKNOWN;
		static double SVG_FECOLORMATRIX_TYPE_MATRIX;
		static double SVG_FECOLORMATRIX_TYPE_SATURATE;
		static double SVG_FECOLORMATRIX_TYPE_HUEROTATE;
		static double SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA;
	};
	class SVGFEComponentTransferElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEComponentTransferElement* prototype;
		SVGFEComponentTransferElement();
	};
	class SVGFECompositeElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		SVGAnimatedString* get_in2();
		SVGAnimatedNumber* get_k1();
		SVGAnimatedNumber* get_k2();
		SVGAnimatedNumber* get_k3();
		SVGAnimatedNumber* get_k4();
		[[cheerp::interface_name(("get_operator"))]]
		SVGAnimatedEnumeration* get_operator_();
		double get_SVG_FECOMPOSITE_OPERATOR_UNKNOWN();
		double get_SVG_FECOMPOSITE_OPERATOR_OVER();
		double get_SVG_FECOMPOSITE_OPERATOR_IN();
		double get_SVG_FECOMPOSITE_OPERATOR_OUT();
		double get_SVG_FECOMPOSITE_OPERATOR_ATOP();
		double get_SVG_FECOMPOSITE_OPERATOR_XOR();
		double get_SVG_FECOMPOSITE_OPERATOR_ARITHMETIC();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFECompositeElement* prototype;
		SVGFECompositeElement();
		static double SVG_FECOMPOSITE_OPERATOR_UNKNOWN;
		static double SVG_FECOMPOSITE_OPERATOR_OVER;
		static double SVG_FECOMPOSITE_OPERATOR_IN;
		static double SVG_FECOMPOSITE_OPERATOR_OUT;
		static double SVG_FECOMPOSITE_OPERATOR_ATOP;
		static double SVG_FECOMPOSITE_OPERATOR_XOR;
		static double SVG_FECOMPOSITE_OPERATOR_ARITHMETIC;
	};
	class SVGFEConvolveMatrixElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedNumber* get_bias();
		SVGAnimatedNumber* get_divisor();
		SVGAnimatedEnumeration* get_edgeMode();
		SVGAnimatedString* get_in1();
		SVGAnimatedNumberList* get_kernelMatrix();
		SVGAnimatedNumber* get_kernelUnitLengthX();
		SVGAnimatedNumber* get_kernelUnitLengthY();
		SVGAnimatedInteger* get_orderX();
		SVGAnimatedInteger* get_orderY();
		SVGAnimatedBoolean* get_preserveAlpha();
		SVGAnimatedInteger* get_targetX();
		SVGAnimatedInteger* get_targetY();
		double get_SVG_EDGEMODE_UNKNOWN();
		double get_SVG_EDGEMODE_DUPLICATE();
		double get_SVG_EDGEMODE_WRAP();
		double get_SVG_EDGEMODE_NONE();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEConvolveMatrixElement* prototype;
		SVGFEConvolveMatrixElement();
		static double SVG_EDGEMODE_UNKNOWN;
		static double SVG_EDGEMODE_DUPLICATE;
		static double SVG_EDGEMODE_WRAP;
		static double SVG_EDGEMODE_NONE;
	};
	class SVGFEDiffuseLightingElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedNumber* get_diffuseConstant();
		SVGAnimatedString* get_in1();
		SVGAnimatedNumber* get_kernelUnitLengthX();
		SVGAnimatedNumber* get_kernelUnitLengthY();
		SVGAnimatedNumber* get_surfaceScale();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEDiffuseLightingElement* prototype;
		SVGFEDiffuseLightingElement();
	};
	class SVGFEDisplacementMapElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		SVGAnimatedString* get_in2();
		SVGAnimatedNumber* get_scale();
		SVGAnimatedEnumeration* get_xChannelSelector();
		SVGAnimatedEnumeration* get_yChannelSelector();
		double get_SVG_CHANNEL_UNKNOWN();
		double get_SVG_CHANNEL_R();
		double get_SVG_CHANNEL_G();
		double get_SVG_CHANNEL_B();
		double get_SVG_CHANNEL_A();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEDisplacementMapElement* prototype;
		SVGFEDisplacementMapElement();
		static double SVG_CHANNEL_UNKNOWN;
		static double SVG_CHANNEL_R;
		static double SVG_CHANNEL_G;
		static double SVG_CHANNEL_B;
		static double SVG_CHANNEL_A;
	};
	class SVGFEDistantLightElement: public SVGElement {
	public:
		SVGAnimatedNumber* get_azimuth();
		SVGAnimatedNumber* get_elevation();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEDistantLightElement* prototype;
		SVGFEDistantLightElement();
	};
	class SVGFEDropShadowElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedNumber* get_dx();
		SVGAnimatedNumber* get_dy();
		SVGAnimatedString* get_in1();
		SVGAnimatedNumber* get_stdDeviationX();
		SVGAnimatedNumber* get_stdDeviationY();
		void setStdDeviation(double stdDeviationX, double stdDeviationY);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEDropShadowElement* prototype;
		SVGFEDropShadowElement();
	};
	class SVGFEFloodElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEFloodElement* prototype;
		SVGFEFloodElement();
	};
	class SVGFEFuncAElement: public SVGComponentTransferFunctionElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEFuncAElement* prototype;
		SVGFEFuncAElement();
	};
	class SVGFEFuncBElement: public SVGComponentTransferFunctionElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEFuncBElement* prototype;
		SVGFEFuncBElement();
	};
	class SVGFEFuncGElement: public SVGComponentTransferFunctionElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEFuncGElement* prototype;
		SVGFEFuncGElement();
	};
	class SVGFEFuncRElement: public SVGComponentTransferFunctionElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEFuncRElement* prototype;
		SVGFEFuncRElement();
	};
	class SVGFEGaussianBlurElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		SVGAnimatedNumber* get_stdDeviationX();
		SVGAnimatedNumber* get_stdDeviationY();
		void setStdDeviation(double stdDeviationX, double stdDeviationY);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEGaussianBlurElement* prototype;
		SVGFEGaussianBlurElement();
	};
	class SVGFEImageElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes, public SVGURIReference {
	public:
		SVGAnimatedPreserveAspectRatio* get_preserveAspectRatio();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEImageElement* prototype;
		SVGFEImageElement();
	};
	class SVGFEMergeElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEMergeElement* prototype;
		SVGFEMergeElement();
	};
	class SVGFEMergeNodeElement: public SVGElement {
	public:
		SVGAnimatedString* get_in1();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEMergeNodeElement* prototype;
		SVGFEMergeNodeElement();
	};
	class SVGFEMorphologyElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		[[cheerp::interface_name(("get_operator"))]]
		SVGAnimatedEnumeration* get_operator_();
		SVGAnimatedNumber* get_radiusX();
		SVGAnimatedNumber* get_radiusY();
		double get_SVG_MORPHOLOGY_OPERATOR_UNKNOWN();
		double get_SVG_MORPHOLOGY_OPERATOR_ERODE();
		double get_SVG_MORPHOLOGY_OPERATOR_DILATE();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEMorphologyElement* prototype;
		SVGFEMorphologyElement();
		static double SVG_MORPHOLOGY_OPERATOR_UNKNOWN;
		static double SVG_MORPHOLOGY_OPERATOR_ERODE;
		static double SVG_MORPHOLOGY_OPERATOR_DILATE;
	};
	class SVGFEOffsetElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedNumber* get_dx();
		SVGAnimatedNumber* get_dy();
		SVGAnimatedString* get_in1();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEOffsetElement* prototype;
		SVGFEOffsetElement();
	};
	class SVGFEPointLightElement: public SVGElement {
	public:
		SVGAnimatedNumber* get_x();
		SVGAnimatedNumber* get_y();
		SVGAnimatedNumber* get_z();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFEPointLightElement* prototype;
		SVGFEPointLightElement();
	};
	class SVGFESpecularLightingElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		SVGAnimatedNumber* get_kernelUnitLengthX();
		SVGAnimatedNumber* get_kernelUnitLengthY();
		SVGAnimatedNumber* get_specularConstant();
		SVGAnimatedNumber* get_specularExponent();
		SVGAnimatedNumber* get_surfaceScale();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFESpecularLightingElement* prototype;
		SVGFESpecularLightingElement();
	};
	class SVGFESpotLightElement: public SVGElement {
	public:
		SVGAnimatedNumber* get_limitingConeAngle();
		SVGAnimatedNumber* get_pointsAtX();
		SVGAnimatedNumber* get_pointsAtY();
		SVGAnimatedNumber* get_pointsAtZ();
		SVGAnimatedNumber* get_specularExponent();
		SVGAnimatedNumber* get_x();
		SVGAnimatedNumber* get_y();
		SVGAnimatedNumber* get_z();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFESpotLightElement* prototype;
		SVGFESpotLightElement();
	};
	class SVGFETileElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedString* get_in1();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFETileElement* prototype;
		SVGFETileElement();
	};
	class SVGFETurbulenceElement: public SVGElement, public SVGFilterPrimitiveStandardAttributes {
	public:
		SVGAnimatedNumber* get_baseFrequencyX();
		SVGAnimatedNumber* get_baseFrequencyY();
		SVGAnimatedInteger* get_numOctaves();
		SVGAnimatedNumber* get_seed();
		SVGAnimatedEnumeration* get_stitchTiles();
		SVGAnimatedEnumeration* get_type();
		double get_SVG_TURBULENCE_TYPE_UNKNOWN();
		double get_SVG_TURBULENCE_TYPE_FRACTALNOISE();
		double get_SVG_TURBULENCE_TYPE_TURBULENCE();
		double get_SVG_STITCHTYPE_UNKNOWN();
		double get_SVG_STITCHTYPE_STITCH();
		double get_SVG_STITCHTYPE_NOSTITCH();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFETurbulenceElement* prototype;
		SVGFETurbulenceElement();
		static double SVG_TURBULENCE_TYPE_UNKNOWN;
		static double SVG_TURBULENCE_TYPE_FRACTALNOISE;
		static double SVG_TURBULENCE_TYPE_TURBULENCE;
		static double SVG_STITCHTYPE_UNKNOWN;
		static double SVG_STITCHTYPE_STITCH;
		static double SVG_STITCHTYPE_NOSTITCH;
	};
	class SVGFilterElement: public SVGElement, public SVGURIReference {
	public:
		SVGAnimatedEnumeration* get_filterUnits();
		SVGAnimatedLength* get_height();
		SVGAnimatedEnumeration* get_primitiveUnits();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGFilterElement* prototype;
		SVGFilterElement();
	};
	class SVGFitToViewBox: public virtual Object {
	public:
		SVGAnimatedPreserveAspectRatio* get_preserveAspectRatio();
		SVGAnimatedRect* get_viewBox();
	};
	class SVGForeignObjectElement: public SVGGraphicsElement {
	public:
		SVGAnimatedLength* get_height();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGForeignObjectElement* prototype;
		SVGForeignObjectElement();
	};
	class SVGGElement: public SVGGraphicsElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGGElement* prototype;
		SVGGElement();
	};
	class SVGGradientElement: public SVGElement, public SVGURIReference {
	public:
		SVGAnimatedTransformList* get_gradientTransform();
		SVGAnimatedEnumeration* get_gradientUnits();
		SVGAnimatedEnumeration* get_spreadMethod();
		double get_SVG_SPREADMETHOD_UNKNOWN();
		double get_SVG_SPREADMETHOD_PAD();
		double get_SVG_SPREADMETHOD_REFLECT();
		double get_SVG_SPREADMETHOD_REPEAT();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGGradientElement* prototype;
		SVGGradientElement();
		static double SVG_SPREADMETHOD_UNKNOWN;
		static double SVG_SPREADMETHOD_PAD;
		static double SVG_SPREADMETHOD_REFLECT;
		static double SVG_SPREADMETHOD_REPEAT;
	};
	class SVGImageElement: public SVGGraphicsElement, public SVGURIReference {
	public:
		SVGAnimatedLength* get_height();
		SVGAnimatedPreserveAspectRatio* get_preserveAspectRatio();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGImageElement* prototype;
		SVGImageElement();
	};
	class SVGLength: public Object {
	public:
		double get_unitType();
		double get_value();
		void set_value(double value);
		String* get_valueAsString();
		void set_valueAsString(const String& valueAsString);
		double get_valueInSpecifiedUnits();
		void set_valueInSpecifiedUnits(double valueInSpecifiedUnits);
		void convertToSpecifiedUnits(double unitType);
		void newValueSpecifiedUnits(double unitType, double valueInSpecifiedUnits);
		double get_SVG_LENGTHTYPE_UNKNOWN();
		double get_SVG_LENGTHTYPE_NUMBER();
		double get_SVG_LENGTHTYPE_PERCENTAGE();
		double get_SVG_LENGTHTYPE_EMS();
		double get_SVG_LENGTHTYPE_EXS();
		double get_SVG_LENGTHTYPE_PX();
		double get_SVG_LENGTHTYPE_CM();
		double get_SVG_LENGTHTYPE_MM();
		double get_SVG_LENGTHTYPE_IN();
		double get_SVG_LENGTHTYPE_PT();
		double get_SVG_LENGTHTYPE_PC();
		static SVGLength* prototype;
		SVGLength();
		static double SVG_LENGTHTYPE_UNKNOWN;
		static double SVG_LENGTHTYPE_NUMBER;
		static double SVG_LENGTHTYPE_PERCENTAGE;
		static double SVG_LENGTHTYPE_EMS;
		static double SVG_LENGTHTYPE_EXS;
		static double SVG_LENGTHTYPE_PX;
		static double SVG_LENGTHTYPE_CM;
		static double SVG_LENGTHTYPE_MM;
		static double SVG_LENGTHTYPE_IN;
		static double SVG_LENGTHTYPE_PT;
		static double SVG_LENGTHTYPE_PC;
	};
	class SVGLengthList: public Object {
	public:
		int get_length() const;
		double get_numberOfItems();
		SVGLength* appendItem(SVGLength* newItem);
		void clear();
		SVGLength* getItem(double index);
		SVGLength* initialize(SVGLength* newItem);
		SVGLength* insertItemBefore(SVGLength* newItem, double index);
		SVGLength* removeItem(double index);
		SVGLength* replaceItem(SVGLength* newItem, double index);
		SVGLength* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		SVGLength*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::SVGLength*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static SVGLengthList* prototype;
		SVGLengthList();
	public:
		using client::Object::operator[];
	};
	class SVGLineElement: public SVGGeometryElement {
	public:
		SVGAnimatedLength* get_x1();
		SVGAnimatedLength* get_x2();
		SVGAnimatedLength* get_y1();
		SVGAnimatedLength* get_y2();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGLineElement* prototype;
		SVGLineElement();
	};
	class SVGLinearGradientElement: public SVGGradientElement {
	public:
		SVGAnimatedLength* get_x1();
		SVGAnimatedLength* get_x2();
		SVGAnimatedLength* get_y1();
		SVGAnimatedLength* get_y2();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGLinearGradientElement* prototype;
		SVGLinearGradientElement();
	};
	class SVGMPathElement: public SVGElement, public SVGURIReference {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGMPathElement* prototype;
		SVGMPathElement();
	};
	class SVGMarkerElement: public SVGElement, public SVGFitToViewBox {
	public:
		SVGAnimatedLength* get_markerHeight();
		SVGAnimatedEnumeration* get_markerUnits();
		SVGAnimatedLength* get_markerWidth();
		SVGAnimatedAngle* get_orientAngle();
		SVGAnimatedEnumeration* get_orientType();
		SVGAnimatedLength* get_refX();
		SVGAnimatedLength* get_refY();
		void setOrientToAngle(SVGAngle* angle);
		void setOrientToAuto();
		double get_SVG_MARKERUNITS_UNKNOWN();
		double get_SVG_MARKERUNITS_USERSPACEONUSE();
		double get_SVG_MARKERUNITS_STROKEWIDTH();
		double get_SVG_MARKER_ORIENT_UNKNOWN();
		double get_SVG_MARKER_ORIENT_AUTO();
		double get_SVG_MARKER_ORIENT_ANGLE();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGMarkerElement* prototype;
		SVGMarkerElement();
		static double SVG_MARKERUNITS_UNKNOWN;
		static double SVG_MARKERUNITS_USERSPACEONUSE;
		static double SVG_MARKERUNITS_STROKEWIDTH;
		static double SVG_MARKER_ORIENT_UNKNOWN;
		static double SVG_MARKER_ORIENT_AUTO;
		static double SVG_MARKER_ORIENT_ANGLE;
	};
	class SVGMaskElement: public SVGElement {
	public:
		SVGAnimatedLength* get_height();
		SVGAnimatedEnumeration* get_maskContentUnits();
		SVGAnimatedEnumeration* get_maskUnits();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGMaskElement* prototype;
		SVGMaskElement();
	};
	class SVGMetadataElement: public SVGElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGMetadataElement* prototype;
		SVGMetadataElement();
	};
	class SVGNumber: public Object {
	public:
		double get_value();
		void set_value(double value);
		static SVGNumber* prototype;
		SVGNumber();
	};
	class SVGNumberList: public Object {
	public:
		int get_length() const;
		double get_numberOfItems();
		SVGNumber* appendItem(SVGNumber* newItem);
		void clear();
		SVGNumber* getItem(double index);
		SVGNumber* initialize(SVGNumber* newItem);
		SVGNumber* insertItemBefore(SVGNumber* newItem, double index);
		SVGNumber* removeItem(double index);
		SVGNumber* replaceItem(SVGNumber* newItem, double index);
		SVGNumber* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		SVGNumber*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::SVGNumber*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static SVGNumberList* prototype;
		SVGNumberList();
	public:
		using client::Object::operator[];
	};
	class SVGPathElement: public SVGGeometryElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGPathElement* prototype;
		SVGPathElement();
	};
	class SVGPatternElement: public SVGElement, public SVGFitToViewBox, public SVGURIReference {
	public:
		SVGAnimatedLength* get_height();
		SVGAnimatedEnumeration* get_patternContentUnits();
		SVGAnimatedTransformList* get_patternTransform();
		SVGAnimatedEnumeration* get_patternUnits();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGPatternElement* prototype;
		SVGPatternElement();
	};
	class SVGPointList: public Object {
	public:
		int get_length() const;
		double get_numberOfItems();
		DOMPoint* appendItem(DOMPoint* newItem);
		void clear();
		DOMPoint* getItem(double index);
		DOMPoint* initialize(DOMPoint* newItem);
		DOMPoint* insertItemBefore(DOMPoint* newItem, double index);
		DOMPoint* removeItem(double index);
		DOMPoint* replaceItem(DOMPoint* newItem, double index);
		DOMPoint* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		DOMPoint*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::DOMPoint*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static SVGPointList* prototype;
		SVGPointList();
	public:
		using client::Object::operator[];
	};
	class SVGPolygonElement: public SVGGeometryElement, public SVGAnimatedPoints {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGPolygonElement* prototype;
		SVGPolygonElement();
	};
	class SVGPolylineElement: public SVGGeometryElement, public SVGAnimatedPoints {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGPolylineElement* prototype;
		SVGPolylineElement();
	};
	class SVGPreserveAspectRatio: public Object {
	public:
		double get_align();
		void set_align(double align);
		double get_meetOrSlice();
		void set_meetOrSlice(double meetOrSlice);
		double get_SVG_PRESERVEASPECTRATIO_UNKNOWN();
		double get_SVG_PRESERVEASPECTRATIO_NONE();
		double get_SVG_PRESERVEASPECTRATIO_XMINYMIN();
		double get_SVG_PRESERVEASPECTRATIO_XMIDYMIN();
		double get_SVG_PRESERVEASPECTRATIO_XMAXYMIN();
		double get_SVG_PRESERVEASPECTRATIO_XMINYMID();
		double get_SVG_PRESERVEASPECTRATIO_XMIDYMID();
		double get_SVG_PRESERVEASPECTRATIO_XMAXYMID();
		double get_SVG_PRESERVEASPECTRATIO_XMINYMAX();
		double get_SVG_PRESERVEASPECTRATIO_XMIDYMAX();
		double get_SVG_PRESERVEASPECTRATIO_XMAXYMAX();
		double get_SVG_MEETORSLICE_UNKNOWN();
		double get_SVG_MEETORSLICE_MEET();
		double get_SVG_MEETORSLICE_SLICE();
		static SVGPreserveAspectRatio* prototype;
		SVGPreserveAspectRatio();
		static double SVG_PRESERVEASPECTRATIO_UNKNOWN;
		static double SVG_PRESERVEASPECTRATIO_NONE;
		static double SVG_PRESERVEASPECTRATIO_XMINYMIN;
		static double SVG_PRESERVEASPECTRATIO_XMIDYMIN;
		static double SVG_PRESERVEASPECTRATIO_XMAXYMIN;
		static double SVG_PRESERVEASPECTRATIO_XMINYMID;
		static double SVG_PRESERVEASPECTRATIO_XMIDYMID;
		static double SVG_PRESERVEASPECTRATIO_XMAXYMID;
		static double SVG_PRESERVEASPECTRATIO_XMINYMAX;
		static double SVG_PRESERVEASPECTRATIO_XMIDYMAX;
		static double SVG_PRESERVEASPECTRATIO_XMAXYMAX;
		static double SVG_MEETORSLICE_UNKNOWN;
		static double SVG_MEETORSLICE_MEET;
		static double SVG_MEETORSLICE_SLICE;
	};
	class SVGRadialGradientElement: public SVGGradientElement {
	public:
		SVGAnimatedLength* get_cx();
		SVGAnimatedLength* get_cy();
		SVGAnimatedLength* get_fr();
		SVGAnimatedLength* get_fx();
		SVGAnimatedLength* get_fy();
		SVGAnimatedLength* get_r();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGRadialGradientElement* prototype;
		SVGRadialGradientElement();
	};
	class SVGRectElement: public SVGGeometryElement {
	public:
		SVGAnimatedLength* get_height();
		SVGAnimatedLength* get_rx();
		SVGAnimatedLength* get_ry();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGRectElement* prototype;
		SVGRectElement();
	};
	class SVGSVGElementEventMap: public SVGElementEventMap, public WindowEventHandlersEventMap {
	};
	class SVGTransform;
	class SVGSVGElement: public SVGGraphicsElement, public SVGFitToViewBox, public WindowEventHandlers {
	public:
		double get_currentScale();
		void set_currentScale(double currentScale);
		DOMPointReadOnly* get_currentTranslate();
		SVGAnimatedLength* get_height();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
		bool animationsPaused();
		bool checkEnclosure(SVGElement* element, DOMRectReadOnly* rect);
		bool checkIntersection(SVGElement* element, DOMRectReadOnly* rect);
		SVGAngle* createSVGAngle();
		SVGLength* createSVGLength();
		DOMMatrix* createSVGMatrix();
		SVGNumber* createSVGNumber();
		DOMPoint* createSVGPoint();
		DOMRect* createSVGRect();
		SVGTransform* createSVGTransform();
		SVGTransform* createSVGTransformFromMatrix();
		SVGTransform* createSVGTransformFromMatrix(DOMMatrix2DInit* matrix);
		void deselectAll();
		void forceRedraw();
		double getCurrentTime();
		Element* getElementById(const String& elementId);
		NodeListOf<_Any*>* getEnclosureList(DOMRectReadOnly* rect, SVGElement* referenceElement);
		NodeListOf<_Any*>* getIntersectionList(DOMRectReadOnly* rect, SVGElement* referenceElement);
		void pauseAnimations();
		void setCurrentTime(double seconds);
		double suspendRedraw(double maxWaitMilliseconds);
		void unpauseAnimations();
		void unsuspendRedraw(double suspendHandleID);
		void unsuspendRedrawAll();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGSVGElement* prototype;
		SVGSVGElement();
	};
	class SVGScriptElement: public SVGElement, public SVGURIReference {
	public:
		String* get_type();
		void set_type(const String& type);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGScriptElement* prototype;
		SVGScriptElement();
	};
	class SVGSetElement: public SVGAnimationElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGSetElement* prototype;
		SVGSetElement();
	};
	class SVGStopElement: public SVGElement {
	public:
		SVGAnimatedNumber* get_offset();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGStopElement* prototype;
		SVGStopElement();
	};
	class SVGStringList: public Object {
	public:
		int get_length() const;
		double get_numberOfItems();
		String* appendItem(const String& newItem);
		void clear();
		String* getItem(double index);
		String* initialize(const String& newItem);
		String* insertItemBefore(const String& newItem, double index);
		String* removeItem(double index);
		String* replaceItem(const String& newItem, double index);
		String* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		String*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::String*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static SVGStringList* prototype;
		SVGStringList();
	public:
		using client::Object::operator[];
	};
	class SVGStyleElement: public SVGElement, public LinkStyle {
	public:
		bool get_disabled();
		void set_disabled(bool disabled);
		String* get_media();
		void set_media(const String& media);
		String* get_title();
		void set_title(const String& title);
		String* get_type();
		void set_type(const String& type);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGStyleElement* prototype;
		SVGStyleElement();
	};
	class SVGSwitchElement: public SVGGraphicsElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGSwitchElement* prototype;
		SVGSwitchElement();
	};
	class SVGSymbolElement: public SVGElement, public SVGFitToViewBox {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGSymbolElement* prototype;
		SVGSymbolElement();
	};
	class SVGTextContentElement: public SVGGraphicsElement {
	public:
		SVGAnimatedEnumeration* get_lengthAdjust();
		SVGAnimatedLength* get_textLength();
		double getCharNumAtPosition();
		double getCharNumAtPosition(DOMPointInit* point);
		double getComputedTextLength();
		DOMPoint* getEndPositionOfChar(double charnum);
		DOMRect* getExtentOfChar(double charnum);
		double getNumberOfChars();
		double getRotationOfChar(double charnum);
		DOMPoint* getStartPositionOfChar(double charnum);
		double getSubStringLength(double charnum, double nchars);
		void selectSubString(double charnum, double nchars);
		double get_LENGTHADJUST_UNKNOWN();
		double get_LENGTHADJUST_SPACING();
		double get_LENGTHADJUST_SPACINGANDGLYPHS();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGTextContentElement* prototype;
		SVGTextContentElement();
		static double LENGTHADJUST_UNKNOWN;
		static double LENGTHADJUST_SPACING;
		static double LENGTHADJUST_SPACINGANDGLYPHS;
	};
	class SVGTextPositioningElement: public SVGTextContentElement {
	public:
		SVGAnimatedLengthList* get_dx();
		SVGAnimatedLengthList* get_dy();
		SVGAnimatedNumberList* get_rotate();
		SVGAnimatedLengthList* get_x();
		SVGAnimatedLengthList* get_y();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGTextPositioningElement* prototype;
		SVGTextPositioningElement();
	};
	class SVGTSpanElement: public SVGTextPositioningElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGTSpanElement* prototype;
		SVGTSpanElement();
	};
	class SVGTextElement: public SVGTextPositioningElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGTextElement* prototype;
		SVGTextElement();
	};
	class SVGTextPathElement: public SVGTextContentElement, public SVGURIReference {
	public:
		SVGAnimatedEnumeration* get_method();
		SVGAnimatedEnumeration* get_spacing();
		SVGAnimatedLength* get_startOffset();
		double get_TEXTPATH_METHODTYPE_UNKNOWN();
		double get_TEXTPATH_METHODTYPE_ALIGN();
		double get_TEXTPATH_METHODTYPE_STRETCH();
		double get_TEXTPATH_SPACINGTYPE_UNKNOWN();
		double get_TEXTPATH_SPACINGTYPE_AUTO();
		double get_TEXTPATH_SPACINGTYPE_EXACT();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGTextPathElement* prototype;
		SVGTextPathElement();
		static double TEXTPATH_METHODTYPE_UNKNOWN;
		static double TEXTPATH_METHODTYPE_ALIGN;
		static double TEXTPATH_METHODTYPE_STRETCH;
		static double TEXTPATH_SPACINGTYPE_UNKNOWN;
		static double TEXTPATH_SPACINGTYPE_AUTO;
		static double TEXTPATH_SPACINGTYPE_EXACT;
	};
	class SVGTitleElement: public SVGElement {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGTitleElement* prototype;
		SVGTitleElement();
	};
	class SVGTransform: public Object {
	public:
		double get_angle();
		DOMMatrix* get_matrix();
		double get_type();
		void setMatrix();
		void setMatrix(DOMMatrix2DInit* matrix);
		void setRotate(double angle, double cx, double cy);
		void setScale(double sx, double sy);
		void setSkewX(double angle);
		void setSkewY(double angle);
		void setTranslate(double tx, double ty);
		double get_SVG_TRANSFORM_UNKNOWN();
		double get_SVG_TRANSFORM_MATRIX();
		double get_SVG_TRANSFORM_TRANSLATE();
		double get_SVG_TRANSFORM_SCALE();
		double get_SVG_TRANSFORM_ROTATE();
		double get_SVG_TRANSFORM_SKEWX();
		double get_SVG_TRANSFORM_SKEWY();
		static SVGTransform* prototype;
		SVGTransform();
		static double SVG_TRANSFORM_UNKNOWN;
		static double SVG_TRANSFORM_MATRIX;
		static double SVG_TRANSFORM_TRANSLATE;
		static double SVG_TRANSFORM_SCALE;
		static double SVG_TRANSFORM_ROTATE;
		static double SVG_TRANSFORM_SKEWX;
		static double SVG_TRANSFORM_SKEWY;
	};
	class SVGTransformList: public Object {
	public:
		int get_length() const;
		double get_numberOfItems();
		SVGTransform* appendItem(SVGTransform* newItem);
		void clear();
		SVGTransform* consolidate();
		SVGTransform* createSVGTransformFromMatrix();
		SVGTransform* createSVGTransformFromMatrix(DOMMatrix2DInit* matrix);
		SVGTransform* getItem(double index);
		SVGTransform* initialize(SVGTransform* newItem);
		SVGTransform* insertItemBefore(SVGTransform* newItem, double index);
		SVGTransform* removeItem(double index);
		SVGTransform* replaceItem(SVGTransform* newItem, double index);
		SVGTransform* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		SVGTransform*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::SVGTransform*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static SVGTransformList* prototype;
		SVGTransformList();
	public:
		using client::Object::operator[];
	};
	class SVGUnitTypes: public Object {
	public:
		double get_SVG_UNIT_TYPE_UNKNOWN();
		double get_SVG_UNIT_TYPE_USERSPACEONUSE();
		double get_SVG_UNIT_TYPE_OBJECTBOUNDINGBOX();
		static SVGUnitTypes* prototype;
		SVGUnitTypes();
		static double SVG_UNIT_TYPE_UNKNOWN;
		static double SVG_UNIT_TYPE_USERSPACEONUSE;
		static double SVG_UNIT_TYPE_OBJECTBOUNDINGBOX;
	};
	class SVGUseElement: public SVGGraphicsElement, public SVGURIReference {
	public:
		SVGAnimatedLength* get_height();
		SVGAnimatedLength* get_width();
		SVGAnimatedLength* get_x();
		SVGAnimatedLength* get_y();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGUseElement* prototype;
		SVGUseElement();
	};
	class SVGViewElement: public SVGElement, public SVGFitToViewBox {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SVGViewElement* prototype;
		SVGViewElement();
	};
	class ScreenOrientation;
	class Screen: public Object {
	public:
		double get_availHeight();
		double get_availWidth();
		double get_colorDepth();
		double get_height();
		ScreenOrientation* get_orientation();
		double get_pixelDepth();
		double get_width();
		static Screen* prototype;
		Screen();
	};
	class ScreenOrientationEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"change\""))]]
		Event* get__34_change_34_();
		[[cheerp::interface_name(("set_\"change\""))]]
		void set__34_change_34_(Event* _34_change_34_);
	};
	class ScreenOrientation: public EventTarget {
	public:
		double get_angle();
		_Function<_Any*(Event*)>* get_onchange();
		void set_onchange(EventListener* onchange);
		void set_onchange(const _Function<_Any*(Event*)>& onchange);
		String* get_type();
		void unlock();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static ScreenOrientation* prototype;
		ScreenOrientation();
	};
	class ScriptProcessorNodeEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"audioprocess\""))]]
		AudioProcessingEvent* get__34_audioprocess_34_();
		[[cheerp::interface_name(("set_\"audioprocess\""))]]
		void set__34_audioprocess_34_(AudioProcessingEvent* _34_audioprocess_34_);
	};
	class ScriptProcessorNode: public AudioNode {
	public:
		double get_bufferSize();
		_Function<_Any*(AudioProcessingEvent*)>* get_onaudioprocess();
		void set_onaudioprocess(EventListener* onaudioprocess);
		void set_onaudioprocess(const _Function<_Any*(AudioProcessingEvent*)>& onaudioprocess);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static ScriptProcessorNode* prototype;
		ScriptProcessorNode();
	};
	class SecurityPolicyViolationEvent: public Event {
	public:
		String* get_blockedURI();
		double get_columnNumber();
		String* get_disposition();
		String* get_documentURI();
		String* get_effectiveDirective();
		double get_lineNumber();
		String* get_originalPolicy();
		String* get_referrer();
		String* get_sample();
		String* get_sourceFile();
		double get_statusCode();
		String* get_violatedDirective();
		static SecurityPolicyViolationEvent* prototype;
		SecurityPolicyViolationEvent(const String& type);
		SecurityPolicyViolationEvent(const String& type, SecurityPolicyViolationEventInit* eventInitDict);
	};
	class Selection: public Object {
	public:
		Node* get_anchorNode();
		double get_anchorOffset();
		Node* get_focusNode();
		double get_focusOffset();
		bool get_isCollapsed();
		double get_rangeCount();
		String* get_type();
		void addRange(Range* range);
		void collapse(Node* node);
		void collapse(Node* node, double offset);
		void collapseToEnd();
		void collapseToStart();
		bool containsNode(Node* node);
		bool containsNode(Node* node, bool allowPartialContainment);
		void deleteFromDocument();
		void empty();
		void extend(Node* node);
		void extend(Node* node, double offset);
		Range* getRangeAt(double index);
		void modify();
		void modify(const String& alter);
		void modify(const String& alter, const String& direction);
		void modify(const String& alter, const String& direction, const String& granularity);
		void removeAllRanges();
		void removeRange(Range* range);
		void selectAllChildren(Node* node);
		void setBaseAndExtent(Node* anchorNode, double anchorOffset, Node* focusNode, double focusOffset);
		void setPosition(Node* node);
		void setPosition(Node* node, double offset);
		String* toString();
		static Selection* prototype;
		Selection();
	};
	class ServiceWorkerEventMap: public AbstractWorkerEventMap {
	public:
		[[cheerp::interface_name(("get_\"statechange\""))]]
		Event* get__34_statechange_34_();
		[[cheerp::interface_name(("set_\"statechange\""))]]
		void set__34_statechange_34_(Event* _34_statechange_34_);
	};
	class ServiceWorker: public EventTarget, public AbstractWorker {
	public:
		_Function<_Any*(Event*)>* get_onstatechange();
		void set_onstatechange(EventListener* onstatechange);
		void set_onstatechange(const _Function<_Any*(Event*)>& onstatechange);
		String* get_scriptURL();
		String* get_state();
		void postMessage(const _Any& message, Array* transfer);
		void postMessage(const _Any& message);
		void postMessage(const _Any& message, StructuredSerializeOptions* options);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static ServiceWorker* prototype;
		ServiceWorker();
	};
	class ServiceWorkerContainerEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"controllerchange\""))]]
		Event* get__34_controllerchange_34_();
		[[cheerp::interface_name(("set_\"controllerchange\""))]]
		void set__34_controllerchange_34_(Event* _34_controllerchange_34_);
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"messageerror\""))]]
		MessageEvent<_Any*>* get__34_messageerror_34_();
		[[cheerp::interface_name(("set_\"messageerror\""))]]
		void set__34_messageerror_34_(MessageEvent<_Any*>* _34_messageerror_34_);
	};
	class ServiceWorkerRegistration;
	class ServiceWorkerContainer: public EventTarget {
	public:
		ServiceWorker* get_controller();
		_Function<_Any*(Event*)>* get_oncontrollerchange();
		void set_oncontrollerchange(EventListener* oncontrollerchange);
		void set_oncontrollerchange(const _Function<_Any*(Event*)>& oncontrollerchange);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessageerror();
		void set_onmessageerror(EventListener* onmessageerror);
		void set_onmessageerror(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessageerror);
		Promise<ServiceWorkerRegistration*>* get_ready();
		Promise<ServiceWorkerRegistration*>* getRegistration();
		Promise<ServiceWorkerRegistration*>* getRegistration(const String& clientURL);
		Promise<ServiceWorkerRegistration*>* getRegistration(URL* clientURL);
		Promise<ReadonlyArray<ServiceWorkerRegistration*>*>* getRegistrations();
		[[cheerp::interface_name(("register"))]]
		Promise<ServiceWorkerRegistration*>* register_(const String& scriptURL);
		[[cheerp::interface_name(("register"))]]
		Promise<ServiceWorkerRegistration*>* register_(URL* scriptURL);
		[[cheerp::interface_name(("register"))]]
		Promise<ServiceWorkerRegistration*>* register_(const String& scriptURL, RegistrationOptions* options);
		[[cheerp::interface_name(("register"))]]
		Promise<ServiceWorkerRegistration*>* register_(URL* scriptURL, RegistrationOptions* options);
		void startMessages();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static ServiceWorkerContainer* prototype;
		ServiceWorkerContainer();
	};
	class ServiceWorkerRegistrationEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"updatefound\""))]]
		Event* get__34_updatefound_34_();
		[[cheerp::interface_name(("set_\"updatefound\""))]]
		void set__34_updatefound_34_(Event* _34_updatefound_34_);
	};
	class ServiceWorkerRegistration: public EventTarget {
	public:
		ServiceWorker* get_active();
		ServiceWorker* get_installing();
		NavigationPreloadManager* get_navigationPreload();
		_Function<_Any*(Event*)>* get_onupdatefound();
		void set_onupdatefound(EventListener* onupdatefound);
		void set_onupdatefound(const _Function<_Any*(Event*)>& onupdatefound);
		PushManager* get_pushManager();
		String* get_scope();
		String* get_updateViaCache();
		ServiceWorker* get_waiting();
		Promise<TArray<Notification*>*>* getNotifications();
		Promise<TArray<Notification*>*>* getNotifications(GetNotificationOptions* filter);
		Promise<_Any*>* showNotification(const String& title);
		Promise<_Any*>* showNotification(const String& title, NotificationOptions* options);
		Promise<bool>* unregister();
		Promise<_Any*>* update();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static ServiceWorkerRegistration* prototype;
		ServiceWorkerRegistration();
	};
	class ShadowRootEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"slotchange\""))]]
		Event* get__34_slotchange_34_();
		[[cheerp::interface_name(("set_\"slotchange\""))]]
		void set__34_slotchange_34_(Event* _34_slotchange_34_);
	};
	class ShadowRoot: public DocumentFragment, public DocumentOrShadowRoot, public InnerHTML {
	public:
		bool get_delegatesFocus();
		Element* get_host();
		String* get_mode();
		_Function<_Any*(Event*)>* get_onslotchange();
		void set_onslotchange(EventListener* onslotchange);
		void set_onslotchange(const _Function<_Any*(Event*)>& onslotchange);
		String* get_slotAssignment();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static ShadowRoot* prototype;
		ShadowRoot();
	};
	class SharedWorker: public EventTarget, public AbstractWorker {
	public:
		MessagePort* get_port();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SharedWorker* prototype;
		SharedWorker(const String& scriptURL);
		SharedWorker(URL* scriptURL);
		SharedWorker(const String& scriptURL, const String& options);
		SharedWorker(URL* scriptURL, const String& options);
		SharedWorker(const String& scriptURL, WorkerOptions* options);
		SharedWorker(URL* scriptURL, WorkerOptions* options);
	};
	class SourceBufferEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"abort\""))]]
		Event* get__34_abort_34_();
		[[cheerp::interface_name(("set_\"abort\""))]]
		void set__34_abort_34_(Event* _34_abort_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"update\""))]]
		Event* get__34_update_34_();
		[[cheerp::interface_name(("set_\"update\""))]]
		void set__34_update_34_(Event* _34_update_34_);
		[[cheerp::interface_name(("get_\"updateend\""))]]
		Event* get__34_updateend_34_();
		[[cheerp::interface_name(("set_\"updateend\""))]]
		void set__34_updateend_34_(Event* _34_updateend_34_);
		[[cheerp::interface_name(("get_\"updatestart\""))]]
		Event* get__34_updatestart_34_();
		[[cheerp::interface_name(("set_\"updatestart\""))]]
		void set__34_updatestart_34_(Event* _34_updatestart_34_);
	};
	class SourceBuffer: public EventTarget {
	public:
		double get_appendWindowEnd();
		void set_appendWindowEnd(double appendWindowEnd);
		double get_appendWindowStart();
		void set_appendWindowStart(double appendWindowStart);
		TimeRanges* get_buffered();
		String* get_mode();
		void set_mode(const String& mode);
		_Function<_Any*(Event*)>* get_onabort();
		void set_onabort(EventListener* onabort);
		void set_onabort(const _Function<_Any*(Event*)>& onabort);
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(Event*)>* get_onupdate();
		void set_onupdate(EventListener* onupdate);
		void set_onupdate(const _Function<_Any*(Event*)>& onupdate);
		_Function<_Any*(Event*)>* get_onupdateend();
		void set_onupdateend(EventListener* onupdateend);
		void set_onupdateend(const _Function<_Any*(Event*)>& onupdateend);
		_Function<_Any*(Event*)>* get_onupdatestart();
		void set_onupdatestart(EventListener* onupdatestart);
		void set_onupdatestart(const _Function<_Any*(Event*)>& onupdatestart);
		double get_timestampOffset();
		void set_timestampOffset(double timestampOffset);
		bool get_updating();
		void abort();
		void appendBuffer(const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		void changeType(const String& type);
		void remove(double start, double end);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SourceBuffer* prototype;
		SourceBuffer();
	};
	class SourceBufferListEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"addsourcebuffer\""))]]
		Event* get__34_addsourcebuffer_34_();
		[[cheerp::interface_name(("set_\"addsourcebuffer\""))]]
		void set__34_addsourcebuffer_34_(Event* _34_addsourcebuffer_34_);
		[[cheerp::interface_name(("get_\"removesourcebuffer\""))]]
		Event* get__34_removesourcebuffer_34_();
		[[cheerp::interface_name(("set_\"removesourcebuffer\""))]]
		void set__34_removesourcebuffer_34_(Event* _34_removesourcebuffer_34_);
	};
	class SourceBufferList: public EventTarget {
	public:
		int get_length() const;
		_Function<_Any*(Event*)>* get_onaddsourcebuffer();
		void set_onaddsourcebuffer(EventListener* onaddsourcebuffer);
		void set_onaddsourcebuffer(const _Function<_Any*(Event*)>& onaddsourcebuffer);
		_Function<_Any*(Event*)>* get_onremovesourcebuffer();
		void set_onremovesourcebuffer(EventListener* onremovesourcebuffer);
		void set_onremovesourcebuffer(const _Function<_Any*(Event*)>& onremovesourcebuffer);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		SourceBuffer* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		SourceBuffer*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::SourceBuffer*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static SourceBufferList* prototype;
		SourceBufferList();
	public:
		using client::Object::operator[];
	};
	class SpeechRecognitionAlternative: public Object {
	public:
		double get_confidence();
		String* get_transcript();
		static SpeechRecognitionAlternative* prototype;
		SpeechRecognitionAlternative();
	};
	class SpeechRecognitionResult: public Object {
	public:
		bool get_isFinal();
		int get_length() const;
		SpeechRecognitionAlternative* item(double index);
		SpeechRecognitionAlternative* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		SpeechRecognitionAlternative*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::SpeechRecognitionAlternative*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static SpeechRecognitionResult* prototype;
		SpeechRecognitionResult();
	public:
		using client::Object::operator[];
	};
	class SpeechRecognitionResultList: public Object {
	public:
		int get_length() const;
		SpeechRecognitionResult* item(double index);
		SpeechRecognitionResult* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		SpeechRecognitionResult*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::SpeechRecognitionResult*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static SpeechRecognitionResultList* prototype;
		SpeechRecognitionResultList();
	public:
		using client::Object::operator[];
	};
	class SpeechSynthesisEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"voiceschanged\""))]]
		Event* get__34_voiceschanged_34_();
		[[cheerp::interface_name(("set_\"voiceschanged\""))]]
		void set__34_voiceschanged_34_(Event* _34_voiceschanged_34_);
	};
	class SpeechSynthesisVoice;
	class SpeechSynthesis: public EventTarget {
	public:
		_Function<_Any*(Event*)>* get_onvoiceschanged();
		void set_onvoiceschanged(EventListener* onvoiceschanged);
		void set_onvoiceschanged(const _Function<_Any*(Event*)>& onvoiceschanged);
		bool get_paused();
		bool get_pending();
		bool get_speaking();
		void cancel();
		TArray<SpeechSynthesisVoice*>* getVoices();
		void pause();
		void resume();
		void speak(SpeechSynthesisUtterance* utterance);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SpeechSynthesis* prototype;
		SpeechSynthesis();
	};
	class SpeechSynthesisEvent: public Event {
	public:
		double get_charIndex();
		double get_charLength();
		double get_elapsedTime();
		String* get_name();
		SpeechSynthesisUtterance* get_utterance();
		static SpeechSynthesisEvent* prototype;
		SpeechSynthesisEvent(const String& type, SpeechSynthesisEventInit* eventInitDict);
	};
	class SpeechSynthesisErrorEvent: public SpeechSynthesisEvent {
	public:
		String* get_error();
		static SpeechSynthesisErrorEvent* prototype;
		SpeechSynthesisErrorEvent(const String& type, SpeechSynthesisErrorEventInit* eventInitDict);
	};
	class SpeechSynthesisUtteranceEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"boundary\""))]]
		SpeechSynthesisEvent* get__34_boundary_34_();
		[[cheerp::interface_name(("set_\"boundary\""))]]
		void set__34_boundary_34_(SpeechSynthesisEvent* _34_boundary_34_);
		[[cheerp::interface_name(("get_\"end\""))]]
		SpeechSynthesisEvent* get__34_end_34_();
		[[cheerp::interface_name(("set_\"end\""))]]
		void set__34_end_34_(SpeechSynthesisEvent* _34_end_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		SpeechSynthesisErrorEvent* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(SpeechSynthesisErrorEvent* _34_error_34_);
		[[cheerp::interface_name(("get_\"mark\""))]]
		SpeechSynthesisEvent* get__34_mark_34_();
		[[cheerp::interface_name(("set_\"mark\""))]]
		void set__34_mark_34_(SpeechSynthesisEvent* _34_mark_34_);
		[[cheerp::interface_name(("get_\"pause\""))]]
		SpeechSynthesisEvent* get__34_pause_34_();
		[[cheerp::interface_name(("set_\"pause\""))]]
		void set__34_pause_34_(SpeechSynthesisEvent* _34_pause_34_);
		[[cheerp::interface_name(("get_\"resume\""))]]
		SpeechSynthesisEvent* get__34_resume_34_();
		[[cheerp::interface_name(("set_\"resume\""))]]
		void set__34_resume_34_(SpeechSynthesisEvent* _34_resume_34_);
		[[cheerp::interface_name(("get_\"start\""))]]
		SpeechSynthesisEvent* get__34_start_34_();
		[[cheerp::interface_name(("set_\"start\""))]]
		void set__34_start_34_(SpeechSynthesisEvent* _34_start_34_);
	};
	class SpeechSynthesisUtterance: public EventTarget {
	public:
		String* get_lang();
		void set_lang(const String& lang);
		_Function<_Any*(SpeechSynthesisEvent*)>* get_onboundary();
		void set_onboundary(EventListener* onboundary);
		void set_onboundary(const _Function<_Any*(SpeechSynthesisEvent*)>& onboundary);
		_Function<_Any*(SpeechSynthesisEvent*)>* get_onend();
		void set_onend(EventListener* onend);
		void set_onend(const _Function<_Any*(SpeechSynthesisEvent*)>& onend);
		_Function<_Any*(SpeechSynthesisErrorEvent*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(SpeechSynthesisErrorEvent*)>& onerror);
		_Function<_Any*(SpeechSynthesisEvent*)>* get_onmark();
		void set_onmark(EventListener* onmark);
		void set_onmark(const _Function<_Any*(SpeechSynthesisEvent*)>& onmark);
		_Function<_Any*(SpeechSynthesisEvent*)>* get_onpause();
		void set_onpause(EventListener* onpause);
		void set_onpause(const _Function<_Any*(SpeechSynthesisEvent*)>& onpause);
		_Function<_Any*(SpeechSynthesisEvent*)>* get_onresume();
		void set_onresume(EventListener* onresume);
		void set_onresume(const _Function<_Any*(SpeechSynthesisEvent*)>& onresume);
		_Function<_Any*(SpeechSynthesisEvent*)>* get_onstart();
		void set_onstart(EventListener* onstart);
		void set_onstart(const _Function<_Any*(SpeechSynthesisEvent*)>& onstart);
		double get_pitch();
		void set_pitch(double pitch);
		double get_rate();
		void set_rate(double rate);
		String* get_text();
		void set_text(const String& text);
		SpeechSynthesisVoice* get_voice();
		void set_voice(SpeechSynthesisVoice* voice);
		double get_volume();
		void set_volume(double volume);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SpeechSynthesisUtterance* prototype;
		SpeechSynthesisUtterance();
		SpeechSynthesisUtterance(const String& text);
	};
	class SpeechSynthesisVoice: public Object {
	public:
		[[cheerp::interface_name(("get_default"))]]
		bool get_default_();
		String* get_lang();
		bool get_localService();
		String* get_name();
		String* get_voiceURI();
		static SpeechSynthesisVoice* prototype;
		SpeechSynthesisVoice();
	};
	class StaticRange: public AbstractRange {
	public:
		static StaticRange* prototype;
		StaticRange(StaticRangeInit* init);
	};
	class StereoPannerNode: public AudioNode {
	public:
		AudioParam* get_pan();
		static StereoPannerNode* prototype;
		StereoPannerNode(BaseAudioContext* context);
		StereoPannerNode(BaseAudioContext* context, StereoPannerOptions* options);
	};
	class Storage: public Object {
	public:
		int get_length() const;
		void clear();
		String* getItem(const String& key);
		String* key(double index);
		void removeItem(const String& key);
		void setItem(const String& key, const String& value);
		Object* operator[](const String& name) const;
		static Storage* prototype;
		Storage();
	public:
		using client::Object::operator[];
	};
	class StorageEvent: public Event {
	public:
		String* get_key();
		String* get_newValue();
		String* get_oldValue();
		Storage* get_storageArea();
		String* get_url();
		void initStorageEvent(const String& type);
		void initStorageEvent(const String& type, bool bubbles);
		void initStorageEvent(const String& type, bool bubbles, bool cancelable);
		void initStorageEvent(const String& type, bool bubbles, bool cancelable, const String& key);
		void initStorageEvent(const String& type, bool bubbles, bool cancelable, const String& key, const String& oldValue);
		void initStorageEvent(const String& type, bool bubbles, bool cancelable, const String& key, const String& oldValue, const String& newValue);
		void initStorageEvent(const String& type, bool bubbles, bool cancelable, const String& key, const String& oldValue, const String& newValue, const String& url);
		void initStorageEvent(const String& type, bool bubbles, bool cancelable, const String& key, const String& oldValue, const String& newValue, URL* url);
		void initStorageEvent(const String& type, bool bubbles, bool cancelable, const String& key, const String& oldValue, const String& newValue, const String& url, Storage* storageArea);
		void initStorageEvent(const String& type, bool bubbles, bool cancelable, const String& key, const String& oldValue, const String& newValue, URL* url, Storage* storageArea);
		static StorageEvent* prototype;
		StorageEvent(const String& type);
		StorageEvent(const String& type, StorageEventInit* eventInitDict);
	};
	class StorageManager: public Object {
	public:
		Promise<StorageEstimate*>* estimate();
		Promise<FileSystemDirectoryHandle*>* getDirectory();
		Promise<bool>* persist();
		Promise<bool>* persisted();
		static StorageManager* prototype;
		StorageManager();
	};
	class StyleMedia: public Object {
	public:
		String* get_type();
		void set_type(const String& type);
		bool matchMedium(const String& mediaquery);
	};
	class StylePropertyMapReadOnly: public Object {
	public:
		int get_size() const;
		CSSStyleValue* get(const String& property);
		TArray<CSSStyleValue*>* getAll(const String& property);
		bool has(const String& property);
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(TArray<CSSStyleValue*>*, String*, StylePropertyMapReadOnly*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(TArray<CSSStyleValue*>*, String*, StylePropertyMapReadOnly*)>& callbackfn, const _Any& thisArg);
		static StylePropertyMapReadOnly* prototype;
		StylePropertyMapReadOnly();
	};
	class StylePropertyMap: public StylePropertyMapReadOnly {
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void append(const String& property, _Args... values) {
			_append(cheerp::clientCast(property), cheerp::clientCast(values)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("append"))]]
		_Any* _append(_Args... data);
	public:
		void clear();
		[[cheerp::interface_name(("delete"))]]
		void delete_(const String& property);
		template<class... _Args>
		[[gnu::always_inline]]
		void set(const String& property, _Args... values) {
			_set(cheerp::clientCast(property), cheerp::clientCast(values)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("set"))]]
		_Any* _set(_Args... data);
	public:
		static StylePropertyMap* prototype;
		StylePropertyMap();
	};
	class StyleSheetList: public Object {
	public:
		int get_length() const;
		CSSStyleSheet* item(double index);
		CSSStyleSheet* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		CSSStyleSheet*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::CSSStyleSheet*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static StyleSheetList* prototype;
		StyleSheetList();
	public:
		using client::Object::operator[];
	};
	class SubmitEvent: public Event {
	public:
		HTMLElement* get_submitter();
		static SubmitEvent* prototype;
		SubmitEvent(const String& type);
		SubmitEvent(const String& type, SubmitEventInit* eventInitDict);
	};
	class SubtleCrypto: public Object {
	public:
		Promise<ArrayBuffer*>* decrypt(const String& algorithm, CryptoKey* key, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<ArrayBuffer*>* decrypt(const _Union<AesCbcParams*, Algorithm*, AesCtrParams*, AesGcmParams*, RsaOaepParams*>& algorithm, CryptoKey* key, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<ArrayBuffer*>* deriveBits(const String& algorithm, CryptoKey* baseKey, double length);
		Promise<ArrayBuffer*>* deriveBits(const _Union<Algorithm*, EcdhKeyDeriveParams*, HkdfParams*, Pbkdf2Params*>& algorithm, CryptoKey* baseKey, double length);
		Promise<CryptoKey*>* deriveKey(const String& algorithm, CryptoKey* baseKey, const String& derivedKeyType, bool extractable, TArray<String*>* keyUsages);
		Promise<CryptoKey*>* deriveKey(const _Union<Algorithm*, EcdhKeyDeriveParams*, HkdfParams*, Pbkdf2Params*>& algorithm, CryptoKey* baseKey, const String& derivedKeyType, bool extractable, TArray<String*>* keyUsages);
		Promise<CryptoKey*>* deriveKey(const String& algorithm, CryptoKey* baseKey, const _Union<Algorithm*, AesDerivedKeyParams*, HkdfParams*, HmacImportParams*, Pbkdf2Params*>& derivedKeyType, bool extractable, TArray<String*>* keyUsages);
		Promise<CryptoKey*>* deriveKey(const _Union<Algorithm*, EcdhKeyDeriveParams*, HkdfParams*, Pbkdf2Params*>& algorithm, CryptoKey* baseKey, const _Union<Algorithm*, AesDerivedKeyParams*, HkdfParams*, HmacImportParams*, Pbkdf2Params*>& derivedKeyType, bool extractable, TArray<String*>* keyUsages);
		Promise<ArrayBuffer*>* digest(const String& algorithm, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<ArrayBuffer*>* digest(Algorithm* algorithm, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<ArrayBuffer*>* encrypt(const String& algorithm, CryptoKey* key, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<ArrayBuffer*>* encrypt(const _Union<AesCbcParams*, Algorithm*, AesCtrParams*, AesGcmParams*, RsaOaepParams*>& algorithm, CryptoKey* key, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		_Union<Promise<JsonWebKey*>*, Promise<ArrayBuffer*>*>* exportKey(const String& format, CryptoKey* key);
		_Union<Promise<CryptoKeyPair*>*, Promise<CryptoKey*>*>* generateKey(const _Union<EcKeyGenParams*, RsaHashedKeyGenParams*, AesKeyGenParams*, HmacKeyGenParams*, Pbkdf2Params*>& algorithm, bool extractable, ReadonlyArray<String*>* keyUsages);
		Promise<_Any*>* generateKey(const String& algorithm, bool extractable, TArray<String*>* keyUsages);
		Promise<_Any*>* generateKey(Algorithm* algorithm, bool extractable, TArray<String*>* keyUsages);
		Promise<CryptoKey*>* importKey(const String& format, JsonWebKey* keyData, const String& algorithm, bool extractable, ReadonlyArray<String*>* keyUsages);
		Promise<CryptoKey*>* importKey(const String& format, JsonWebKey* keyData, const _Union<Algorithm*, AesKeyAlgorithm*, EcKeyImportParams*, HmacImportParams*, RsaHashedImportParams*>& algorithm, bool extractable, ReadonlyArray<String*>* keyUsages);
		Promise<CryptoKey*>* importKey(const String& format, const _Union<ArrayBuffer*, ArrayBufferView*>& keyData, const String& algorithm, bool extractable, TArray<String*>* keyUsages);
		Promise<CryptoKey*>* importKey(const String& format, const _Union<ArrayBuffer*, ArrayBufferView*>& keyData, const _Union<Algorithm*, AesKeyAlgorithm*, EcKeyImportParams*, HmacImportParams*, RsaHashedImportParams*>& algorithm, bool extractable, TArray<String*>* keyUsages);
		Promise<ArrayBuffer*>* sign(const String& algorithm, CryptoKey* key, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<ArrayBuffer*>* sign(const _Union<Algorithm*, EcdsaParams*, RsaPssParams*>& algorithm, CryptoKey* key, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<CryptoKey*>* unwrapKey(const String& format, const _Union<ArrayBuffer*, ArrayBufferView*>& wrappedKey, CryptoKey* unwrappingKey, const String& unwrapAlgorithm, const String& unwrappedKeyAlgorithm, bool extractable, TArray<String*>* keyUsages);
		Promise<CryptoKey*>* unwrapKey(const String& format, const _Union<ArrayBuffer*, ArrayBufferView*>& wrappedKey, CryptoKey* unwrappingKey, const _Union<AesCbcParams*, Algorithm*, AesCtrParams*, AesGcmParams*, RsaOaepParams*>& unwrapAlgorithm, const String& unwrappedKeyAlgorithm, bool extractable, TArray<String*>* keyUsages);
		Promise<CryptoKey*>* unwrapKey(const String& format, const _Union<ArrayBuffer*, ArrayBufferView*>& wrappedKey, CryptoKey* unwrappingKey, const String& unwrapAlgorithm, const _Union<Algorithm*, AesKeyAlgorithm*, EcKeyImportParams*, HmacImportParams*, RsaHashedImportParams*>& unwrappedKeyAlgorithm, bool extractable, TArray<String*>* keyUsages);
		Promise<CryptoKey*>* unwrapKey(const String& format, const _Union<ArrayBuffer*, ArrayBufferView*>& wrappedKey, CryptoKey* unwrappingKey, const _Union<AesCbcParams*, Algorithm*, AesCtrParams*, AesGcmParams*, RsaOaepParams*>& unwrapAlgorithm, const _Union<Algorithm*, AesKeyAlgorithm*, EcKeyImportParams*, HmacImportParams*, RsaHashedImportParams*>& unwrappedKeyAlgorithm, bool extractable, TArray<String*>* keyUsages);
		Promise<bool>* verify(const String& algorithm, CryptoKey* key, const _Union<ArrayBuffer*, ArrayBufferView*>& signature, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<bool>* verify(const _Union<Algorithm*, EcdsaParams*, RsaPssParams*>& algorithm, CryptoKey* key, const _Union<ArrayBuffer*, ArrayBufferView*>& signature, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		Promise<ArrayBuffer*>* wrapKey(const String& format, CryptoKey* key, CryptoKey* wrappingKey, const String& wrapAlgorithm);
		Promise<ArrayBuffer*>* wrapKey(const String& format, CryptoKey* key, CryptoKey* wrappingKey, const _Union<AesCbcParams*, Algorithm*, AesCtrParams*, AesGcmParams*, RsaOaepParams*>& wrapAlgorithm);
		static SubtleCrypto* prototype;
		SubtleCrypto();
	};
	class TextDecoderCommon: public virtual Object {
	public:
		String* get_encoding();
		bool get_fatal();
		bool get_ignoreBOM();
	};
	class TextDecoder: public TextDecoderCommon {
	public:
		String* decode();
		String* decode(const _Union<ArrayBuffer*, ArrayBufferView*>& input);
		String* decode(const _Union<ArrayBuffer*, ArrayBufferView*>& input, TextDecodeOptions* options);
		static TextDecoder* prototype;
		TextDecoder();
		TextDecoder(const String& label);
		TextDecoder(const String& label, TextDecoderOptions* options);
	};
	class TextDecoderStream: public GenericTransformStream, public TextDecoderCommon {
	public:
		ReadableStream<String*>* get_readable();
		WritableStream<_Any*>* get_writable();
		static TextDecoderStream* prototype;
		TextDecoderStream();
		TextDecoderStream(const String& label);
		TextDecoderStream(const String& label, TextDecoderOptions* options);
	};
	class TextEncoderCommon: public virtual Object {
	public:
		String* get_encoding();
	};
	class TextEncoder: public TextEncoderCommon {
	public:
		Uint8Array* encode();
		Uint8Array* encode(const String& input);
		TextEncoderEncodeIntoResult* encodeInto(const String& source, Uint8Array* destination);
		static TextEncoder* prototype;
		TextEncoder();
	};
	class TextEncoderStream: public GenericTransformStream, public TextEncoderCommon {
	public:
		ReadableStream<Uint8Array*>* get_readable();
		WritableStream<String*>* get_writable();
		static TextEncoderStream* prototype;
		TextEncoderStream();
	};
	class TextMetrics: public Object {
	public:
		double get_actualBoundingBoxAscent();
		double get_actualBoundingBoxDescent();
		double get_actualBoundingBoxLeft();
		double get_actualBoundingBoxRight();
		double get_fontBoundingBoxAscent();
		double get_fontBoundingBoxDescent();
		double get_width();
		static TextMetrics* prototype;
		TextMetrics();
	};
	class TextTrackEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"cuechange\""))]]
		Event* get__34_cuechange_34_();
		[[cheerp::interface_name(("set_\"cuechange\""))]]
		void set__34_cuechange_34_(Event* _34_cuechange_34_);
	};
	class TextTrackCueList;
	class TextTrackCue;
	class TextTrack: public EventTarget {
	public:
		TextTrackCueList* get_activeCues();
		TextTrackCueList* get_cues();
		String* get_id();
		String* get_inBandMetadataTrackDispatchType();
		String* get_kind();
		String* get_label();
		String* get_language();
		String* get_mode();
		void set_mode(const String& mode);
		_Function<_Any*(Event*)>* get_oncuechange();
		void set_oncuechange(EventListener* oncuechange);
		void set_oncuechange(const _Function<_Any*(Event*)>& oncuechange);
		void addCue(TextTrackCue* cue);
		void removeCue(TextTrackCue* cue);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static TextTrack* prototype;
		TextTrack();
	};
	class TextTrackCueEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"enter\""))]]
		Event* get__34_enter_34_();
		[[cheerp::interface_name(("set_\"enter\""))]]
		void set__34_enter_34_(Event* _34_enter_34_);
		[[cheerp::interface_name(("get_\"exit\""))]]
		Event* get__34_exit_34_();
		[[cheerp::interface_name(("set_\"exit\""))]]
		void set__34_exit_34_(Event* _34_exit_34_);
	};
	class TextTrackCue: public EventTarget {
	public:
		double get_endTime();
		void set_endTime(double endTime);
		String* get_id();
		void set_id(const String& id);
		_Function<_Any*(Event*)>* get_onenter();
		void set_onenter(EventListener* onenter);
		void set_onenter(const _Function<_Any*(Event*)>& onenter);
		_Function<_Any*(Event*)>* get_onexit();
		void set_onexit(EventListener* onexit);
		void set_onexit(const _Function<_Any*(Event*)>& onexit);
		bool get_pauseOnExit();
		void set_pauseOnExit(bool pauseOnExit);
		double get_startTime();
		void set_startTime(double startTime);
		TextTrack* get_track();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static TextTrackCue* prototype;
		TextTrackCue();
	};
	class TextTrackCueList: public Object {
	public:
		int get_length() const;
		TextTrackCue* getCueById(const String& id);
		TextTrackCue* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		TextTrackCue*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::TextTrackCue*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static TextTrackCueList* prototype;
		TextTrackCueList();
	public:
		using client::Object::operator[];
	};
	class TextTrackListEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"addtrack\""))]]
		TrackEvent* get__34_addtrack_34_();
		[[cheerp::interface_name(("set_\"addtrack\""))]]
		void set__34_addtrack_34_(TrackEvent* _34_addtrack_34_);
		[[cheerp::interface_name(("get_\"change\""))]]
		Event* get__34_change_34_();
		[[cheerp::interface_name(("set_\"change\""))]]
		void set__34_change_34_(Event* _34_change_34_);
		[[cheerp::interface_name(("get_\"removetrack\""))]]
		TrackEvent* get__34_removetrack_34_();
		[[cheerp::interface_name(("set_\"removetrack\""))]]
		void set__34_removetrack_34_(TrackEvent* _34_removetrack_34_);
	};
	class TextTrackList: public EventTarget {
	public:
		int get_length() const;
		_Function<_Any*(TrackEvent*)>* get_onaddtrack();
		void set_onaddtrack(EventListener* onaddtrack);
		void set_onaddtrack(const _Function<_Any*(TrackEvent*)>& onaddtrack);
		_Function<_Any*(Event*)>* get_onchange();
		void set_onchange(EventListener* onchange);
		void set_onchange(const _Function<_Any*(Event*)>& onchange);
		_Function<_Any*(TrackEvent*)>* get_onremovetrack();
		void set_onremovetrack(EventListener* onremovetrack);
		void set_onremovetrack(const _Function<_Any*(TrackEvent*)>& onremovetrack);
		TextTrack* getTrackById(const String& id);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		TextTrack* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		TextTrack*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::TextTrack*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static TextTrackList* prototype;
		TextTrackList();
	public:
		using client::Object::operator[];
	};
	class TimeRanges: public Object {
	public:
		int get_length() const;
		double end(double index);
		double start(double index);
		static TimeRanges* prototype;
		TimeRanges();
	};
	class ToggleEvent: public Event {
	public:
		String* get_newState();
		String* get_oldState();
		static ToggleEvent* prototype;
		ToggleEvent(const String& type);
		ToggleEvent(const String& type, ToggleEventInit* eventInitDict);
	};
	class Touch: public Object {
	public:
		double get_clientX();
		double get_clientY();
		double get_force();
		double get_identifier();
		double get_pageX();
		double get_pageY();
		double get_radiusX();
		double get_radiusY();
		double get_rotationAngle();
		double get_screenX();
		double get_screenY();
		EventTarget* get_target();
		static Touch* prototype;
		Touch(TouchInit* touchInitDict);
	};
	class TouchList;
	class TouchEvent: public UIEvent {
	public:
		bool get_altKey();
		TouchList* get_changedTouches();
		bool get_ctrlKey();
		bool get_metaKey();
		bool get_shiftKey();
		TouchList* get_targetTouches();
		TouchList* get_touches();
		static TouchEvent* prototype;
		TouchEvent(const String& type);
		TouchEvent(const String& type, TouchEventInit* eventInitDict);
	};
	class TouchList: public Object {
	public:
		int get_length() const;
		Touch* item(double index);
		Touch* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Touch*& operator[](double index) {
			return __builtin_cheerp_make_regular<client::Touch*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static TouchList* prototype;
		TouchList();
	public:
		using client::Object::operator[];
	};
	class TrackEvent: public Event {
	public:
		TextTrack* get_track();
		static TrackEvent* prototype;
		TrackEvent(const String& type);
		TrackEvent(const String& type, TrackEventInit* eventInitDict);
	};
	template<class _T0, class _T1>
	class TransformStream: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	public:
		ReadableStream<_T1>* get_readable();
		WritableStream<_T0>* get_writable();
		static TransformStream<_Any*, _Any*>* prototype;
		TransformStream();
		template<class _T2 = _Any*, class _T3 = _Any*>
		TransformStream(Transformer<_T2, _T3>* transformer);
		template<class _T2 = _Any*, class _T3 = _Any*>
		TransformStream(Transformer<_T2, _T3>* transformer, QueuingStrategy<_T2>* writableStrategy);
		template<class _T2 = _Any*, class _T3 = _Any*>
		TransformStream(Transformer<_T2, _T3>* transformer, QueuingStrategy<_T2>* writableStrategy, QueuingStrategy<_T3>* readableStrategy);
	};
	template<class _T0>
	class TransformStreamDefaultController: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		double get_desiredSize();
		void enqueue();
		void enqueue(_T0 chunk);
		void error();
		void error(const _Any& reason);
		void terminate();
		static TransformStreamDefaultController<_Any*>* prototype;
		TransformStreamDefaultController();
	};
	class TransitionEvent: public Event {
	public:
		double get_elapsedTime();
		String* get_propertyName();
		String* get_pseudoElement();
		static TransitionEvent* prototype;
		TransitionEvent(const String& type);
		TransitionEvent(const String& type, TransitionEventInit* transitionEventInitDict);
	};
	class TreeWalker: public Object {
	public:
		Node* get_currentNode();
		void set_currentNode(Node* currentNode);
		_Union<_Function<double(Node*)>*, Object*>* get_filter();
		Node* get_root();
		double get_whatToShow();
		Node* firstChild();
		Node* lastChild();
		Node* nextNode();
		Node* nextSibling();
		Node* parentNode();
		Node* previousNode();
		Node* previousSibling();
		static TreeWalker* prototype;
		TreeWalker();
	};
	class URL: public Object {
	public:
		String* get_hash();
		void set_hash(const String& hash);
		String* get_host();
		void set_host(const String& host);
		String* get_hostname();
		void set_hostname(const String& hostname);
		String* get_href();
		void set_href(const String& href);
		String* toString();
		String* get_origin();
		String* get_password();
		void set_password(const String& password);
		String* get_pathname();
		void set_pathname(const String& pathname);
		String* get_port();
		void set_port(const String& port);
		String* get_protocol();
		void set_protocol(const String& protocol);
		String* get_search();
		void set_search(const String& search);
		URLSearchParams* get_searchParams();
		String* get_username();
		void set_username(const String& username);
		String* toJSON();
		static URL* prototype;
		URL(const String& url);
		URL(URL* url);
		URL(const String& url, const String& base);
		URL(URL* url, const String& base);
		URL(const String& url, URL* base);
		URL(URL* url, URL* base);
		static bool canParse(const String& url);
		static bool canParse(URL* url);
		static bool canParse(const String& url, const String& base);
		static bool canParse(URL* url, const String& base);
		static String* createObjectURL(Blob* obj);
		static void revokeObjectURL(const String& url);
	};
	extern Object webkitURL;
	class URLSearchParams: public Object {
	public:
		int get_size() const;
		void append(const String& name, const String& value);
		[[cheerp::interface_name(("delete"))]]
		void delete_(const String& name);
		[[cheerp::interface_name(("delete"))]]
		void delete_(const String& name, const String& value);
		String* get(const String& name);
		TArray<String*>* getAll(const String& name);
		bool has(const String& name);
		bool has(const String& name, const String& value);
		void set(const String& name, const String& value);
		void sort();
		String* toString();
		void forEach(EventListener* callbackfn);
		void forEach(const _Function<void(String*, String*, URLSearchParams*)>& callbackfn);
		void forEach(EventListener* callbackfn, const _Any& thisArg);
		void forEach(const _Function<void(String*, String*, URLSearchParams*)>& callbackfn, const _Any& thisArg);
		static URLSearchParams* prototype;
		URLSearchParams();
		URLSearchParams(const String& init);
		URLSearchParams(const _Union<URLSearchParams*, Object*, TArray<TArray<String*>*>*>& init);
	};
	class UserActivation: public Object {
	public:
		bool get_hasBeenActive();
		bool get_isActive();
		static UserActivation* prototype;
		UserActivation();
	};
	class VTTRegion;
	class VTTCue: public TextTrackCue {
	public:
		String* get_align();
		void set_align(const String& align);
		_Union<double, String*>* get_line();
		void set_line(const String& line);
		void set_line(double line);
		String* get_lineAlign();
		void set_lineAlign(const String& lineAlign);
		_Union<double, String*>* get_position();
		void set_position(const String& position);
		void set_position(double position);
		String* get_positionAlign();
		void set_positionAlign(const String& positionAlign);
		VTTRegion* get_region();
		void set_region(VTTRegion* region);
		int get_size() const;
		void set_size(double size);
		bool get_snapToLines();
		void set_snapToLines(bool snapToLines);
		String* get_text();
		void set_text(const String& text);
		String* get_vertical();
		void set_vertical(const String& vertical);
		DocumentFragment* getCueAsHTML();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static VTTCue* prototype;
		VTTCue(double startTime, double endTime, const String& text);
	};
	class VTTRegion: public Object {
	public:
		String* get_id();
		void set_id(const String& id);
		double get_lines();
		void set_lines(double lines);
		double get_regionAnchorX();
		void set_regionAnchorX(double regionAnchorX);
		double get_regionAnchorY();
		void set_regionAnchorY(double regionAnchorY);
		String* get_scroll();
		void set_scroll(const String& scroll);
		double get_viewportAnchorX();
		void set_viewportAnchorX(double viewportAnchorX);
		double get_viewportAnchorY();
		void set_viewportAnchorY(double viewportAnchorY);
		double get_width();
		void set_width(double width);
		static VTTRegion* prototype;
		VTTRegion();
	};
	class ValidityState: public Object {
	public:
		bool get_badInput();
		bool get_customError();
		bool get_patternMismatch();
		bool get_rangeOverflow();
		bool get_rangeUnderflow();
		bool get_stepMismatch();
		bool get_tooLong();
		bool get_tooShort();
		bool get_typeMismatch();
		bool get_valid();
		bool get_valueMissing();
		static ValidityState* prototype;
		ValidityState();
	};
	class VideoColorSpace: public Object {
	public:
		bool get_fullRange();
		String* get_matrix();
		String* get_primaries();
		String* get_transfer();
		VideoColorSpaceInit* toJSON();
		static VideoColorSpace* prototype;
		VideoColorSpace();
		VideoColorSpace(VideoColorSpaceInit* init);
	};
	class VideoDecoderEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"dequeue\""))]]
		Event* get__34_dequeue_34_();
		[[cheerp::interface_name(("set_\"dequeue\""))]]
		void set__34_dequeue_34_(Event* _34_dequeue_34_);
	};
	class VideoDecoder: public EventTarget {
	public:
		double get_decodeQueueSize();
		_Function<_Any*(Event*)>* get_ondequeue();
		void set_ondequeue(EventListener* ondequeue);
		void set_ondequeue(const _Function<_Any*(Event*)>& ondequeue);
		String* get_state();
		void close();
		void configure(VideoDecoderConfig* config);
		void decode(EncodedVideoChunk* chunk);
		Promise<_Any*>* flush();
		void reset();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static VideoDecoder* prototype;
		VideoDecoder(VideoDecoderInit* init);
		static Promise<VideoDecoderSupport*>* isConfigSupported(VideoDecoderConfig* config);
	};
	class VideoEncoderEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"dequeue\""))]]
		Event* get__34_dequeue_34_();
		[[cheerp::interface_name(("set_\"dequeue\""))]]
		void set__34_dequeue_34_(Event* _34_dequeue_34_);
	};
	class VideoEncoder: public EventTarget {
	public:
		double get_encodeQueueSize();
		_Function<_Any*(Event*)>* get_ondequeue();
		void set_ondequeue(EventListener* ondequeue);
		void set_ondequeue(const _Function<_Any*(Event*)>& ondequeue);
		String* get_state();
		void close();
		void configure(VideoEncoderConfig* config);
		void encode(VideoFrame* frame);
		void encode(VideoFrame* frame, VideoEncoderEncodeOptions* options);
		Promise<_Any*>* flush();
		void reset();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static VideoEncoder* prototype;
		VideoEncoder(VideoEncoderInit* init);
		static Promise<VideoEncoderSupport*>* isConfigSupported(VideoEncoderConfig* config);
	};
	class VideoFrame: public Object {
	public:
		double get_codedHeight();
		DOMRectReadOnly* get_codedRect();
		double get_codedWidth();
		VideoColorSpace* get_colorSpace();
		double get_displayHeight();
		double get_displayWidth();
		double get_duration();
		String* get_format();
		double get_timestamp();
		DOMRectReadOnly* get_visibleRect();
		double allocationSize();
		double allocationSize(VideoFrameCopyToOptions* options);
		VideoFrame* clone();
		void close();
		Promise<TArray<PlaneLayout*>*>* copyTo(const _Union<ArrayBuffer*, ArrayBufferView*>& destination);
		Promise<TArray<PlaneLayout*>*>* copyTo(const _Union<ArrayBuffer*, ArrayBufferView*>& destination, VideoFrameCopyToOptions* options);
		static VideoFrame* prototype;
		VideoFrame(const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image);
		VideoFrame(const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, VideoFrameInit* init);
		VideoFrame(const _Union<ArrayBuffer*, ArrayBufferView*>& data, VideoFrameBufferInit* init);
	};
	class VideoPlaybackQuality: public Object {
	public:
		double get_corruptedVideoFrames();
		double get_creationTime();
		double get_droppedVideoFrames();
		double get_totalVideoFrames();
		static VideoPlaybackQuality* prototype;
		VideoPlaybackQuality();
	};
	class VisualViewportEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"resize\""))]]
		Event* get__34_resize_34_();
		[[cheerp::interface_name(("set_\"resize\""))]]
		void set__34_resize_34_(Event* _34_resize_34_);
		[[cheerp::interface_name(("get_\"scroll\""))]]
		Event* get__34_scroll_34_();
		[[cheerp::interface_name(("set_\"scroll\""))]]
		void set__34_scroll_34_(Event* _34_scroll_34_);
	};
	class VisualViewport: public EventTarget {
	public:
		double get_height();
		double get_offsetLeft();
		double get_offsetTop();
		_Function<_Any*(Event*)>* get_onresize();
		void set_onresize(EventListener* onresize);
		void set_onresize(const _Function<_Any*(Event*)>& onresize);
		_Function<_Any*(Event*)>* get_onscroll();
		void set_onscroll(EventListener* onscroll);
		void set_onscroll(const _Function<_Any*(Event*)>& onscroll);
		double get_pageLeft();
		double get_pageTop();
		double get_scale();
		double get_width();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static VisualViewport* prototype;
		VisualViewport();
	};
	class WEBGL_color_buffer_float: public Object {
	public:
		double get_RGBA32F_EXT();
		double get_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT();
		double get_UNSIGNED_NORMALIZED_EXT();
	};
	class WEBGL_compressed_texture_astc: public Object {
	public:
		TArray<String*>* getSupportedProfiles();
		double get_COMPRESSED_RGBA_ASTC_4x4_KHR();
		double get_COMPRESSED_RGBA_ASTC_5x4_KHR();
		double get_COMPRESSED_RGBA_ASTC_5x5_KHR();
		double get_COMPRESSED_RGBA_ASTC_6x5_KHR();
		double get_COMPRESSED_RGBA_ASTC_6x6_KHR();
		double get_COMPRESSED_RGBA_ASTC_8x5_KHR();
		double get_COMPRESSED_RGBA_ASTC_8x6_KHR();
		double get_COMPRESSED_RGBA_ASTC_8x8_KHR();
		double get_COMPRESSED_RGBA_ASTC_10x5_KHR();
		double get_COMPRESSED_RGBA_ASTC_10x6_KHR();
		double get_COMPRESSED_RGBA_ASTC_10x8_KHR();
		double get_COMPRESSED_RGBA_ASTC_10x10_KHR();
		double get_COMPRESSED_RGBA_ASTC_12x10_KHR();
		double get_COMPRESSED_RGBA_ASTC_12x12_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR();
		double get_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR();
	};
	class WEBGL_compressed_texture_etc: public Object {
	public:
		double get_COMPRESSED_R11_EAC();
		double get_COMPRESSED_SIGNED_R11_EAC();
		double get_COMPRESSED_RG11_EAC();
		double get_COMPRESSED_SIGNED_RG11_EAC();
		double get_COMPRESSED_RGB8_ETC2();
		double get_COMPRESSED_SRGB8_ETC2();
		double get_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2();
		double get_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2();
		double get_COMPRESSED_RGBA8_ETC2_EAC();
		double get_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC();
	};
	class WEBGL_compressed_texture_etc1: public Object {
	public:
		double get_COMPRESSED_RGB_ETC1_WEBGL();
	};
	class WEBGL_compressed_texture_pvrtc: public Object {
	public:
		double get_COMPRESSED_RGB_PVRTC_4BPPV1_IMG();
		double get_COMPRESSED_RGB_PVRTC_2BPPV1_IMG();
		double get_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG();
		double get_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG();
	};
	class WEBGL_compressed_texture_s3tc: public Object {
	public:
		double get_COMPRESSED_RGB_S3TC_DXT1_EXT();
		double get_COMPRESSED_RGBA_S3TC_DXT1_EXT();
		double get_COMPRESSED_RGBA_S3TC_DXT3_EXT();
		double get_COMPRESSED_RGBA_S3TC_DXT5_EXT();
	};
	class WEBGL_compressed_texture_s3tc_srgb: public Object {
	public:
		double get_COMPRESSED_SRGB_S3TC_DXT1_EXT();
		double get_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT();
		double get_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT();
		double get_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT();
	};
	class WEBGL_debug_renderer_info: public Object {
	public:
		double get_UNMASKED_VENDOR_WEBGL();
		double get_UNMASKED_RENDERER_WEBGL();
	};
	class WebGLShader;
	class WEBGL_debug_shaders: public Object {
	public:
		String* getTranslatedShaderSource(WebGLShader* shader);
	};
	class WEBGL_depth_texture: public Object {
	public:
		double get_UNSIGNED_INT_24_8_WEBGL();
	};
	class WEBGL_draw_buffers: public Object {
	public:
		void drawBuffersWEBGL(TArray<double>* buffers);
		double get_COLOR_ATTACHMENT0_WEBGL();
		double get_COLOR_ATTACHMENT1_WEBGL();
		double get_COLOR_ATTACHMENT2_WEBGL();
		double get_COLOR_ATTACHMENT3_WEBGL();
		double get_COLOR_ATTACHMENT4_WEBGL();
		double get_COLOR_ATTACHMENT5_WEBGL();
		double get_COLOR_ATTACHMENT6_WEBGL();
		double get_COLOR_ATTACHMENT7_WEBGL();
		double get_COLOR_ATTACHMENT8_WEBGL();
		double get_COLOR_ATTACHMENT9_WEBGL();
		double get_COLOR_ATTACHMENT10_WEBGL();
		double get_COLOR_ATTACHMENT11_WEBGL();
		double get_COLOR_ATTACHMENT12_WEBGL();
		double get_COLOR_ATTACHMENT13_WEBGL();
		double get_COLOR_ATTACHMENT14_WEBGL();
		double get_COLOR_ATTACHMENT15_WEBGL();
		double get_DRAW_BUFFER0_WEBGL();
		double get_DRAW_BUFFER1_WEBGL();
		double get_DRAW_BUFFER2_WEBGL();
		double get_DRAW_BUFFER3_WEBGL();
		double get_DRAW_BUFFER4_WEBGL();
		double get_DRAW_BUFFER5_WEBGL();
		double get_DRAW_BUFFER6_WEBGL();
		double get_DRAW_BUFFER7_WEBGL();
		double get_DRAW_BUFFER8_WEBGL();
		double get_DRAW_BUFFER9_WEBGL();
		double get_DRAW_BUFFER10_WEBGL();
		double get_DRAW_BUFFER11_WEBGL();
		double get_DRAW_BUFFER12_WEBGL();
		double get_DRAW_BUFFER13_WEBGL();
		double get_DRAW_BUFFER14_WEBGL();
		double get_DRAW_BUFFER15_WEBGL();
		double get_MAX_COLOR_ATTACHMENTS_WEBGL();
		double get_MAX_DRAW_BUFFERS_WEBGL();
	};
	class WEBGL_lose_context: public Object {
	public:
		void loseContext();
		void restoreContext();
	};
	class WEBGL_multi_draw: public Object {
	public:
		void multiDrawArraysInstancedWEBGL(double mode, const _Union<Int32Array*, TArray<double>*>& firstsList, double firstsOffset, const _Union<Int32Array*, TArray<double>*>& countsList, double countsOffset, const _Union<Int32Array*, TArray<double>*>& instanceCountsList, double instanceCountsOffset, double drawcount);
		void multiDrawArraysWEBGL(double mode, const _Union<Int32Array*, TArray<double>*>& firstsList, double firstsOffset, const _Union<Int32Array*, TArray<double>*>& countsList, double countsOffset, double drawcount);
		void multiDrawElementsInstancedWEBGL(double mode, const _Union<Int32Array*, TArray<double>*>& countsList, double countsOffset, double type, const _Union<Int32Array*, TArray<double>*>& offsetsList, double offsetsOffset, const _Union<Int32Array*, TArray<double>*>& instanceCountsList, double instanceCountsOffset, double drawcount);
		void multiDrawElementsWEBGL(double mode, const _Union<Int32Array*, TArray<double>*>& countsList, double countsOffset, double type, const _Union<Int32Array*, TArray<double>*>& offsetsList, double offsetsOffset, double drawcount);
	};
	class WakeLockSentinel;
	class WakeLock: public Object {
	public:
		Promise<WakeLockSentinel*>* request();
		Promise<WakeLockSentinel*>* request(const String& type);
		static WakeLock* prototype;
		WakeLock();
	};
	class WakeLockSentinelEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"release\""))]]
		Event* get__34_release_34_();
		[[cheerp::interface_name(("set_\"release\""))]]
		void set__34_release_34_(Event* _34_release_34_);
	};
	class WakeLockSentinel: public EventTarget {
	public:
		_Function<_Any*(Event*)>* get_onrelease();
		void set_onrelease(EventListener* onrelease);
		void set_onrelease(const _Function<_Any*(Event*)>& onrelease);
		bool get_released();
		String* get_type();
		Promise<_Any*>* release();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static WakeLockSentinel* prototype;
		WakeLockSentinel();
	};
	class WaveShaperNode: public AudioNode {
	public:
		Float32Array* get_curve();
		void set_curve(Float32Array* curve);
		String* get_oversample();
		void set_oversample(const String& oversample);
		static WaveShaperNode* prototype;
		WaveShaperNode(BaseAudioContext* context);
		WaveShaperNode(BaseAudioContext* context, WaveShaperOptions* options);
	};
	class WebGLQuery;
	class WebGLBuffer;
	class WebGLSampler;
	class WebGLTransformFeedback;
	class WebGLVertexArrayObject;
	class WebGLSync;
	class WebGLProgram;
	class WebGLActiveInfo;
	class WebGLUniformLocation;
	class WebGL2RenderingContextBase: public virtual Object {
	public:
		void beginQuery(double target, WebGLQuery* query);
		void beginTransformFeedback(double primitiveMode);
		void bindBufferBase(double target, double index, WebGLBuffer* buffer);
		void bindBufferRange(double target, double index, WebGLBuffer* buffer, double offset, double size);
		void bindSampler(double unit, WebGLSampler* sampler);
		void bindTransformFeedback(double target, WebGLTransformFeedback* tf);
		void bindVertexArray(WebGLVertexArrayObject* array);
		void blitFramebuffer(double srcX0, double srcY0, double srcX1, double srcY1, double dstX0, double dstY0, double dstX1, double dstY1, double mask, double filter);
		void clearBufferfi(double buffer, double drawbuffer, double depth, double stencil);
		void clearBufferfv(double buffer, double drawbuffer, const _Union<Float32Array*, TArray<double>*>& values);
		void clearBufferfv(double buffer, double drawbuffer, const _Union<Float32Array*, TArray<double>*>& values, double srcOffset);
		void clearBufferiv(double buffer, double drawbuffer, const _Union<Int32Array*, TArray<double>*>& values);
		void clearBufferiv(double buffer, double drawbuffer, const _Union<Int32Array*, TArray<double>*>& values, double srcOffset);
		void clearBufferuiv(double buffer, double drawbuffer, const _Union<Uint32Array*, TArray<double>*>& values);
		void clearBufferuiv(double buffer, double drawbuffer, const _Union<Uint32Array*, TArray<double>*>& values, double srcOffset);
		double clientWaitSync(WebGLSync* sync, double flags, double timeout);
		void compressedTexImage3D(double target, double level, double internalformat, double width, double height, double depth, double border, double imageSize, double offset);
		void compressedTexImage3D(double target, double level, double internalformat, double width, double height, double depth, double border, ArrayBufferView* srcData);
		void compressedTexImage3D(double target, double level, double internalformat, double width, double height, double depth, double border, ArrayBufferView* srcData, double srcOffset);
		void compressedTexImage3D(double target, double level, double internalformat, double width, double height, double depth, double border, ArrayBufferView* srcData, double srcOffset, double srcLengthOverride);
		void compressedTexSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double width, double height, double depth, double format, double imageSize, double offset);
		void compressedTexSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double width, double height, double depth, double format, ArrayBufferView* srcData);
		void compressedTexSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double width, double height, double depth, double format, ArrayBufferView* srcData, double srcOffset);
		void compressedTexSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double width, double height, double depth, double format, ArrayBufferView* srcData, double srcOffset, double srcLengthOverride);
		void copyBufferSubData(double readTarget, double writeTarget, double readOffset, double writeOffset, double size);
		void copyTexSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double x, double y, double width, double height);
		WebGLQuery* createQuery();
		WebGLSampler* createSampler();
		WebGLTransformFeedback* createTransformFeedback();
		WebGLVertexArrayObject* createVertexArray();
		void deleteQuery(WebGLQuery* query);
		void deleteSampler(WebGLSampler* sampler);
		void deleteSync(WebGLSync* sync);
		void deleteTransformFeedback(WebGLTransformFeedback* tf);
		void deleteVertexArray(WebGLVertexArrayObject* vertexArray);
		void drawArraysInstanced(double mode, double first, double count, double instanceCount);
		void drawBuffers(TArray<double>* buffers);
		void drawElementsInstanced(double mode, double count, double type, double offset, double instanceCount);
		void drawRangeElements(double mode, double start, double end, double count, double type, double offset);
		void endQuery(double target);
		void endTransformFeedback();
		WebGLSync* fenceSync(double condition, double flags);
		void framebufferTextureLayer(double target, double attachment, WebGLTexture* texture, double level, double layer);
		String* getActiveUniformBlockName(WebGLProgram* program, double uniformBlockIndex);
		Object* getActiveUniformBlockParameter(WebGLProgram* program, double uniformBlockIndex, double pname);
		Object* getActiveUniforms(WebGLProgram* program, TArray<double>* uniformIndices, double pname);
		void getBufferSubData(double target, double srcByteOffset, ArrayBufferView* dstBuffer);
		void getBufferSubData(double target, double srcByteOffset, ArrayBufferView* dstBuffer, double dstOffset);
		void getBufferSubData(double target, double srcByteOffset, ArrayBufferView* dstBuffer, double dstOffset, double length);
		double getFragDataLocation(WebGLProgram* program, const String& name);
		Object* getIndexedParameter(double target, double index);
		Object* getInternalformatParameter(double target, double internalformat, double pname);
		WebGLQuery* getQuery(double target, double pname);
		Object* getQueryParameter(WebGLQuery* query, double pname);
		Object* getSamplerParameter(WebGLSampler* sampler, double pname);
		Object* getSyncParameter(WebGLSync* sync, double pname);
		WebGLActiveInfo* getTransformFeedbackVarying(WebGLProgram* program, double index);
		double getUniformBlockIndex(WebGLProgram* program, const String& uniformBlockName);
		TArray<double>* getUniformIndices(WebGLProgram* program, TArray<String*>* uniformNames);
		void invalidateFramebuffer(double target, TArray<double>* attachments);
		void invalidateSubFramebuffer(double target, TArray<double>* attachments, double x, double y, double width, double height);
		bool isQuery(WebGLQuery* query);
		bool isSampler(WebGLSampler* sampler);
		bool isSync(WebGLSync* sync);
		bool isTransformFeedback(WebGLTransformFeedback* tf);
		bool isVertexArray(WebGLVertexArrayObject* vertexArray);
		void pauseTransformFeedback();
		void readBuffer(double src);
		void renderbufferStorageMultisample(double target, double samples, double internalformat, double width, double height);
		void resumeTransformFeedback();
		void samplerParameterf(WebGLSampler* sampler, double pname, double param);
		void samplerParameteri(WebGLSampler* sampler, double pname, double param);
		void texImage3D(double target, double level, double internalformat, double width, double height, double depth, double border, double format, double type, double pboOffset);
		void texImage3D(double target, double level, double internalformat, double width, double height, double depth, double border, double format, double type, const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, VideoFrame*>& source);
		void texImage3D(double target, double level, double internalformat, double width, double height, double depth, double border, double format, double type, ArrayBufferView* srcData);
		void texImage3D(double target, double level, double internalformat, double width, double height, double depth, double border, double format, double type, ArrayBufferView* srcData, double srcOffset);
		void texStorage2D(double target, double levels, double internalformat, double width, double height);
		void texStorage3D(double target, double levels, double internalformat, double width, double height, double depth);
		void texSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double width, double height, double depth, double format, double type, double pboOffset);
		void texSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double width, double height, double depth, double format, double type, const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, VideoFrame*>& source);
		void texSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double width, double height, double depth, double format, double type, ArrayBufferView* srcData);
		void texSubImage3D(double target, double level, double xoffset, double yoffset, double zoffset, double width, double height, double depth, double format, double type, ArrayBufferView* srcData, double srcOffset);
		void transformFeedbackVaryings(WebGLProgram* program, TArray<String*>* varyings, double bufferMode);
		void uniform1ui(WebGLUniformLocation* location, double v0);
		void uniform1uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data);
		void uniform1uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data, double srcOffset);
		void uniform1uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform2ui(WebGLUniformLocation* location, double v0, double v1);
		void uniform2uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data);
		void uniform2uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data, double srcOffset);
		void uniform2uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform3ui(WebGLUniformLocation* location, double v0, double v1, double v2);
		void uniform3uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data);
		void uniform3uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data, double srcOffset);
		void uniform3uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform4ui(WebGLUniformLocation* location, double v0, double v1, double v2, double v3);
		void uniform4uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data);
		void uniform4uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data, double srcOffset);
		void uniform4uiv(WebGLUniformLocation* location, const _Union<Uint32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformBlockBinding(WebGLProgram* program, double uniformBlockIndex, double uniformBlockBinding);
		void uniformMatrix2x3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix2x3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix2x3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformMatrix2x4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix2x4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix2x4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformMatrix3x2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix3x2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix3x2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformMatrix3x4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix3x4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix3x4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformMatrix4x2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix4x2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix4x2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformMatrix4x3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix4x3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix4x3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void vertexAttribDivisor(double index, double divisor);
		void vertexAttribI4i(double index, double x, double y, double z, double w);
		void vertexAttribI4iv(double index, const _Union<Int32Array*, TArray<double>*>& values);
		void vertexAttribI4ui(double index, double x, double y, double z, double w);
		void vertexAttribI4uiv(double index, const _Union<Uint32Array*, TArray<double>*>& values);
		void vertexAttribIPointer(double index, double size, double type, double stride, double offset);
		void waitSync(WebGLSync* sync, double flags, double timeout);
		double get_READ_BUFFER();
		double get_UNPACK_ROW_LENGTH();
		double get_UNPACK_SKIP_ROWS();
		double get_UNPACK_SKIP_PIXELS();
		double get_PACK_ROW_LENGTH();
		double get_PACK_SKIP_ROWS();
		double get_PACK_SKIP_PIXELS();
		double get_COLOR();
		double get_DEPTH();
		double get_STENCIL();
		double get_RED();
		double get_RGB8();
		double get_RGBA8();
		double get_RGB10_A2();
		double get_TEXTURE_BINDING_3D();
		double get_UNPACK_SKIP_IMAGES();
		double get_UNPACK_IMAGE_HEIGHT();
		double get_TEXTURE_3D();
		double get_TEXTURE_WRAP_R();
		double get_MAX_3D_TEXTURE_SIZE();
		double get_UNSIGNED_INT_2_10_10_10_REV();
		double get_MAX_ELEMENTS_VERTICES();
		double get_MAX_ELEMENTS_INDICES();
		double get_TEXTURE_MIN_LOD();
		double get_TEXTURE_MAX_LOD();
		double get_TEXTURE_BASE_LEVEL();
		double get_TEXTURE_MAX_LEVEL();
		double get_MIN();
		double get_MAX();
		double get_DEPTH_COMPONENT24();
		double get_MAX_TEXTURE_LOD_BIAS();
		double get_TEXTURE_COMPARE_MODE();
		double get_TEXTURE_COMPARE_FUNC();
		double get_CURRENT_QUERY();
		double get_QUERY_RESULT();
		double get_QUERY_RESULT_AVAILABLE();
		double get_STREAM_READ();
		double get_STREAM_COPY();
		double get_STATIC_READ();
		double get_STATIC_COPY();
		double get_DYNAMIC_READ();
		double get_DYNAMIC_COPY();
		double get_MAX_DRAW_BUFFERS();
		double get_DRAW_BUFFER0();
		double get_DRAW_BUFFER1();
		double get_DRAW_BUFFER2();
		double get_DRAW_BUFFER3();
		double get_DRAW_BUFFER4();
		double get_DRAW_BUFFER5();
		double get_DRAW_BUFFER6();
		double get_DRAW_BUFFER7();
		double get_DRAW_BUFFER8();
		double get_DRAW_BUFFER9();
		double get_DRAW_BUFFER10();
		double get_DRAW_BUFFER11();
		double get_DRAW_BUFFER12();
		double get_DRAW_BUFFER13();
		double get_DRAW_BUFFER14();
		double get_DRAW_BUFFER15();
		double get_MAX_FRAGMENT_UNIFORM_COMPONENTS();
		double get_MAX_VERTEX_UNIFORM_COMPONENTS();
		double get_SAMPLER_3D();
		double get_SAMPLER_2D_SHADOW();
		double get_FRAGMENT_SHADER_DERIVATIVE_HINT();
		double get_PIXEL_PACK_BUFFER();
		double get_PIXEL_UNPACK_BUFFER();
		double get_PIXEL_PACK_BUFFER_BINDING();
		double get_PIXEL_UNPACK_BUFFER_BINDING();
		double get_FLOAT_MAT2x3();
		double get_FLOAT_MAT2x4();
		double get_FLOAT_MAT3x2();
		double get_FLOAT_MAT3x4();
		double get_FLOAT_MAT4x2();
		double get_FLOAT_MAT4x3();
		double get_SRGB();
		double get_SRGB8();
		double get_SRGB8_ALPHA8();
		double get_COMPARE_REF_TO_TEXTURE();
		double get_RGBA32F();
		double get_RGB32F();
		double get_RGBA16F();
		double get_RGB16F();
		double get_VERTEX_ATTRIB_ARRAY_INTEGER();
		double get_MAX_ARRAY_TEXTURE_LAYERS();
		double get_MIN_PROGRAM_TEXEL_OFFSET();
		double get_MAX_PROGRAM_TEXEL_OFFSET();
		double get_MAX_VARYING_COMPONENTS();
		double get_TEXTURE_2D_ARRAY();
		double get_TEXTURE_BINDING_2D_ARRAY();
		double get_R11F_G11F_B10F();
		double get_UNSIGNED_INT_10F_11F_11F_REV();
		double get_RGB9_E5();
		double get_UNSIGNED_INT_5_9_9_9_REV();
		double get_TRANSFORM_FEEDBACK_BUFFER_MODE();
		double get_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS();
		double get_TRANSFORM_FEEDBACK_VARYINGS();
		double get_TRANSFORM_FEEDBACK_BUFFER_START();
		double get_TRANSFORM_FEEDBACK_BUFFER_SIZE();
		double get_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN();
		double get_RASTERIZER_DISCARD();
		double get_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS();
		double get_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS();
		double get_INTERLEAVED_ATTRIBS();
		double get_SEPARATE_ATTRIBS();
		double get_TRANSFORM_FEEDBACK_BUFFER();
		double get_TRANSFORM_FEEDBACK_BUFFER_BINDING();
		double get_RGBA32UI();
		double get_RGB32UI();
		double get_RGBA16UI();
		double get_RGB16UI();
		double get_RGBA8UI();
		double get_RGB8UI();
		double get_RGBA32I();
		double get_RGB32I();
		double get_RGBA16I();
		double get_RGB16I();
		double get_RGBA8I();
		double get_RGB8I();
		double get_RED_INTEGER();
		double get_RGB_INTEGER();
		double get_RGBA_INTEGER();
		double get_SAMPLER_2D_ARRAY();
		double get_SAMPLER_2D_ARRAY_SHADOW();
		double get_SAMPLER_CUBE_SHADOW();
		double get_UNSIGNED_INT_VEC2();
		double get_UNSIGNED_INT_VEC3();
		double get_UNSIGNED_INT_VEC4();
		double get_INT_SAMPLER_2D();
		double get_INT_SAMPLER_3D();
		double get_INT_SAMPLER_CUBE();
		double get_INT_SAMPLER_2D_ARRAY();
		double get_UNSIGNED_INT_SAMPLER_2D();
		double get_UNSIGNED_INT_SAMPLER_3D();
		double get_UNSIGNED_INT_SAMPLER_CUBE();
		double get_UNSIGNED_INT_SAMPLER_2D_ARRAY();
		double get_DEPTH_COMPONENT32F();
		double get_DEPTH32F_STENCIL8();
		double get_FLOAT_32_UNSIGNED_INT_24_8_REV();
		double get_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING();
		double get_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE();
		double get_FRAMEBUFFER_ATTACHMENT_RED_SIZE();
		double get_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE();
		double get_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE();
		double get_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE();
		double get_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE();
		double get_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE();
		double get_FRAMEBUFFER_DEFAULT();
		double get_UNSIGNED_INT_24_8();
		double get_DEPTH24_STENCIL8();
		double get_UNSIGNED_NORMALIZED();
		double get_DRAW_FRAMEBUFFER_BINDING();
		double get_READ_FRAMEBUFFER();
		double get_DRAW_FRAMEBUFFER();
		double get_READ_FRAMEBUFFER_BINDING();
		double get_RENDERBUFFER_SAMPLES();
		double get_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER();
		double get_MAX_COLOR_ATTACHMENTS();
		double get_COLOR_ATTACHMENT1();
		double get_COLOR_ATTACHMENT2();
		double get_COLOR_ATTACHMENT3();
		double get_COLOR_ATTACHMENT4();
		double get_COLOR_ATTACHMENT5();
		double get_COLOR_ATTACHMENT6();
		double get_COLOR_ATTACHMENT7();
		double get_COLOR_ATTACHMENT8();
		double get_COLOR_ATTACHMENT9();
		double get_COLOR_ATTACHMENT10();
		double get_COLOR_ATTACHMENT11();
		double get_COLOR_ATTACHMENT12();
		double get_COLOR_ATTACHMENT13();
		double get_COLOR_ATTACHMENT14();
		double get_COLOR_ATTACHMENT15();
		double get_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE();
		double get_MAX_SAMPLES();
		double get_HALF_FLOAT();
		double get_RG();
		double get_RG_INTEGER();
		double get_R8();
		double get_RG8();
		double get_R16F();
		double get_R32F();
		double get_RG16F();
		double get_RG32F();
		double get_R8I();
		double get_R8UI();
		double get_R16I();
		double get_R16UI();
		double get_R32I();
		double get_R32UI();
		double get_RG8I();
		double get_RG8UI();
		double get_RG16I();
		double get_RG16UI();
		double get_RG32I();
		double get_RG32UI();
		double get_VERTEX_ARRAY_BINDING();
		double get_R8_SNORM();
		double get_RG8_SNORM();
		double get_RGB8_SNORM();
		double get_RGBA8_SNORM();
		double get_SIGNED_NORMALIZED();
		double get_COPY_READ_BUFFER();
		double get_COPY_WRITE_BUFFER();
		double get_COPY_READ_BUFFER_BINDING();
		double get_COPY_WRITE_BUFFER_BINDING();
		double get_UNIFORM_BUFFER();
		double get_UNIFORM_BUFFER_BINDING();
		double get_UNIFORM_BUFFER_START();
		double get_UNIFORM_BUFFER_SIZE();
		double get_MAX_VERTEX_UNIFORM_BLOCKS();
		double get_MAX_FRAGMENT_UNIFORM_BLOCKS();
		double get_MAX_COMBINED_UNIFORM_BLOCKS();
		double get_MAX_UNIFORM_BUFFER_BINDINGS();
		double get_MAX_UNIFORM_BLOCK_SIZE();
		double get_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS();
		double get_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS();
		double get_UNIFORM_BUFFER_OFFSET_ALIGNMENT();
		double get_ACTIVE_UNIFORM_BLOCKS();
		double get_UNIFORM_TYPE();
		double get_UNIFORM_SIZE();
		double get_UNIFORM_BLOCK_INDEX();
		double get_UNIFORM_OFFSET();
		double get_UNIFORM_ARRAY_STRIDE();
		double get_UNIFORM_MATRIX_STRIDE();
		double get_UNIFORM_IS_ROW_MAJOR();
		double get_UNIFORM_BLOCK_BINDING();
		double get_UNIFORM_BLOCK_DATA_SIZE();
		double get_UNIFORM_BLOCK_ACTIVE_UNIFORMS();
		double get_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES();
		double get_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER();
		double get_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER();
		double get_INVALID_INDEX();
		double get_MAX_VERTEX_OUTPUT_COMPONENTS();
		double get_MAX_FRAGMENT_INPUT_COMPONENTS();
		double get_MAX_SERVER_WAIT_TIMEOUT();
		double get_OBJECT_TYPE();
		double get_SYNC_CONDITION();
		double get_SYNC_STATUS();
		double get_SYNC_FLAGS();
		double get_SYNC_FENCE();
		double get_SYNC_GPU_COMMANDS_COMPLETE();
		double get_UNSIGNALED();
		double get_SIGNALED();
		double get_ALREADY_SIGNALED();
		double get_TIMEOUT_EXPIRED();
		double get_CONDITION_SATISFIED();
		double get_WAIT_FAILED();
		double get_SYNC_FLUSH_COMMANDS_BIT();
		double get_VERTEX_ATTRIB_ARRAY_DIVISOR();
		double get_ANY_SAMPLES_PASSED();
		double get_ANY_SAMPLES_PASSED_CONSERVATIVE();
		double get_SAMPLER_BINDING();
		double get_RGB10_A2UI();
		double get_INT_2_10_10_10_REV();
		double get_TRANSFORM_FEEDBACK();
		double get_TRANSFORM_FEEDBACK_PAUSED();
		double get_TRANSFORM_FEEDBACK_ACTIVE();
		double get_TRANSFORM_FEEDBACK_BINDING();
		double get_TEXTURE_IMMUTABLE_FORMAT();
		double get_MAX_ELEMENT_INDEX();
		double get_TEXTURE_IMMUTABLE_LEVELS();
		double get_TIMEOUT_IGNORED();
		double get_MAX_CLIENT_WAIT_TIMEOUT_WEBGL();
	};
	class WebGL2RenderingContextOverloads: public virtual Object {
	public:
		void bufferData(double target, double size, double usage);
		void bufferData(double target, const _Union<ArrayBuffer*, ArrayBufferView*>& srcData, double usage);
		void bufferData(double target, ArrayBufferView* srcData, double usage, double srcOffset);
		void bufferData(double target, ArrayBufferView* srcData, double usage, double srcOffset, double length);
		void bufferSubData(double target, double dstByteOffset, const _Union<ArrayBuffer*, ArrayBufferView*>& srcData);
		void bufferSubData(double target, double dstByteOffset, ArrayBufferView* srcData, double srcOffset);
		void bufferSubData(double target, double dstByteOffset, ArrayBufferView* srcData, double srcOffset, double length);
		void compressedTexImage2D(double target, double level, double internalformat, double width, double height, double border, double imageSize, double offset);
		void compressedTexImage2D(double target, double level, double internalformat, double width, double height, double border, ArrayBufferView* srcData);
		void compressedTexImage2D(double target, double level, double internalformat, double width, double height, double border, ArrayBufferView* srcData, double srcOffset);
		void compressedTexImage2D(double target, double level, double internalformat, double width, double height, double border, ArrayBufferView* srcData, double srcOffset, double srcLengthOverride);
		void compressedTexSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, double imageSize, double offset);
		void compressedTexSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, ArrayBufferView* srcData);
		void compressedTexSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, ArrayBufferView* srcData, double srcOffset);
		void compressedTexSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, ArrayBufferView* srcData, double srcOffset, double srcLengthOverride);
		void readPixels(double x, double y, double width, double height, double format, double type, ArrayBufferView* dstData);
		void readPixels(double x, double y, double width, double height, double format, double type, double offset);
		void readPixels(double x, double y, double width, double height, double format, double type, ArrayBufferView* dstData, double dstOffset);
		void texImage2D(double target, double level, double internalformat, double width, double height, double border, double format, double type, ArrayBufferView* pixels);
		void texImage2D(double target, double level, double internalformat, double format, double type, const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, VideoFrame*>& source);
		void texImage2D(double target, double level, double internalformat, double width, double height, double border, double format, double type, double pboOffset);
		void texImage2D(double target, double level, double internalformat, double width, double height, double border, double format, double type, const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, VideoFrame*>& source);
		void texImage2D(double target, double level, double internalformat, double width, double height, double border, double format, double type, ArrayBufferView* srcData, double srcOffset);
		void texSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, double type, ArrayBufferView* pixels);
		void texSubImage2D(double target, double level, double xoffset, double yoffset, double format, double type, const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, VideoFrame*>& source);
		void texSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, double type, double pboOffset);
		void texSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, double type, const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, VideoFrame*>& source);
		void texSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, double type, ArrayBufferView* srcData, double srcOffset);
		void uniform1fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data);
		void uniform1fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniform1fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform1iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data);
		void uniform1iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data, double srcOffset);
		void uniform1iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform2fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data);
		void uniform2fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniform2fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform2iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data);
		void uniform2iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data, double srcOffset);
		void uniform2iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform3fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data);
		void uniform3fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniform3fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform3iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data);
		void uniform3iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data, double srcOffset);
		void uniform3iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform4fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data);
		void uniform4fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniform4fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniform4iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data);
		void uniform4iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data, double srcOffset);
		void uniform4iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformMatrix2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformMatrix3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
		void uniformMatrix4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data);
		void uniformMatrix4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset);
		void uniformMatrix4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& data, double srcOffset, double srcLength);
	};
	class WebGLFramebuffer;
	class WebGLRenderbuffer;
	class WebGLShaderPrecisionFormat;
	class WebGLRenderingContextBase: public virtual Object {
	public:
		_Union<HTMLCanvasElement*, OffscreenCanvas*>* get_canvas();
		String* get_drawingBufferColorSpace();
		void set_drawingBufferColorSpace(const String& drawingBufferColorSpace);
		double get_drawingBufferHeight();
		double get_drawingBufferWidth();
		void activeTexture(double texture);
		void attachShader(WebGLProgram* program, WebGLShader* shader);
		void bindAttribLocation(WebGLProgram* program, double index, const String& name);
		void bindBuffer(double target, WebGLBuffer* buffer);
		void bindFramebuffer(double target, WebGLFramebuffer* framebuffer);
		void bindRenderbuffer(double target, WebGLRenderbuffer* renderbuffer);
		void bindTexture(double target, WebGLTexture* texture);
		void blendColor(double red, double green, double blue, double alpha);
		void blendEquation(double mode);
		void blendEquationSeparate(double modeRGB, double modeAlpha);
		void blendFunc(double sfactor, double dfactor);
		void blendFuncSeparate(double srcRGB, double dstRGB, double srcAlpha, double dstAlpha);
		double checkFramebufferStatus(double target);
		void clear(double mask);
		void clearColor(double red, double green, double blue, double alpha);
		void clearDepth(double depth);
		void clearStencil(double s);
		void colorMask(bool red, bool green, bool blue, bool alpha);
		void compileShader(WebGLShader* shader);
		void copyTexImage2D(double target, double level, double internalformat, double x, double y, double width, double height, double border);
		void copyTexSubImage2D(double target, double level, double xoffset, double yoffset, double x, double y, double width, double height);
		WebGLBuffer* createBuffer();
		WebGLFramebuffer* createFramebuffer();
		WebGLProgram* createProgram();
		WebGLRenderbuffer* createRenderbuffer();
		WebGLShader* createShader(double type);
		WebGLTexture* createTexture();
		void cullFace(double mode);
		void deleteBuffer(WebGLBuffer* buffer);
		void deleteFramebuffer(WebGLFramebuffer* framebuffer);
		void deleteProgram(WebGLProgram* program);
		void deleteRenderbuffer(WebGLRenderbuffer* renderbuffer);
		void deleteShader(WebGLShader* shader);
		void deleteTexture(WebGLTexture* texture);
		void depthFunc(double func);
		void depthMask(bool flag);
		void depthRange(double zNear, double zFar);
		void detachShader(WebGLProgram* program, WebGLShader* shader);
		void disable(double cap);
		void disableVertexAttribArray(double index);
		void drawArrays(double mode, double first, double count);
		void drawElements(double mode, double count, double type, double offset);
		void enable(double cap);
		void enableVertexAttribArray(double index);
		void finish();
		void flush();
		void framebufferRenderbuffer(double target, double attachment, double renderbuffertarget, WebGLRenderbuffer* renderbuffer);
		void framebufferTexture2D(double target, double attachment, double textarget, WebGLTexture* texture, double level);
		void frontFace(double mode);
		void generateMipmap(double target);
		WebGLActiveInfo* getActiveAttrib(WebGLProgram* program, double index);
		WebGLActiveInfo* getActiveUniform(WebGLProgram* program, double index);
		TArray<WebGLShader*>* getAttachedShaders(WebGLProgram* program);
		double getAttribLocation(WebGLProgram* program, const String& name);
		Object* getBufferParameter(double target, double pname);
		WebGLContextAttributes* getContextAttributes();
		double getError();
		_Union<ANGLE_instanced_arrays*, EXT_blend_minmax*, EXT_color_buffer_float*, EXT_color_buffer_half_float*, EXT_float_blend*, EXT_frag_depth*, EXT_sRGB*, EXT_shader_texture_lod*, EXT_texture_compression_bptc*, EXT_texture_compression_rgtc*, EXT_texture_filter_anisotropic*, KHR_parallel_shader_compile*, OES_element_index_uint*, OES_fbo_render_mipmap*, OES_standard_derivatives*, OES_texture_float*, OES_texture_float_linear*, OES_texture_half_float*, OES_texture_half_float_linear*, OES_vertex_array_object*, OVR_multiview2*, WEBGL_color_buffer_float*, WEBGL_compressed_texture_astc*, WEBGL_compressed_texture_etc*, WEBGL_compressed_texture_etc1*, WEBGL_compressed_texture_pvrtc*, WEBGL_compressed_texture_s3tc*, WEBGL_compressed_texture_s3tc_srgb*, WEBGL_debug_renderer_info*, WEBGL_debug_shaders*, WEBGL_depth_texture*, WEBGL_draw_buffers*, WEBGL_lose_context*, WEBGL_multi_draw*, Object*>* getExtension(const String& extensionName);
		Object* getFramebufferAttachmentParameter(double target, double attachment, double pname);
		Object* getParameter(double pname);
		String* getProgramInfoLog(WebGLProgram* program);
		Object* getProgramParameter(WebGLProgram* program, double pname);
		Object* getRenderbufferParameter(double target, double pname);
		String* getShaderInfoLog(WebGLShader* shader);
		Object* getShaderParameter(WebGLShader* shader, double pname);
		WebGLShaderPrecisionFormat* getShaderPrecisionFormat(double shadertype, double precisiontype);
		String* getShaderSource(WebGLShader* shader);
		TArray<String*>* getSupportedExtensions();
		Object* getTexParameter(double target, double pname);
		Object* getUniform(WebGLProgram* program, WebGLUniformLocation* location);
		WebGLUniformLocation* getUniformLocation(WebGLProgram* program, const String& name);
		Object* getVertexAttrib(double index, double pname);
		double getVertexAttribOffset(double index, double pname);
		void hint(double target, double mode);
		bool isBuffer(WebGLBuffer* buffer);
		bool isContextLost();
		bool isEnabled(double cap);
		bool isFramebuffer(WebGLFramebuffer* framebuffer);
		bool isProgram(WebGLProgram* program);
		bool isRenderbuffer(WebGLRenderbuffer* renderbuffer);
		bool isShader(WebGLShader* shader);
		bool isTexture(WebGLTexture* texture);
		void lineWidth(double width);
		void linkProgram(WebGLProgram* program);
		void pixelStorei(double pname, const _Union<double, bool>& param);
		void polygonOffset(double factor, double units);
		void renderbufferStorage(double target, double internalformat, double width, double height);
		void sampleCoverage(double value, bool invert);
		void scissor(double x, double y, double width, double height);
		void shaderSource(WebGLShader* shader, const String& source);
		void stencilFunc(double func, double ref, double mask);
		void stencilFuncSeparate(double face, double func, double ref, double mask);
		void stencilMask(double mask);
		void stencilMaskSeparate(double face, double mask);
		void stencilOp(double fail, double zfail, double zpass);
		void stencilOpSeparate(double face, double fail, double zfail, double zpass);
		void texParameterf(double target, double pname, double param);
		void texParameteri(double target, double pname, double param);
		void uniform1f(WebGLUniformLocation* location, double x);
		void uniform1i(WebGLUniformLocation* location, double x);
		void uniform2f(WebGLUniformLocation* location, double x, double y);
		void uniform2i(WebGLUniformLocation* location, double x, double y);
		void uniform3f(WebGLUniformLocation* location, double x, double y, double z);
		void uniform3i(WebGLUniformLocation* location, double x, double y, double z);
		void uniform4f(WebGLUniformLocation* location, double x, double y, double z, double w);
		void uniform4i(WebGLUniformLocation* location, double x, double y, double z, double w);
		void useProgram(WebGLProgram* program);
		void validateProgram(WebGLProgram* program);
		void vertexAttrib1f(double index, double x);
		void vertexAttrib1fv(double index, const _Union<Float32Array*, TArray<double>*>& values);
		void vertexAttrib2f(double index, double x, double y);
		void vertexAttrib2fv(double index, const _Union<Float32Array*, TArray<double>*>& values);
		void vertexAttrib3f(double index, double x, double y, double z);
		void vertexAttrib3fv(double index, const _Union<Float32Array*, TArray<double>*>& values);
		void vertexAttrib4f(double index, double x, double y, double z, double w);
		void vertexAttrib4fv(double index, const _Union<Float32Array*, TArray<double>*>& values);
		void vertexAttribPointer(double index, double size, double type, bool normalized, double stride, double offset);
		void viewport(double x, double y, double width, double height);
		double get_DEPTH_BUFFER_BIT();
		double get_STENCIL_BUFFER_BIT();
		double get_COLOR_BUFFER_BIT();
		double get_POINTS();
		double get_LINES();
		double get_LINE_LOOP();
		double get_LINE_STRIP();
		double get_TRIANGLES();
		double get_TRIANGLE_STRIP();
		double get_TRIANGLE_FAN();
		double get_ZERO();
		double get_ONE();
		double get_SRC_COLOR();
		double get_ONE_MINUS_SRC_COLOR();
		double get_SRC_ALPHA();
		double get_ONE_MINUS_SRC_ALPHA();
		double get_DST_ALPHA();
		double get_ONE_MINUS_DST_ALPHA();
		double get_DST_COLOR();
		double get_ONE_MINUS_DST_COLOR();
		double get_SRC_ALPHA_SATURATE();
		double get_FUNC_ADD();
		double get_BLEND_EQUATION();
		double get_BLEND_EQUATION_RGB();
		double get_BLEND_EQUATION_ALPHA();
		double get_FUNC_SUBTRACT();
		double get_FUNC_REVERSE_SUBTRACT();
		double get_BLEND_DST_RGB();
		double get_BLEND_SRC_RGB();
		double get_BLEND_DST_ALPHA();
		double get_BLEND_SRC_ALPHA();
		double get_CONSTANT_COLOR();
		double get_ONE_MINUS_CONSTANT_COLOR();
		double get_CONSTANT_ALPHA();
		double get_ONE_MINUS_CONSTANT_ALPHA();
		double get_BLEND_COLOR();
		double get_ARRAY_BUFFER();
		double get_ELEMENT_ARRAY_BUFFER();
		double get_ARRAY_BUFFER_BINDING();
		double get_ELEMENT_ARRAY_BUFFER_BINDING();
		double get_STREAM_DRAW();
		double get_STATIC_DRAW();
		double get_DYNAMIC_DRAW();
		double get_BUFFER_SIZE();
		double get_BUFFER_USAGE();
		double get_CURRENT_VERTEX_ATTRIB();
		double get_FRONT();
		double get_BACK();
		double get_FRONT_AND_BACK();
		double get_CULL_FACE();
		double get_BLEND();
		double get_DITHER();
		double get_STENCIL_TEST();
		double get_DEPTH_TEST();
		double get_SCISSOR_TEST();
		double get_POLYGON_OFFSET_FILL();
		double get_SAMPLE_ALPHA_TO_COVERAGE();
		double get_SAMPLE_COVERAGE();
		double get_NO_ERROR();
		double get_INVALID_ENUM();
		double get_INVALID_VALUE();
		double get_INVALID_OPERATION();
		double get_OUT_OF_MEMORY();
		double get_CW();
		double get_CCW();
		double get_LINE_WIDTH();
		double get_ALIASED_POINT_SIZE_RANGE();
		double get_ALIASED_LINE_WIDTH_RANGE();
		double get_CULL_FACE_MODE();
		double get_FRONT_FACE();
		double get_DEPTH_RANGE();
		double get_DEPTH_WRITEMASK();
		double get_DEPTH_CLEAR_VALUE();
		double get_DEPTH_FUNC();
		double get_STENCIL_CLEAR_VALUE();
		double get_STENCIL_FUNC();
		double get_STENCIL_FAIL();
		double get_STENCIL_PASS_DEPTH_FAIL();
		double get_STENCIL_PASS_DEPTH_PASS();
		double get_STENCIL_REF();
		double get_STENCIL_VALUE_MASK();
		double get_STENCIL_WRITEMASK();
		double get_STENCIL_BACK_FUNC();
		double get_STENCIL_BACK_FAIL();
		double get_STENCIL_BACK_PASS_DEPTH_FAIL();
		double get_STENCIL_BACK_PASS_DEPTH_PASS();
		double get_STENCIL_BACK_REF();
		double get_STENCIL_BACK_VALUE_MASK();
		double get_STENCIL_BACK_WRITEMASK();
		double get_VIEWPORT();
		double get_SCISSOR_BOX();
		double get_COLOR_CLEAR_VALUE();
		double get_COLOR_WRITEMASK();
		double get_UNPACK_ALIGNMENT();
		double get_PACK_ALIGNMENT();
		double get_MAX_TEXTURE_SIZE();
		double get_MAX_VIEWPORT_DIMS();
		double get_SUBPIXEL_BITS();
		double get_RED_BITS();
		double get_GREEN_BITS();
		double get_BLUE_BITS();
		double get_ALPHA_BITS();
		double get_DEPTH_BITS();
		double get_STENCIL_BITS();
		double get_POLYGON_OFFSET_UNITS();
		double get_POLYGON_OFFSET_FACTOR();
		double get_TEXTURE_BINDING_2D();
		double get_SAMPLE_BUFFERS();
		double get_SAMPLES();
		double get_SAMPLE_COVERAGE_VALUE();
		double get_SAMPLE_COVERAGE_INVERT();
		double get_COMPRESSED_TEXTURE_FORMATS();
		double get_DONT_CARE();
		double get_FASTEST();
		double get_NICEST();
		double get_GENERATE_MIPMAP_HINT();
		double get_BYTE();
		double get_UNSIGNED_BYTE();
		double get_SHORT();
		double get_UNSIGNED_SHORT();
		double get_INT();
		double get_UNSIGNED_INT();
		double get_FLOAT();
		double get_DEPTH_COMPONENT();
		double get_ALPHA();
		double get_RGB();
		double get_RGBA();
		double get_LUMINANCE();
		double get_LUMINANCE_ALPHA();
		double get_UNSIGNED_SHORT_4_4_4_4();
		double get_UNSIGNED_SHORT_5_5_5_1();
		double get_UNSIGNED_SHORT_5_6_5();
		double get_FRAGMENT_SHADER();
		double get_VERTEX_SHADER();
		double get_MAX_VERTEX_ATTRIBS();
		double get_MAX_VERTEX_UNIFORM_VECTORS();
		double get_MAX_VARYING_VECTORS();
		double get_MAX_COMBINED_TEXTURE_IMAGE_UNITS();
		double get_MAX_VERTEX_TEXTURE_IMAGE_UNITS();
		double get_MAX_TEXTURE_IMAGE_UNITS();
		double get_MAX_FRAGMENT_UNIFORM_VECTORS();
		double get_SHADER_TYPE();
		double get_DELETE_STATUS();
		double get_LINK_STATUS();
		double get_VALIDATE_STATUS();
		double get_ATTACHED_SHADERS();
		double get_ACTIVE_UNIFORMS();
		double get_ACTIVE_ATTRIBUTES();
		double get_SHADING_LANGUAGE_VERSION();
		double get_CURRENT_PROGRAM();
		double get_NEVER();
		double get_LESS();
		double get_EQUAL();
		double get_LEQUAL();
		double get_GREATER();
		double get_NOTEQUAL();
		double get_GEQUAL();
		double get_ALWAYS();
		double get_KEEP();
		double get_REPLACE();
		double get_INCR();
		double get_DECR();
		double get_INVERT();
		double get_INCR_WRAP();
		double get_DECR_WRAP();
		double get_VENDOR();
		double get_RENDERER();
		double get_VERSION();
		double get_NEAREST();
		double get_LINEAR();
		double get_NEAREST_MIPMAP_NEAREST();
		double get_LINEAR_MIPMAP_NEAREST();
		double get_NEAREST_MIPMAP_LINEAR();
		double get_LINEAR_MIPMAP_LINEAR();
		double get_TEXTURE_MAG_FILTER();
		double get_TEXTURE_MIN_FILTER();
		double get_TEXTURE_WRAP_S();
		double get_TEXTURE_WRAP_T();
		double get_TEXTURE_2D();
		double get_TEXTURE();
		double get_TEXTURE_CUBE_MAP();
		double get_TEXTURE_BINDING_CUBE_MAP();
		double get_TEXTURE_CUBE_MAP_POSITIVE_X();
		double get_TEXTURE_CUBE_MAP_NEGATIVE_X();
		double get_TEXTURE_CUBE_MAP_POSITIVE_Y();
		double get_TEXTURE_CUBE_MAP_NEGATIVE_Y();
		double get_TEXTURE_CUBE_MAP_POSITIVE_Z();
		double get_TEXTURE_CUBE_MAP_NEGATIVE_Z();
		double get_MAX_CUBE_MAP_TEXTURE_SIZE();
		double get_TEXTURE0();
		double get_TEXTURE1();
		double get_TEXTURE2();
		double get_TEXTURE3();
		double get_TEXTURE4();
		double get_TEXTURE5();
		double get_TEXTURE6();
		double get_TEXTURE7();
		double get_TEXTURE8();
		double get_TEXTURE9();
		double get_TEXTURE10();
		double get_TEXTURE11();
		double get_TEXTURE12();
		double get_TEXTURE13();
		double get_TEXTURE14();
		double get_TEXTURE15();
		double get_TEXTURE16();
		double get_TEXTURE17();
		double get_TEXTURE18();
		double get_TEXTURE19();
		double get_TEXTURE20();
		double get_TEXTURE21();
		double get_TEXTURE22();
		double get_TEXTURE23();
		double get_TEXTURE24();
		double get_TEXTURE25();
		double get_TEXTURE26();
		double get_TEXTURE27();
		double get_TEXTURE28();
		double get_TEXTURE29();
		double get_TEXTURE30();
		double get_TEXTURE31();
		double get_ACTIVE_TEXTURE();
		double get_REPEAT();
		double get_CLAMP_TO_EDGE();
		double get_MIRRORED_REPEAT();
		double get_FLOAT_VEC2();
		double get_FLOAT_VEC3();
		double get_FLOAT_VEC4();
		double get_INT_VEC2();
		double get_INT_VEC3();
		double get_INT_VEC4();
		double get_BOOL();
		double get_BOOL_VEC2();
		double get_BOOL_VEC3();
		double get_BOOL_VEC4();
		double get_FLOAT_MAT2();
		double get_FLOAT_MAT3();
		double get_FLOAT_MAT4();
		double get_SAMPLER_2D();
		double get_SAMPLER_CUBE();
		double get_VERTEX_ATTRIB_ARRAY_ENABLED();
		double get_VERTEX_ATTRIB_ARRAY_SIZE();
		double get_VERTEX_ATTRIB_ARRAY_STRIDE();
		double get_VERTEX_ATTRIB_ARRAY_TYPE();
		double get_VERTEX_ATTRIB_ARRAY_NORMALIZED();
		double get_VERTEX_ATTRIB_ARRAY_POINTER();
		double get_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING();
		double get_IMPLEMENTATION_COLOR_READ_TYPE();
		double get_IMPLEMENTATION_COLOR_READ_FORMAT();
		double get_COMPILE_STATUS();
		double get_LOW_FLOAT();
		double get_MEDIUM_FLOAT();
		double get_HIGH_FLOAT();
		double get_LOW_INT();
		double get_MEDIUM_INT();
		double get_HIGH_INT();
		double get_FRAMEBUFFER();
		double get_RENDERBUFFER();
		double get_RGBA4();
		double get_RGB5_A1();
		double get_RGB565();
		double get_DEPTH_COMPONENT16();
		double get_STENCIL_INDEX8();
		double get_DEPTH_STENCIL();
		double get_RENDERBUFFER_WIDTH();
		double get_RENDERBUFFER_HEIGHT();
		double get_RENDERBUFFER_INTERNAL_FORMAT();
		double get_RENDERBUFFER_RED_SIZE();
		double get_RENDERBUFFER_GREEN_SIZE();
		double get_RENDERBUFFER_BLUE_SIZE();
		double get_RENDERBUFFER_ALPHA_SIZE();
		double get_RENDERBUFFER_DEPTH_SIZE();
		double get_RENDERBUFFER_STENCIL_SIZE();
		double get_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE();
		double get_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME();
		double get_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL();
		double get_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE();
		double get_COLOR_ATTACHMENT0();
		double get_DEPTH_ATTACHMENT();
		double get_STENCIL_ATTACHMENT();
		double get_DEPTH_STENCIL_ATTACHMENT();
		double get_NONE();
		double get_FRAMEBUFFER_COMPLETE();
		double get_FRAMEBUFFER_INCOMPLETE_ATTACHMENT();
		double get_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT();
		double get_FRAMEBUFFER_INCOMPLETE_DIMENSIONS();
		double get_FRAMEBUFFER_UNSUPPORTED();
		double get_FRAMEBUFFER_BINDING();
		double get_RENDERBUFFER_BINDING();
		double get_MAX_RENDERBUFFER_SIZE();
		double get_INVALID_FRAMEBUFFER_OPERATION();
		double get_UNPACK_FLIP_Y_WEBGL();
		double get_UNPACK_PREMULTIPLY_ALPHA_WEBGL();
		double get_CONTEXT_LOST_WEBGL();
		double get_UNPACK_COLORSPACE_CONVERSION_WEBGL();
		double get_BROWSER_DEFAULT_WEBGL();
	};
	class WebGL2RenderingContext: public WebGL2RenderingContextBase, public WebGL2RenderingContextOverloads, public WebGLRenderingContextBase {
	public:
		static WebGL2RenderingContext* prototype;
		WebGL2RenderingContext();
		static double READ_BUFFER;
		static double UNPACK_ROW_LENGTH;
		static double UNPACK_SKIP_ROWS;
		static double UNPACK_SKIP_PIXELS;
		static double PACK_ROW_LENGTH;
		static double PACK_SKIP_ROWS;
		static double PACK_SKIP_PIXELS;
		static double COLOR;
		static double DEPTH;
		static double STENCIL;
		static double RED;
		static double RGB8;
		static double RGBA8;
		static double RGB10_A2;
		static double TEXTURE_BINDING_3D;
		static double UNPACK_SKIP_IMAGES;
		static double UNPACK_IMAGE_HEIGHT;
		static double TEXTURE_3D;
		static double TEXTURE_WRAP_R;
		static double MAX_3D_TEXTURE_SIZE;
		static double UNSIGNED_INT_2_10_10_10_REV;
		static double MAX_ELEMENTS_VERTICES;
		static double MAX_ELEMENTS_INDICES;
		static double TEXTURE_MIN_LOD;
		static double TEXTURE_MAX_LOD;
		static double TEXTURE_BASE_LEVEL;
		static double TEXTURE_MAX_LEVEL;
		static double MIN;
		static double MAX;
		static double DEPTH_COMPONENT24;
		static double MAX_TEXTURE_LOD_BIAS;
		static double TEXTURE_COMPARE_MODE;
		static double TEXTURE_COMPARE_FUNC;
		static double CURRENT_QUERY;
		static double QUERY_RESULT;
		static double QUERY_RESULT_AVAILABLE;
		static double STREAM_READ;
		static double STREAM_COPY;
		static double STATIC_READ;
		static double STATIC_COPY;
		static double DYNAMIC_READ;
		static double DYNAMIC_COPY;
		static double MAX_DRAW_BUFFERS;
		static double DRAW_BUFFER0;
		static double DRAW_BUFFER1;
		static double DRAW_BUFFER2;
		static double DRAW_BUFFER3;
		static double DRAW_BUFFER4;
		static double DRAW_BUFFER5;
		static double DRAW_BUFFER6;
		static double DRAW_BUFFER7;
		static double DRAW_BUFFER8;
		static double DRAW_BUFFER9;
		static double DRAW_BUFFER10;
		static double DRAW_BUFFER11;
		static double DRAW_BUFFER12;
		static double DRAW_BUFFER13;
		static double DRAW_BUFFER14;
		static double DRAW_BUFFER15;
		static double MAX_FRAGMENT_UNIFORM_COMPONENTS;
		static double MAX_VERTEX_UNIFORM_COMPONENTS;
		static double SAMPLER_3D;
		static double SAMPLER_2D_SHADOW;
		static double FRAGMENT_SHADER_DERIVATIVE_HINT;
		static double PIXEL_PACK_BUFFER;
		static double PIXEL_UNPACK_BUFFER;
		static double PIXEL_PACK_BUFFER_BINDING;
		static double PIXEL_UNPACK_BUFFER_BINDING;
		static double FLOAT_MAT2x3;
		static double FLOAT_MAT2x4;
		static double FLOAT_MAT3x2;
		static double FLOAT_MAT3x4;
		static double FLOAT_MAT4x2;
		static double FLOAT_MAT4x3;
		static double SRGB;
		static double SRGB8;
		static double SRGB8_ALPHA8;
		static double COMPARE_REF_TO_TEXTURE;
		static double RGBA32F;
		static double RGB32F;
		static double RGBA16F;
		static double RGB16F;
		static double VERTEX_ATTRIB_ARRAY_INTEGER;
		static double MAX_ARRAY_TEXTURE_LAYERS;
		static double MIN_PROGRAM_TEXEL_OFFSET;
		static double MAX_PROGRAM_TEXEL_OFFSET;
		static double MAX_VARYING_COMPONENTS;
		static double TEXTURE_2D_ARRAY;
		static double TEXTURE_BINDING_2D_ARRAY;
		static double R11F_G11F_B10F;
		static double UNSIGNED_INT_10F_11F_11F_REV;
		static double RGB9_E5;
		static double UNSIGNED_INT_5_9_9_9_REV;
		static double TRANSFORM_FEEDBACK_BUFFER_MODE;
		static double MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS;
		static double TRANSFORM_FEEDBACK_VARYINGS;
		static double TRANSFORM_FEEDBACK_BUFFER_START;
		static double TRANSFORM_FEEDBACK_BUFFER_SIZE;
		static double TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN;
		static double RASTERIZER_DISCARD;
		static double MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS;
		static double MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS;
		static double INTERLEAVED_ATTRIBS;
		static double SEPARATE_ATTRIBS;
		static double TRANSFORM_FEEDBACK_BUFFER;
		static double TRANSFORM_FEEDBACK_BUFFER_BINDING;
		static double RGBA32UI;
		static double RGB32UI;
		static double RGBA16UI;
		static double RGB16UI;
		static double RGBA8UI;
		static double RGB8UI;
		static double RGBA32I;
		static double RGB32I;
		static double RGBA16I;
		static double RGB16I;
		static double RGBA8I;
		static double RGB8I;
		static double RED_INTEGER;
		static double RGB_INTEGER;
		static double RGBA_INTEGER;
		static double SAMPLER_2D_ARRAY;
		static double SAMPLER_2D_ARRAY_SHADOW;
		static double SAMPLER_CUBE_SHADOW;
		static double UNSIGNED_INT_VEC2;
		static double UNSIGNED_INT_VEC3;
		static double UNSIGNED_INT_VEC4;
		static double INT_SAMPLER_2D;
		static double INT_SAMPLER_3D;
		static double INT_SAMPLER_CUBE;
		static double INT_SAMPLER_2D_ARRAY;
		static double UNSIGNED_INT_SAMPLER_2D;
		static double UNSIGNED_INT_SAMPLER_3D;
		static double UNSIGNED_INT_SAMPLER_CUBE;
		static double UNSIGNED_INT_SAMPLER_2D_ARRAY;
		static double DEPTH_COMPONENT32F;
		static double DEPTH32F_STENCIL8;
		static double FLOAT_32_UNSIGNED_INT_24_8_REV;
		static double FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING;
		static double FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE;
		static double FRAMEBUFFER_ATTACHMENT_RED_SIZE;
		static double FRAMEBUFFER_ATTACHMENT_GREEN_SIZE;
		static double FRAMEBUFFER_ATTACHMENT_BLUE_SIZE;
		static double FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE;
		static double FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE;
		static double FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE;
		static double FRAMEBUFFER_DEFAULT;
		static double UNSIGNED_INT_24_8;
		static double DEPTH24_STENCIL8;
		static double UNSIGNED_NORMALIZED;
		static double DRAW_FRAMEBUFFER_BINDING;
		static double READ_FRAMEBUFFER;
		static double DRAW_FRAMEBUFFER;
		static double READ_FRAMEBUFFER_BINDING;
		static double RENDERBUFFER_SAMPLES;
		static double FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER;
		static double MAX_COLOR_ATTACHMENTS;
		static double COLOR_ATTACHMENT1;
		static double COLOR_ATTACHMENT2;
		static double COLOR_ATTACHMENT3;
		static double COLOR_ATTACHMENT4;
		static double COLOR_ATTACHMENT5;
		static double COLOR_ATTACHMENT6;
		static double COLOR_ATTACHMENT7;
		static double COLOR_ATTACHMENT8;
		static double COLOR_ATTACHMENT9;
		static double COLOR_ATTACHMENT10;
		static double COLOR_ATTACHMENT11;
		static double COLOR_ATTACHMENT12;
		static double COLOR_ATTACHMENT13;
		static double COLOR_ATTACHMENT14;
		static double COLOR_ATTACHMENT15;
		static double FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
		static double MAX_SAMPLES;
		static double HALF_FLOAT;
		static double RG;
		static double RG_INTEGER;
		static double R8;
		static double RG8;
		static double R16F;
		static double R32F;
		static double RG16F;
		static double RG32F;
		static double R8I;
		static double R8UI;
		static double R16I;
		static double R16UI;
		static double R32I;
		static double R32UI;
		static double RG8I;
		static double RG8UI;
		static double RG16I;
		static double RG16UI;
		static double RG32I;
		static double RG32UI;
		static double VERTEX_ARRAY_BINDING;
		static double R8_SNORM;
		static double RG8_SNORM;
		static double RGB8_SNORM;
		static double RGBA8_SNORM;
		static double SIGNED_NORMALIZED;
		static double COPY_READ_BUFFER;
		static double COPY_WRITE_BUFFER;
		static double COPY_READ_BUFFER_BINDING;
		static double COPY_WRITE_BUFFER_BINDING;
		static double UNIFORM_BUFFER;
		static double UNIFORM_BUFFER_BINDING;
		static double UNIFORM_BUFFER_START;
		static double UNIFORM_BUFFER_SIZE;
		static double MAX_VERTEX_UNIFORM_BLOCKS;
		static double MAX_FRAGMENT_UNIFORM_BLOCKS;
		static double MAX_COMBINED_UNIFORM_BLOCKS;
		static double MAX_UNIFORM_BUFFER_BINDINGS;
		static double MAX_UNIFORM_BLOCK_SIZE;
		static double MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS;
		static double MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS;
		static double UNIFORM_BUFFER_OFFSET_ALIGNMENT;
		static double ACTIVE_UNIFORM_BLOCKS;
		static double UNIFORM_TYPE;
		static double UNIFORM_SIZE;
		static double UNIFORM_BLOCK_INDEX;
		static double UNIFORM_OFFSET;
		static double UNIFORM_ARRAY_STRIDE;
		static double UNIFORM_MATRIX_STRIDE;
		static double UNIFORM_IS_ROW_MAJOR;
		static double UNIFORM_BLOCK_BINDING;
		static double UNIFORM_BLOCK_DATA_SIZE;
		static double UNIFORM_BLOCK_ACTIVE_UNIFORMS;
		static double UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES;
		static double UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER;
		static double UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER;
		static double INVALID_INDEX;
		static double MAX_VERTEX_OUTPUT_COMPONENTS;
		static double MAX_FRAGMENT_INPUT_COMPONENTS;
		static double MAX_SERVER_WAIT_TIMEOUT;
		static double OBJECT_TYPE;
		static double SYNC_CONDITION;
		static double SYNC_STATUS;
		static double SYNC_FLAGS;
		static double SYNC_FENCE;
		static double SYNC_GPU_COMMANDS_COMPLETE;
		static double UNSIGNALED;
		static double SIGNALED;
		static double ALREADY_SIGNALED;
		static double TIMEOUT_EXPIRED;
		static double CONDITION_SATISFIED;
		static double WAIT_FAILED;
		static double SYNC_FLUSH_COMMANDS_BIT;
		static double VERTEX_ATTRIB_ARRAY_DIVISOR;
		static double ANY_SAMPLES_PASSED;
		static double ANY_SAMPLES_PASSED_CONSERVATIVE;
		static double SAMPLER_BINDING;
		static double RGB10_A2UI;
		static double INT_2_10_10_10_REV;
		static double TRANSFORM_FEEDBACK;
		static double TRANSFORM_FEEDBACK_PAUSED;
		static double TRANSFORM_FEEDBACK_ACTIVE;
		static double TRANSFORM_FEEDBACK_BINDING;
		static double TEXTURE_IMMUTABLE_FORMAT;
		static double MAX_ELEMENT_INDEX;
		static double TEXTURE_IMMUTABLE_LEVELS;
		static double TIMEOUT_IGNORED;
		static double MAX_CLIENT_WAIT_TIMEOUT_WEBGL;
		static double DEPTH_BUFFER_BIT;
		static double STENCIL_BUFFER_BIT;
		static double COLOR_BUFFER_BIT;
		static double POINTS;
		static double LINES;
		static double LINE_LOOP;
		static double LINE_STRIP;
		static double TRIANGLES;
		static double TRIANGLE_STRIP;
		static double TRIANGLE_FAN;
		static double ZERO;
		static double ONE;
		static double SRC_COLOR;
		static double ONE_MINUS_SRC_COLOR;
		static double SRC_ALPHA;
		static double ONE_MINUS_SRC_ALPHA;
		static double DST_ALPHA;
		static double ONE_MINUS_DST_ALPHA;
		static double DST_COLOR;
		static double ONE_MINUS_DST_COLOR;
		static double SRC_ALPHA_SATURATE;
		static double FUNC_ADD;
		static double BLEND_EQUATION;
		static double BLEND_EQUATION_RGB;
		static double BLEND_EQUATION_ALPHA;
		static double FUNC_SUBTRACT;
		static double FUNC_REVERSE_SUBTRACT;
		static double BLEND_DST_RGB;
		static double BLEND_SRC_RGB;
		static double BLEND_DST_ALPHA;
		static double BLEND_SRC_ALPHA;
		static double CONSTANT_COLOR;
		static double ONE_MINUS_CONSTANT_COLOR;
		static double CONSTANT_ALPHA;
		static double ONE_MINUS_CONSTANT_ALPHA;
		static double BLEND_COLOR;
		static double ARRAY_BUFFER;
		static double ELEMENT_ARRAY_BUFFER;
		static double ARRAY_BUFFER_BINDING;
		static double ELEMENT_ARRAY_BUFFER_BINDING;
		static double STREAM_DRAW;
		static double STATIC_DRAW;
		static double DYNAMIC_DRAW;
		static double BUFFER_SIZE;
		static double BUFFER_USAGE;
		static double CURRENT_VERTEX_ATTRIB;
		static double FRONT;
		static double BACK;
		static double FRONT_AND_BACK;
		static double CULL_FACE;
		static double BLEND;
		static double DITHER;
		static double STENCIL_TEST;
		static double DEPTH_TEST;
		static double SCISSOR_TEST;
		static double POLYGON_OFFSET_FILL;
		static double SAMPLE_ALPHA_TO_COVERAGE;
		static double SAMPLE_COVERAGE;
		static double NO_ERROR;
		static double INVALID_ENUM;
		static double INVALID_VALUE;
		static double INVALID_OPERATION;
		static double OUT_OF_MEMORY;
		static double CW;
		static double CCW;
		static double LINE_WIDTH;
		static double ALIASED_POINT_SIZE_RANGE;
		static double ALIASED_LINE_WIDTH_RANGE;
		static double CULL_FACE_MODE;
		static double FRONT_FACE;
		static double DEPTH_RANGE;
		static double DEPTH_WRITEMASK;
		static double DEPTH_CLEAR_VALUE;
		static double DEPTH_FUNC;
		static double STENCIL_CLEAR_VALUE;
		static double STENCIL_FUNC;
		static double STENCIL_FAIL;
		static double STENCIL_PASS_DEPTH_FAIL;
		static double STENCIL_PASS_DEPTH_PASS;
		static double STENCIL_REF;
		static double STENCIL_VALUE_MASK;
		static double STENCIL_WRITEMASK;
		static double STENCIL_BACK_FUNC;
		static double STENCIL_BACK_FAIL;
		static double STENCIL_BACK_PASS_DEPTH_FAIL;
		static double STENCIL_BACK_PASS_DEPTH_PASS;
		static double STENCIL_BACK_REF;
		static double STENCIL_BACK_VALUE_MASK;
		static double STENCIL_BACK_WRITEMASK;
		static double VIEWPORT;
		static double SCISSOR_BOX;
		static double COLOR_CLEAR_VALUE;
		static double COLOR_WRITEMASK;
		static double UNPACK_ALIGNMENT;
		static double PACK_ALIGNMENT;
		static double MAX_TEXTURE_SIZE;
		static double MAX_VIEWPORT_DIMS;
		static double SUBPIXEL_BITS;
		static double RED_BITS;
		static double GREEN_BITS;
		static double BLUE_BITS;
		static double ALPHA_BITS;
		static double DEPTH_BITS;
		static double STENCIL_BITS;
		static double POLYGON_OFFSET_UNITS;
		static double POLYGON_OFFSET_FACTOR;
		static double TEXTURE_BINDING_2D;
		static double SAMPLE_BUFFERS;
		static double SAMPLES;
		static double SAMPLE_COVERAGE_VALUE;
		static double SAMPLE_COVERAGE_INVERT;
		static double COMPRESSED_TEXTURE_FORMATS;
		static double DONT_CARE;
		static double FASTEST;
		static double NICEST;
		static double GENERATE_MIPMAP_HINT;
		static double BYTE;
		static double UNSIGNED_BYTE;
		static double SHORT;
		static double UNSIGNED_SHORT;
		static double INT;
		static double UNSIGNED_INT;
		static double FLOAT;
		static double DEPTH_COMPONENT;
		static double ALPHA;
		static double RGB;
		static double RGBA;
		static double LUMINANCE;
		static double LUMINANCE_ALPHA;
		static double UNSIGNED_SHORT_4_4_4_4;
		static double UNSIGNED_SHORT_5_5_5_1;
		static double UNSIGNED_SHORT_5_6_5;
		static double FRAGMENT_SHADER;
		static double VERTEX_SHADER;
		static double MAX_VERTEX_ATTRIBS;
		static double MAX_VERTEX_UNIFORM_VECTORS;
		static double MAX_VARYING_VECTORS;
		static double MAX_COMBINED_TEXTURE_IMAGE_UNITS;
		static double MAX_VERTEX_TEXTURE_IMAGE_UNITS;
		static double MAX_TEXTURE_IMAGE_UNITS;
		static double MAX_FRAGMENT_UNIFORM_VECTORS;
		static double SHADER_TYPE;
		static double DELETE_STATUS;
		static double LINK_STATUS;
		static double VALIDATE_STATUS;
		static double ATTACHED_SHADERS;
		static double ACTIVE_UNIFORMS;
		static double ACTIVE_ATTRIBUTES;
		static double SHADING_LANGUAGE_VERSION;
		static double CURRENT_PROGRAM;
		static double NEVER;
		static double LESS;
		static double EQUAL;
		static double LEQUAL;
		static double GREATER;
		static double NOTEQUAL;
		static double GEQUAL;
		static double ALWAYS;
		static double KEEP;
		static double REPLACE;
		static double INCR;
		static double DECR;
		static double INVERT;
		static double INCR_WRAP;
		static double DECR_WRAP;
		static double VENDOR;
		static double RENDERER;
		static double VERSION;
		static double NEAREST;
		static double LINEAR;
		static double NEAREST_MIPMAP_NEAREST;
		static double LINEAR_MIPMAP_NEAREST;
		static double NEAREST_MIPMAP_LINEAR;
		static double LINEAR_MIPMAP_LINEAR;
		static double TEXTURE_MAG_FILTER;
		static double TEXTURE_MIN_FILTER;
		static double TEXTURE_WRAP_S;
		static double TEXTURE_WRAP_T;
		static double TEXTURE_2D;
		static double TEXTURE;
		static double TEXTURE_CUBE_MAP;
		static double TEXTURE_BINDING_CUBE_MAP;
		static double TEXTURE_CUBE_MAP_POSITIVE_X;
		static double TEXTURE_CUBE_MAP_NEGATIVE_X;
		static double TEXTURE_CUBE_MAP_POSITIVE_Y;
		static double TEXTURE_CUBE_MAP_NEGATIVE_Y;
		static double TEXTURE_CUBE_MAP_POSITIVE_Z;
		static double TEXTURE_CUBE_MAP_NEGATIVE_Z;
		static double MAX_CUBE_MAP_TEXTURE_SIZE;
		static double TEXTURE0;
		static double TEXTURE1;
		static double TEXTURE2;
		static double TEXTURE3;
		static double TEXTURE4;
		static double TEXTURE5;
		static double TEXTURE6;
		static double TEXTURE7;
		static double TEXTURE8;
		static double TEXTURE9;
		static double TEXTURE10;
		static double TEXTURE11;
		static double TEXTURE12;
		static double TEXTURE13;
		static double TEXTURE14;
		static double TEXTURE15;
		static double TEXTURE16;
		static double TEXTURE17;
		static double TEXTURE18;
		static double TEXTURE19;
		static double TEXTURE20;
		static double TEXTURE21;
		static double TEXTURE22;
		static double TEXTURE23;
		static double TEXTURE24;
		static double TEXTURE25;
		static double TEXTURE26;
		static double TEXTURE27;
		static double TEXTURE28;
		static double TEXTURE29;
		static double TEXTURE30;
		static double TEXTURE31;
		static double ACTIVE_TEXTURE;
		static double REPEAT;
		static double CLAMP_TO_EDGE;
		static double MIRRORED_REPEAT;
		static double FLOAT_VEC2;
		static double FLOAT_VEC3;
		static double FLOAT_VEC4;
		static double INT_VEC2;
		static double INT_VEC3;
		static double INT_VEC4;
		static double BOOL;
		static double BOOL_VEC2;
		static double BOOL_VEC3;
		static double BOOL_VEC4;
		static double FLOAT_MAT2;
		static double FLOAT_MAT3;
		static double FLOAT_MAT4;
		static double SAMPLER_2D;
		static double SAMPLER_CUBE;
		static double VERTEX_ATTRIB_ARRAY_ENABLED;
		static double VERTEX_ATTRIB_ARRAY_SIZE;
		static double VERTEX_ATTRIB_ARRAY_STRIDE;
		static double VERTEX_ATTRIB_ARRAY_TYPE;
		static double VERTEX_ATTRIB_ARRAY_NORMALIZED;
		static double VERTEX_ATTRIB_ARRAY_POINTER;
		static double VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;
		static double IMPLEMENTATION_COLOR_READ_TYPE;
		static double IMPLEMENTATION_COLOR_READ_FORMAT;
		static double COMPILE_STATUS;
		static double LOW_FLOAT;
		static double MEDIUM_FLOAT;
		static double HIGH_FLOAT;
		static double LOW_INT;
		static double MEDIUM_INT;
		static double HIGH_INT;
		static double FRAMEBUFFER;
		static double RENDERBUFFER;
		static double RGBA4;
		static double RGB5_A1;
		static double RGB565;
		static double DEPTH_COMPONENT16;
		static double STENCIL_INDEX8;
		static double DEPTH_STENCIL;
		static double RENDERBUFFER_WIDTH;
		static double RENDERBUFFER_HEIGHT;
		static double RENDERBUFFER_INTERNAL_FORMAT;
		static double RENDERBUFFER_RED_SIZE;
		static double RENDERBUFFER_GREEN_SIZE;
		static double RENDERBUFFER_BLUE_SIZE;
		static double RENDERBUFFER_ALPHA_SIZE;
		static double RENDERBUFFER_DEPTH_SIZE;
		static double RENDERBUFFER_STENCIL_SIZE;
		static double FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;
		static double FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;
		static double FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;
		static double FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;
		static double COLOR_ATTACHMENT0;
		static double DEPTH_ATTACHMENT;
		static double STENCIL_ATTACHMENT;
		static double DEPTH_STENCIL_ATTACHMENT;
		static double NONE;
		static double FRAMEBUFFER_COMPLETE;
		static double FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
		static double FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
		static double FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
		static double FRAMEBUFFER_UNSUPPORTED;
		static double FRAMEBUFFER_BINDING;
		static double RENDERBUFFER_BINDING;
		static double MAX_RENDERBUFFER_SIZE;
		static double INVALID_FRAMEBUFFER_OPERATION;
		static double UNPACK_FLIP_Y_WEBGL;
		static double UNPACK_PREMULTIPLY_ALPHA_WEBGL;
		static double CONTEXT_LOST_WEBGL;
		static double UNPACK_COLORSPACE_CONVERSION_WEBGL;
		static double BROWSER_DEFAULT_WEBGL;
	};
	class WebGLActiveInfo: public Object {
	public:
		String* get_name();
		int get_size() const;
		double get_type();
		static WebGLActiveInfo* prototype;
		WebGLActiveInfo();
	};
	class WebGLBuffer: public Object {
	public:
		static WebGLBuffer* prototype;
		WebGLBuffer();
	};
	class WebGLContextEvent: public Event {
	public:
		String* get_statusMessage();
		static WebGLContextEvent* prototype;
		WebGLContextEvent(const String& type);
		WebGLContextEvent(const String& type, WebGLContextEventInit* eventInit);
	};
	class WebGLFramebuffer: public Object {
	public:
		static WebGLFramebuffer* prototype;
		WebGLFramebuffer();
	};
	class WebGLProgram: public Object {
	public:
		static WebGLProgram* prototype;
		WebGLProgram();
	};
	class WebGLQuery: public Object {
	public:
		static WebGLQuery* prototype;
		WebGLQuery();
	};
	class WebGLRenderbuffer: public Object {
	public:
		static WebGLRenderbuffer* prototype;
		WebGLRenderbuffer();
	};
	class WebGLRenderingContextOverloads: public virtual Object {
	public:
		void bufferData(double target, double size, double usage);
		void bufferData(double target, const _Union<ArrayBuffer*, ArrayBufferView*>& data, double usage);
		void bufferSubData(double target, double offset, const _Union<ArrayBuffer*, ArrayBufferView*>& data);
		void compressedTexImage2D(double target, double level, double internalformat, double width, double height, double border, ArrayBufferView* data);
		void compressedTexSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, ArrayBufferView* data);
		void readPixels(double x, double y, double width, double height, double format, double type, ArrayBufferView* pixels);
		void texImage2D(double target, double level, double internalformat, double width, double height, double border, double format, double type, ArrayBufferView* pixels);
		void texImage2D(double target, double level, double internalformat, double format, double type, const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, VideoFrame*>& source);
		void texSubImage2D(double target, double level, double xoffset, double yoffset, double width, double height, double format, double type, ArrayBufferView* pixels);
		void texSubImage2D(double target, double level, double xoffset, double yoffset, double format, double type, const _Union<HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, VideoFrame*>& source);
		void uniform1fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& v);
		void uniform1iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& v);
		void uniform2fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& v);
		void uniform2iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& v);
		void uniform3fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& v);
		void uniform3iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& v);
		void uniform4fv(WebGLUniformLocation* location, const _Union<Float32Array*, TArray<double>*>& v);
		void uniform4iv(WebGLUniformLocation* location, const _Union<Int32Array*, TArray<double>*>& v);
		void uniformMatrix2fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& value);
		void uniformMatrix3fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& value);
		void uniformMatrix4fv(WebGLUniformLocation* location, bool transpose, const _Union<Float32Array*, TArray<double>*>& value);
	};
	class WebGLRenderingContext: public WebGLRenderingContextBase, public WebGLRenderingContextOverloads {
	public:
		static WebGLRenderingContext* prototype;
		WebGLRenderingContext();
		static double DEPTH_BUFFER_BIT;
		static double STENCIL_BUFFER_BIT;
		static double COLOR_BUFFER_BIT;
		static double POINTS;
		static double LINES;
		static double LINE_LOOP;
		static double LINE_STRIP;
		static double TRIANGLES;
		static double TRIANGLE_STRIP;
		static double TRIANGLE_FAN;
		static double ZERO;
		static double ONE;
		static double SRC_COLOR;
		static double ONE_MINUS_SRC_COLOR;
		static double SRC_ALPHA;
		static double ONE_MINUS_SRC_ALPHA;
		static double DST_ALPHA;
		static double ONE_MINUS_DST_ALPHA;
		static double DST_COLOR;
		static double ONE_MINUS_DST_COLOR;
		static double SRC_ALPHA_SATURATE;
		static double FUNC_ADD;
		static double BLEND_EQUATION;
		static double BLEND_EQUATION_RGB;
		static double BLEND_EQUATION_ALPHA;
		static double FUNC_SUBTRACT;
		static double FUNC_REVERSE_SUBTRACT;
		static double BLEND_DST_RGB;
		static double BLEND_SRC_RGB;
		static double BLEND_DST_ALPHA;
		static double BLEND_SRC_ALPHA;
		static double CONSTANT_COLOR;
		static double ONE_MINUS_CONSTANT_COLOR;
		static double CONSTANT_ALPHA;
		static double ONE_MINUS_CONSTANT_ALPHA;
		static double BLEND_COLOR;
		static double ARRAY_BUFFER;
		static double ELEMENT_ARRAY_BUFFER;
		static double ARRAY_BUFFER_BINDING;
		static double ELEMENT_ARRAY_BUFFER_BINDING;
		static double STREAM_DRAW;
		static double STATIC_DRAW;
		static double DYNAMIC_DRAW;
		static double BUFFER_SIZE;
		static double BUFFER_USAGE;
		static double CURRENT_VERTEX_ATTRIB;
		static double FRONT;
		static double BACK;
		static double FRONT_AND_BACK;
		static double CULL_FACE;
		static double BLEND;
		static double DITHER;
		static double STENCIL_TEST;
		static double DEPTH_TEST;
		static double SCISSOR_TEST;
		static double POLYGON_OFFSET_FILL;
		static double SAMPLE_ALPHA_TO_COVERAGE;
		static double SAMPLE_COVERAGE;
		static double NO_ERROR;
		static double INVALID_ENUM;
		static double INVALID_VALUE;
		static double INVALID_OPERATION;
		static double OUT_OF_MEMORY;
		static double CW;
		static double CCW;
		static double LINE_WIDTH;
		static double ALIASED_POINT_SIZE_RANGE;
		static double ALIASED_LINE_WIDTH_RANGE;
		static double CULL_FACE_MODE;
		static double FRONT_FACE;
		static double DEPTH_RANGE;
		static double DEPTH_WRITEMASK;
		static double DEPTH_CLEAR_VALUE;
		static double DEPTH_FUNC;
		static double STENCIL_CLEAR_VALUE;
		static double STENCIL_FUNC;
		static double STENCIL_FAIL;
		static double STENCIL_PASS_DEPTH_FAIL;
		static double STENCIL_PASS_DEPTH_PASS;
		static double STENCIL_REF;
		static double STENCIL_VALUE_MASK;
		static double STENCIL_WRITEMASK;
		static double STENCIL_BACK_FUNC;
		static double STENCIL_BACK_FAIL;
		static double STENCIL_BACK_PASS_DEPTH_FAIL;
		static double STENCIL_BACK_PASS_DEPTH_PASS;
		static double STENCIL_BACK_REF;
		static double STENCIL_BACK_VALUE_MASK;
		static double STENCIL_BACK_WRITEMASK;
		static double VIEWPORT;
		static double SCISSOR_BOX;
		static double COLOR_CLEAR_VALUE;
		static double COLOR_WRITEMASK;
		static double UNPACK_ALIGNMENT;
		static double PACK_ALIGNMENT;
		static double MAX_TEXTURE_SIZE;
		static double MAX_VIEWPORT_DIMS;
		static double SUBPIXEL_BITS;
		static double RED_BITS;
		static double GREEN_BITS;
		static double BLUE_BITS;
		static double ALPHA_BITS;
		static double DEPTH_BITS;
		static double STENCIL_BITS;
		static double POLYGON_OFFSET_UNITS;
		static double POLYGON_OFFSET_FACTOR;
		static double TEXTURE_BINDING_2D;
		static double SAMPLE_BUFFERS;
		static double SAMPLES;
		static double SAMPLE_COVERAGE_VALUE;
		static double SAMPLE_COVERAGE_INVERT;
		static double COMPRESSED_TEXTURE_FORMATS;
		static double DONT_CARE;
		static double FASTEST;
		static double NICEST;
		static double GENERATE_MIPMAP_HINT;
		static double BYTE;
		static double UNSIGNED_BYTE;
		static double SHORT;
		static double UNSIGNED_SHORT;
		static double INT;
		static double UNSIGNED_INT;
		static double FLOAT;
		static double DEPTH_COMPONENT;
		static double ALPHA;
		static double RGB;
		static double RGBA;
		static double LUMINANCE;
		static double LUMINANCE_ALPHA;
		static double UNSIGNED_SHORT_4_4_4_4;
		static double UNSIGNED_SHORT_5_5_5_1;
		static double UNSIGNED_SHORT_5_6_5;
		static double FRAGMENT_SHADER;
		static double VERTEX_SHADER;
		static double MAX_VERTEX_ATTRIBS;
		static double MAX_VERTEX_UNIFORM_VECTORS;
		static double MAX_VARYING_VECTORS;
		static double MAX_COMBINED_TEXTURE_IMAGE_UNITS;
		static double MAX_VERTEX_TEXTURE_IMAGE_UNITS;
		static double MAX_TEXTURE_IMAGE_UNITS;
		static double MAX_FRAGMENT_UNIFORM_VECTORS;
		static double SHADER_TYPE;
		static double DELETE_STATUS;
		static double LINK_STATUS;
		static double VALIDATE_STATUS;
		static double ATTACHED_SHADERS;
		static double ACTIVE_UNIFORMS;
		static double ACTIVE_ATTRIBUTES;
		static double SHADING_LANGUAGE_VERSION;
		static double CURRENT_PROGRAM;
		static double NEVER;
		static double LESS;
		static double EQUAL;
		static double LEQUAL;
		static double GREATER;
		static double NOTEQUAL;
		static double GEQUAL;
		static double ALWAYS;
		static double KEEP;
		static double REPLACE;
		static double INCR;
		static double DECR;
		static double INVERT;
		static double INCR_WRAP;
		static double DECR_WRAP;
		static double VENDOR;
		static double RENDERER;
		static double VERSION;
		static double NEAREST;
		static double LINEAR;
		static double NEAREST_MIPMAP_NEAREST;
		static double LINEAR_MIPMAP_NEAREST;
		static double NEAREST_MIPMAP_LINEAR;
		static double LINEAR_MIPMAP_LINEAR;
		static double TEXTURE_MAG_FILTER;
		static double TEXTURE_MIN_FILTER;
		static double TEXTURE_WRAP_S;
		static double TEXTURE_WRAP_T;
		static double TEXTURE_2D;
		static double TEXTURE;
		static double TEXTURE_CUBE_MAP;
		static double TEXTURE_BINDING_CUBE_MAP;
		static double TEXTURE_CUBE_MAP_POSITIVE_X;
		static double TEXTURE_CUBE_MAP_NEGATIVE_X;
		static double TEXTURE_CUBE_MAP_POSITIVE_Y;
		static double TEXTURE_CUBE_MAP_NEGATIVE_Y;
		static double TEXTURE_CUBE_MAP_POSITIVE_Z;
		static double TEXTURE_CUBE_MAP_NEGATIVE_Z;
		static double MAX_CUBE_MAP_TEXTURE_SIZE;
		static double TEXTURE0;
		static double TEXTURE1;
		static double TEXTURE2;
		static double TEXTURE3;
		static double TEXTURE4;
		static double TEXTURE5;
		static double TEXTURE6;
		static double TEXTURE7;
		static double TEXTURE8;
		static double TEXTURE9;
		static double TEXTURE10;
		static double TEXTURE11;
		static double TEXTURE12;
		static double TEXTURE13;
		static double TEXTURE14;
		static double TEXTURE15;
		static double TEXTURE16;
		static double TEXTURE17;
		static double TEXTURE18;
		static double TEXTURE19;
		static double TEXTURE20;
		static double TEXTURE21;
		static double TEXTURE22;
		static double TEXTURE23;
		static double TEXTURE24;
		static double TEXTURE25;
		static double TEXTURE26;
		static double TEXTURE27;
		static double TEXTURE28;
		static double TEXTURE29;
		static double TEXTURE30;
		static double TEXTURE31;
		static double ACTIVE_TEXTURE;
		static double REPEAT;
		static double CLAMP_TO_EDGE;
		static double MIRRORED_REPEAT;
		static double FLOAT_VEC2;
		static double FLOAT_VEC3;
		static double FLOAT_VEC4;
		static double INT_VEC2;
		static double INT_VEC3;
		static double INT_VEC4;
		static double BOOL;
		static double BOOL_VEC2;
		static double BOOL_VEC3;
		static double BOOL_VEC4;
		static double FLOAT_MAT2;
		static double FLOAT_MAT3;
		static double FLOAT_MAT4;
		static double SAMPLER_2D;
		static double SAMPLER_CUBE;
		static double VERTEX_ATTRIB_ARRAY_ENABLED;
		static double VERTEX_ATTRIB_ARRAY_SIZE;
		static double VERTEX_ATTRIB_ARRAY_STRIDE;
		static double VERTEX_ATTRIB_ARRAY_TYPE;
		static double VERTEX_ATTRIB_ARRAY_NORMALIZED;
		static double VERTEX_ATTRIB_ARRAY_POINTER;
		static double VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;
		static double IMPLEMENTATION_COLOR_READ_TYPE;
		static double IMPLEMENTATION_COLOR_READ_FORMAT;
		static double COMPILE_STATUS;
		static double LOW_FLOAT;
		static double MEDIUM_FLOAT;
		static double HIGH_FLOAT;
		static double LOW_INT;
		static double MEDIUM_INT;
		static double HIGH_INT;
		static double FRAMEBUFFER;
		static double RENDERBUFFER;
		static double RGBA4;
		static double RGB5_A1;
		static double RGB565;
		static double DEPTH_COMPONENT16;
		static double STENCIL_INDEX8;
		static double DEPTH_STENCIL;
		static double RENDERBUFFER_WIDTH;
		static double RENDERBUFFER_HEIGHT;
		static double RENDERBUFFER_INTERNAL_FORMAT;
		static double RENDERBUFFER_RED_SIZE;
		static double RENDERBUFFER_GREEN_SIZE;
		static double RENDERBUFFER_BLUE_SIZE;
		static double RENDERBUFFER_ALPHA_SIZE;
		static double RENDERBUFFER_DEPTH_SIZE;
		static double RENDERBUFFER_STENCIL_SIZE;
		static double FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;
		static double FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;
		static double FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;
		static double FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;
		static double COLOR_ATTACHMENT0;
		static double DEPTH_ATTACHMENT;
		static double STENCIL_ATTACHMENT;
		static double DEPTH_STENCIL_ATTACHMENT;
		static double NONE;
		static double FRAMEBUFFER_COMPLETE;
		static double FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
		static double FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
		static double FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
		static double FRAMEBUFFER_UNSUPPORTED;
		static double FRAMEBUFFER_BINDING;
		static double RENDERBUFFER_BINDING;
		static double MAX_RENDERBUFFER_SIZE;
		static double INVALID_FRAMEBUFFER_OPERATION;
		static double UNPACK_FLIP_Y_WEBGL;
		static double UNPACK_PREMULTIPLY_ALPHA_WEBGL;
		static double CONTEXT_LOST_WEBGL;
		static double UNPACK_COLORSPACE_CONVERSION_WEBGL;
		static double BROWSER_DEFAULT_WEBGL;
	};
	class WebGLSampler: public Object {
	public:
		static WebGLSampler* prototype;
		WebGLSampler();
	};
	class WebGLShader: public Object {
	public:
		static WebGLShader* prototype;
		WebGLShader();
	};
	class WebGLShaderPrecisionFormat: public Object {
	public:
		double get_precision();
		double get_rangeMax();
		double get_rangeMin();
		static WebGLShaderPrecisionFormat* prototype;
		WebGLShaderPrecisionFormat();
	};
	class WebGLSync: public Object {
	public:
		static WebGLSync* prototype;
		WebGLSync();
	};
	class WebGLTexture: public Object {
	public:
		static WebGLTexture* prototype;
		WebGLTexture();
	};
	class WebGLTransformFeedback: public Object {
	public:
		static WebGLTransformFeedback* prototype;
		WebGLTransformFeedback();
	};
	class WebGLUniformLocation: public Object {
	public:
		static WebGLUniformLocation* prototype;
		WebGLUniformLocation();
	};
	class WebGLVertexArrayObject: public Object {
	public:
		static WebGLVertexArrayObject* prototype;
		WebGLVertexArrayObject();
	};
	class WebGLVertexArrayObjectOES: public Object {
	};
	class WebSocketEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"close\""))]]
		CloseEvent* get__34_close_34_();
		[[cheerp::interface_name(("set_\"close\""))]]
		void set__34_close_34_(CloseEvent* _34_close_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		Event* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(Event* _34_error_34_);
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"open\""))]]
		Event* get__34_open_34_();
		[[cheerp::interface_name(("set_\"open\""))]]
		void set__34_open_34_(Event* _34_open_34_);
	};
	class WebSocket: public EventTarget {
	public:
		String* get_binaryType();
		void set_binaryType(const String& binaryType);
		double get_bufferedAmount();
		String* get_extensions();
		_Function<_Any*(CloseEvent*)>* get_onclose();
		void set_onclose(EventListener* onclose);
		void set_onclose(const _Function<_Any*(CloseEvent*)>& onclose);
		_Function<_Any*(Event*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(Event*)>& onerror);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(Event*)>* get_onopen();
		void set_onopen(EventListener* onopen);
		void set_onopen(const _Function<_Any*(Event*)>& onopen);
		String* get_protocol();
		double get_readyState();
		String* get_url();
		void close();
		void close(double code);
		void close(double code, const String& reason);
		void send(const String& data);
		void send(const _Union<ArrayBuffer*, SharedArrayBuffer*, ArrayBufferView*, Blob*>& data);
		double get_CONNECTING();
		double get_OPEN();
		double get_CLOSING();
		double get_CLOSED();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static WebSocket* prototype;
		WebSocket(const String& url);
		WebSocket(URL* url);
		WebSocket(const String& url, const String& protocols);
		WebSocket(URL* url, const String& protocols);
		WebSocket(const String& url, TArray<String*>* protocols);
		WebSocket(URL* url, TArray<String*>* protocols);
		static double CONNECTING;
		static double OPEN;
		static double CLOSING;
		static double CLOSED;
	};
	class WebTransportDatagramDuplexStream;
	class WebTransportBidirectionalStream;
	class WebTransport: public Object {
	public:
		Promise<WebTransportCloseInfo*>* get_closed();
		WebTransportDatagramDuplexStream* get_datagrams();
		ReadableStream<_Any*>* get_incomingBidirectionalStreams();
		ReadableStream<_Any*>* get_incomingUnidirectionalStreams();
		Promise<_Any*>* get_ready();
		void close();
		void close(WebTransportCloseInfo* closeInfo);
		Promise<WebTransportBidirectionalStream*>* createBidirectionalStream();
		Promise<WebTransportBidirectionalStream*>* createBidirectionalStream(WebTransportSendStreamOptions* options);
		Promise<WritableStream<_Any*>*>* createUnidirectionalStream();
		Promise<WritableStream<_Any*>*>* createUnidirectionalStream(WebTransportSendStreamOptions* options);
		static WebTransport* prototype;
		WebTransport(const String& url);
		WebTransport(URL* url);
		WebTransport(const String& url, WebTransportOptions* options);
		WebTransport(URL* url, WebTransportOptions* options);
	};
	class WebTransportBidirectionalStream: public Object {
	public:
		ReadableStream<_Any*>* get_readable();
		WritableStream<_Any*>* get_writable();
		static WebTransportBidirectionalStream* prototype;
		WebTransportBidirectionalStream();
	};
	class WebTransportDatagramDuplexStream: public Object {
	public:
		double get_incomingHighWaterMark();
		void set_incomingHighWaterMark(double incomingHighWaterMark);
		double get_incomingMaxAge();
		void set_incomingMaxAge(double incomingMaxAge);
		double get_maxDatagramSize();
		double get_outgoingHighWaterMark();
		void set_outgoingHighWaterMark(double outgoingHighWaterMark);
		double get_outgoingMaxAge();
		void set_outgoingMaxAge(double outgoingMaxAge);
		ReadableStream<_Any*>* get_readable();
		WritableStream<_Any*>* get_writable();
		static WebTransportDatagramDuplexStream* prototype;
		WebTransportDatagramDuplexStream();
	};
	class WebTransportError: public DOMException {
	public:
		String* get_source();
		double get_streamErrorCode();
		static WebTransportError* prototype;
		WebTransportError();
		WebTransportError(const String& message);
		WebTransportError(const String& message, WebTransportErrorOptions* options);
	};
	class WheelEvent: public MouseEvent {
	public:
		double get_deltaMode();
		double get_deltaX();
		double get_deltaY();
		double get_deltaZ();
		double get_DOM_DELTA_PIXEL();
		double get_DOM_DELTA_LINE();
		double get_DOM_DELTA_PAGE();
		static WheelEvent* prototype;
		WheelEvent(const String& type);
		WheelEvent(const String& type, WheelEventInit* eventInitDict);
		static double DOM_DELTA_PIXEL;
		static double DOM_DELTA_LINE;
		static double DOM_DELTA_PAGE;
	};
	class WindowEventMap: public GlobalEventHandlersEventMap, public WindowEventHandlersEventMap {
	public:
		[[cheerp::interface_name(("get_\"DOMContentLoaded\""))]]
		Event* get__34_DOMContentLoaded_34_();
		[[cheerp::interface_name(("set_\"DOMContentLoaded\""))]]
		void set__34_DOMContentLoaded_34_(Event* _34_DOMContentLoaded_34_);
		[[cheerp::interface_name(("get_\"devicemotion\""))]]
		DeviceMotionEvent* get__34_devicemotion_34_();
		[[cheerp::interface_name(("set_\"devicemotion\""))]]
		void set__34_devicemotion_34_(DeviceMotionEvent* _34_devicemotion_34_);
		[[cheerp::interface_name(("get_\"deviceorientation\""))]]
		DeviceOrientationEvent* get__34_deviceorientation_34_();
		[[cheerp::interface_name(("set_\"deviceorientation\""))]]
		void set__34_deviceorientation_34_(DeviceOrientationEvent* _34_deviceorientation_34_);
		[[cheerp::interface_name(("get_\"gamepadconnected\""))]]
		GamepadEvent* get__34_gamepadconnected_34_();
		[[cheerp::interface_name(("set_\"gamepadconnected\""))]]
		void set__34_gamepadconnected_34_(GamepadEvent* _34_gamepadconnected_34_);
		[[cheerp::interface_name(("get_\"gamepaddisconnected\""))]]
		GamepadEvent* get__34_gamepaddisconnected_34_();
		[[cheerp::interface_name(("set_\"gamepaddisconnected\""))]]
		void set__34_gamepaddisconnected_34_(GamepadEvent* _34_gamepaddisconnected_34_);
		[[cheerp::interface_name(("get_\"orientationchange\""))]]
		Event* get__34_orientationchange_34_();
		[[cheerp::interface_name(("set_\"orientationchange\""))]]
		void set__34_orientationchange_34_(Event* _34_orientationchange_34_);
	};
	class WindowLocalStorage: public virtual Object {
	public:
		Storage* get_localStorage();
	};
	class WindowOrWorkerGlobalScope: public virtual Object {
	public:
		CacheStorage* get_caches();
		bool get_crossOriginIsolated();
		Crypto* get_crypto();
		IDBFactory* get_indexedDB();
		bool get_isSecureContext();
		String* get_origin();
		Performance* get_performance();
		String* atob(const String& data);
		String* btoa(const String& data);
		void clearInterval(double id);
		void clearTimeout(double id);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, ImageBitmapOptions* options);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh, ImageBitmapOptions* options);
		Promise<Response*>* fetch(const String& input);
		Promise<Response*>* fetch(const _Union<Request*, URL*>& input);
		Promise<Response*>* fetch(const String& input, RequestInit* init);
		Promise<Response*>* fetch(const _Union<Request*, URL*>& input, RequestInit* init);
		void queueMicrotask(EventListener* callback);
		void queueMicrotask(const _Function<void()>& callback);
		void reportError(const _Any& e);
		double setInterval(const String& handler);
		double setInterval(const _Function<void()>& handler);
		double setInterval(Function* handler);
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(const String& handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(const _Function<void()>& handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(Function* handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("setInterval"))]]
		_Any* _setInterval(_Args... data);
	public:
		double setTimeout(const String& handler);
		double setTimeout(const _Function<void()>& handler);
		double setTimeout(Function* handler);
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(const String& handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(const _Function<void()>& handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(Function* handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("setTimeout"))]]
		_Any* _setTimeout(_Args... data);
	public:
		template<class _T0 = _Any*>
		_T0 structuredClone(_T0 value);
		template<class _T0 = _Any*>
		_T0 structuredClone(_T0 value, StructuredSerializeOptions* options);
	};
	class WindowSessionStorage: public virtual Object {
	public:
		Storage* get_sessionStorage();
	};
	class Window: public EventTarget, public AnimationFrameProvider, public GlobalEventHandlers, public WindowEventHandlers, public WindowLocalStorage, public WindowOrWorkerGlobalScope, public WindowSessionStorage {
	public:
		Object* eval(const String& x);
		double parseInt(const String& string);
		double parseInt(const String& string, double radix);
		double parseFloat(const String& string);
		bool isNaN(double number);
		bool isFinite(double number);
		String* decodeURI(const String& encodedURI);
		String* decodeURIComponent(const String& encodedURIComponent);
		String* encodeURI(const String& uri);
		String* encodeURIComponent(const String& uriComponent);
		String* encodeURIComponent(const _Union<double, bool>& uriComponent);
		String* escape(const String& string);
		String* unescape(const String& string);
		Navigator* get_clientInformation();
		bool get_closed();
		CustomElementRegistry* get_customElements();
		double get_devicePixelRatio();
		Document* get_document();
		Event* get_event();
		External* get_external();
		Element* get_frameElement();
		Window* get_frames();
		History* get_history();
		double get_innerHeight();
		double get_innerWidth();
		int get_length() const;
		Location* get_location();
		Object* set_location(const String& href);
		Object* set_location(Location* href);
		BarProp* get_locationbar();
		BarProp* get_menubar();
		String* get_name();
		void set_name(const String& name);
		Navigator* get_navigator();
		_Function<_Any*(DeviceMotionEvent*)>* get_ondevicemotion();
		void set_ondevicemotion(EventListener* ondevicemotion);
		void set_ondevicemotion(const _Function<_Any*(DeviceMotionEvent*)>& ondevicemotion);
		_Function<_Any*(DeviceOrientationEvent*)>* get_ondeviceorientation();
		void set_ondeviceorientation(EventListener* ondeviceorientation);
		void set_ondeviceorientation(const _Function<_Any*(DeviceOrientationEvent*)>& ondeviceorientation);
		_Function<_Any*(Event*)>* get_onorientationchange();
		void set_onorientationchange(EventListener* onorientationchange);
		void set_onorientationchange(const _Function<_Any*(Event*)>& onorientationchange);
		Object* get_opener();
		void set_opener(const _Any& opener);
		double get_orientation();
		double get_outerHeight();
		double get_outerWidth();
		double get_pageXOffset();
		double get_pageYOffset();
		Window* get_parent();
		BarProp* get_personalbar();
		Screen* get_screen();
		double get_screenLeft();
		double get_screenTop();
		double get_screenX();
		double get_screenY();
		double get_scrollX();
		double get_scrollY();
		BarProp* get_scrollbars();
		Window* get_self();
		SpeechSynthesis* get_speechSynthesis();
		String* get_status();
		void set_status(const String& status);
		BarProp* get_statusbar();
		BarProp* get_toolbar();
		Window* get_top();
		VisualViewport* get_visualViewport();
		Window* get_window();
		void alert();
		void alert(const _Any& message);
		void blur();
		void cancelIdleCallback(double handle);
		void captureEvents();
		void close();
		bool confirm();
		bool confirm(const String& message);
		void focus();
		CSSStyleDeclaration* getComputedStyle(Element* elt);
		CSSStyleDeclaration* getComputedStyle(Element* elt, const String& pseudoElt);
		Selection* getSelection();
		MediaQueryList* matchMedia(const String& query);
		void moveBy(double x, double y);
		void moveTo(double x, double y);
		Window* open();
		Window* open(const String& url);
		Window* open(URL* url);
		Window* open(const String& url, const String& target);
		Window* open(URL* url, const String& target);
		Window* open(const String& url, const String& target, const String& features);
		Window* open(URL* url, const String& target, const String& features);
		void postMessage(const _Any& message, const String& targetOrigin);
		void postMessage(const _Any& message, const String& targetOrigin, Array* transfer);
		void postMessage(const _Any& message);
		void postMessage(const _Any& message, WindowPostMessageOptions* options);
		void postMessage(const _Any& message, Array* transfer);
		void postMessage(const _Any& message, StructuredSerializeOptions* options);
		void print();
		String* prompt();
		String* prompt(const String& message);
		String* prompt(const String& message, const String& _default);
		void releaseEvents();
		double requestIdleCallback(EventListener* callback);
		double requestIdleCallback(const _Function<void(IdleDeadline*)>& callback);
		double requestIdleCallback(EventListener* callback, IdleRequestOptions* options);
		double requestIdleCallback(const _Function<void(IdleDeadline*)>& callback, IdleRequestOptions* options);
		void resizeBy(double x, double y);
		void resizeTo(double width, double height);
		void scroll();
		void scroll(ScrollToOptions* options);
		void scroll(double x, double y);
		void scrollBy();
		void scrollBy(ScrollToOptions* options);
		void scrollBy(double x, double y);
		void scrollTo();
		void scrollTo(ScrollToOptions* options);
		void scrollTo(double x, double y);
		void stop();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		Window* operator[](double index) const;
#ifndef LEAN_CXX_LIB
		Window*& operator[](double index) {
			return __builtin_cheerp_make_regular<Window*>(this, 0)[static_cast<int>(index)];
		}
#endif
		static Window* prototype;
		Window();
		String* toString();
		bool dispatchEvent(Event* event);
		void cancelAnimationFrame(double handle);
		double requestAnimationFrame(EventListener* callback);
		double requestAnimationFrame(const _Function<void(double)>& callback);
		String* atob(const String& data);
		String* btoa(const String& data);
		void clearInterval(double id);
		void clearTimeout(double id);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, ImageBitmapOptions* options);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh, ImageBitmapOptions* options);
		Promise<Response*>* fetch(const String& input);
		Promise<Response*>* fetch(const _Union<Request*, URL*>& input);
		Promise<Response*>* fetch(const String& input, RequestInit* init);
		Promise<Response*>* fetch(const _Union<Request*, URL*>& input, RequestInit* init);
		void queueMicrotask(EventListener* callback);
		void queueMicrotask(const _Function<void()>& callback);
		void reportError(const _Any& e);
		double setInterval(const String& handler);
		double setInterval(const _Function<void()>& handler);
		double setInterval(Function* handler);
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(const String& handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(const _Function<void()>& handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(Function* handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("setInterval"))]]
		_Any* _setInterval(_Args... data);
	public:
		double setTimeout(const String& handler);
		double setTimeout(const _Function<void()>& handler);
		double setTimeout(Function* handler);
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(const String& handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(const _Function<void()>& handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(Function* handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("setTimeout"))]]
		_Any* _setTimeout(_Args... data);
	public:
		template<class _T0 = _Any*>
		_T0 structuredClone(_T0 value);
		template<class _T0 = _Any*>
		_T0 structuredClone(_T0 value, StructuredSerializeOptions* options);
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, String*> && ...), void> importScripts(_Args... urls) {
			_importScripts(cheerp::clientCast(urls)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("importScripts"))]]
		_Any* _importScripts(_Args... data);
	public:
		using client::Object::operator[];
	};
	class WorkerEventMap: public AbstractWorkerEventMap {
	public:
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"messageerror\""))]]
		MessageEvent<_Any*>* get__34_messageerror_34_();
		[[cheerp::interface_name(("set_\"messageerror\""))]]
		void set__34_messageerror_34_(MessageEvent<_Any*>* _34_messageerror_34_);
	};
	class Worker: public EventTarget, public AbstractWorker {
	public:
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessageerror();
		void set_onmessageerror(EventListener* onmessageerror);
		void set_onmessageerror(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessageerror);
		void postMessage(const _Any& message, Array* transfer);
		void postMessage(const _Any& message);
		void postMessage(const _Any& message, StructuredSerializeOptions* options);
		void terminate();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static Worker* prototype;
		Worker(const String& scriptURL);
		Worker(URL* scriptURL);
		Worker(const String& scriptURL, WorkerOptions* options);
		Worker(URL* scriptURL, WorkerOptions* options);
	};
	class WritableStreamDefaultController: public Object {
	public:
		AbortSignal* get_signal();
		void error();
		void error(const _Any& e);
		static WritableStreamDefaultController* prototype;
		WritableStreamDefaultController();
	};
	template<class _T0>
	class WritableStreamDefaultWriter: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		Promise<_Any*>* get_closed();
		double get_desiredSize();
		Promise<_Any*>* get_ready();
		Promise<_Any*>* abort();
		Promise<_Any*>* abort(const _Any& reason);
		Promise<_Any*>* close();
		void releaseLock();
		Promise<_Any*>* write();
		Promise<_Any*>* write(_T0 chunk);
		static WritableStreamDefaultWriter<_Any*>* prototype;
		template<class _T1 = _Any*>
		WritableStreamDefaultWriter(WritableStream<_T1>* stream);
	};
	class XMLDocument: public Document {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static XMLDocument* prototype;
		XMLDocument();
	};
	class XMLHttpRequestEventTarget;
	class XMLHttpRequestEventTargetEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"abort\""))]]
		ProgressEvent<XMLHttpRequestEventTarget*>* get__34_abort_34_();
		[[cheerp::interface_name(("set_\"abort\""))]]
		void set__34_abort_34_(ProgressEvent<XMLHttpRequestEventTarget*>* _34_abort_34_);
		[[cheerp::interface_name(("get_\"error\""))]]
		ProgressEvent<XMLHttpRequestEventTarget*>* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(ProgressEvent<XMLHttpRequestEventTarget*>* _34_error_34_);
		[[cheerp::interface_name(("get_\"load\""))]]
		ProgressEvent<XMLHttpRequestEventTarget*>* get__34_load_34_();
		[[cheerp::interface_name(("set_\"load\""))]]
		void set__34_load_34_(ProgressEvent<XMLHttpRequestEventTarget*>* _34_load_34_);
		[[cheerp::interface_name(("get_\"loadend\""))]]
		ProgressEvent<XMLHttpRequestEventTarget*>* get__34_loadend_34_();
		[[cheerp::interface_name(("set_\"loadend\""))]]
		void set__34_loadend_34_(ProgressEvent<XMLHttpRequestEventTarget*>* _34_loadend_34_);
		[[cheerp::interface_name(("get_\"loadstart\""))]]
		ProgressEvent<XMLHttpRequestEventTarget*>* get__34_loadstart_34_();
		[[cheerp::interface_name(("set_\"loadstart\""))]]
		void set__34_loadstart_34_(ProgressEvent<XMLHttpRequestEventTarget*>* _34_loadstart_34_);
		[[cheerp::interface_name(("get_\"progress\""))]]
		ProgressEvent<XMLHttpRequestEventTarget*>* get__34_progress_34_();
		[[cheerp::interface_name(("set_\"progress\""))]]
		void set__34_progress_34_(ProgressEvent<XMLHttpRequestEventTarget*>* _34_progress_34_);
		[[cheerp::interface_name(("get_\"timeout\""))]]
		ProgressEvent<XMLHttpRequestEventTarget*>* get__34_timeout_34_();
		[[cheerp::interface_name(("set_\"timeout\""))]]
		void set__34_timeout_34_(ProgressEvent<XMLHttpRequestEventTarget*>* _34_timeout_34_);
	};
	class XMLHttpRequestEventMap: public XMLHttpRequestEventTargetEventMap {
	public:
		[[cheerp::interface_name(("get_\"readystatechange\""))]]
		Event* get__34_readystatechange_34_();
		[[cheerp::interface_name(("set_\"readystatechange\""))]]
		void set__34_readystatechange_34_(Event* _34_readystatechange_34_);
	};
	class XMLHttpRequestUpload;
	class XMLHttpRequestEventTarget: public EventTarget {
	public:
		_Function<_Any*(ProgressEvent<EventTarget*>*)>* get_onabort();
		void set_onabort(EventListener* onabort);
		void set_onabort(const _Function<_Any*(ProgressEvent<EventTarget*>*)>& onabort);
		_Function<_Any*(ProgressEvent<EventTarget*>*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(ProgressEvent<EventTarget*>*)>& onerror);
		_Function<_Any*(ProgressEvent<EventTarget*>*)>* get_onload();
		void set_onload(EventListener* onload);
		void set_onload(const _Function<_Any*(ProgressEvent<EventTarget*>*)>& onload);
		_Function<_Any*(ProgressEvent<EventTarget*>*)>* get_onloadend();
		void set_onloadend(EventListener* onloadend);
		void set_onloadend(const _Function<_Any*(ProgressEvent<EventTarget*>*)>& onloadend);
		_Function<_Any*(ProgressEvent<EventTarget*>*)>* get_onloadstart();
		void set_onloadstart(EventListener* onloadstart);
		void set_onloadstart(const _Function<_Any*(ProgressEvent<EventTarget*>*)>& onloadstart);
		_Function<_Any*(ProgressEvent<EventTarget*>*)>* get_onprogress();
		void set_onprogress(EventListener* onprogress);
		void set_onprogress(const _Function<_Any*(ProgressEvent<EventTarget*>*)>& onprogress);
		_Function<_Any*(ProgressEvent<EventTarget*>*)>* get_ontimeout();
		void set_ontimeout(EventListener* ontimeout);
		void set_ontimeout(const _Function<_Any*(ProgressEvent<EventTarget*>*)>& ontimeout);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static XMLHttpRequestEventTarget* prototype;
		XMLHttpRequestEventTarget();
	};
	class XMLHttpRequest: public XMLHttpRequestEventTarget {
	public:
		_Function<_Any*(Event*)>* get_onreadystatechange();
		void set_onreadystatechange(EventListener* onreadystatechange);
		void set_onreadystatechange(const _Function<_Any*(Event*)>& onreadystatechange);
		double get_readyState();
		Object* get_response();
		String* get_responseText();
		String* get_responseType();
		void set_responseType(const String& responseType);
		String* get_responseURL();
		Document* get_responseXML();
		double get_status();
		String* get_statusText();
		double get_timeout();
		void set_timeout(double timeout);
		XMLHttpRequestUpload* get_upload();
		bool get_withCredentials();
		void set_withCredentials(bool withCredentials);
		void abort();
		String* getAllResponseHeaders();
		String* getResponseHeader(const String& name);
		void open(const String& method, const String& url);
		void open(const String& method, URL* url);
		void open(const String& method, const String& url, bool async);
		void open(const String& method, URL* url, bool async);
		void open(const String& method, const String& url, bool async, const String& username);
		void open(const String& method, URL* url, bool async, const String& username);
		void open(const String& method, const String& url, bool async, const String& username, const String& password);
		void open(const String& method, URL* url, bool async, const String& username, const String& password);
		void overrideMimeType(const String& mime);
		void send();
		void send(const String& body);
		void send(const _Union<ArrayBuffer*, ArrayBufferView*, Blob*, Document*, FormData*, URLSearchParams*>& body);
		void setRequestHeader(const String& name, const String& value);
		double get_UNSENT();
		double get_OPENED();
		double get_HEADERS_RECEIVED();
		double get_LOADING();
		double get_DONE();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static XMLHttpRequest* prototype;
		XMLHttpRequest();
		static double UNSENT;
		static double OPENED;
		static double HEADERS_RECEIVED;
		static double LOADING;
		static double DONE;
	};
	class XMLHttpRequestUpload: public XMLHttpRequestEventTarget {
	public:
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static XMLHttpRequestUpload* prototype;
		XMLHttpRequestUpload();
	};
	class XMLSerializer: public Object {
	public:
		String* serializeToString(Node* root);
		static XMLSerializer* prototype;
		XMLSerializer();
	};
	class XPathEvaluator: public XPathEvaluatorBase {
	public:
		static XPathEvaluator* prototype;
		XPathEvaluator();
	};
	class XPathExpression: public Object {
	public:
		XPathResult* evaluate(Node* contextNode);
		XPathResult* evaluate(Node* contextNode, double type);
		XPathResult* evaluate(Node* contextNode, double type, XPathResult* result);
		static XPathExpression* prototype;
		XPathExpression();
	};
	class XPathResult: public Object {
	public:
		bool get_booleanValue();
		bool get_invalidIteratorState();
		double get_numberValue();
		double get_resultType();
		Node* get_singleNodeValue();
		double get_snapshotLength();
		String* get_stringValue();
		Node* iterateNext();
		Node* snapshotItem(double index);
		double get_ANY_TYPE();
		double get_NUMBER_TYPE();
		double get_STRING_TYPE();
		double get_BOOLEAN_TYPE();
		double get_UNORDERED_NODE_ITERATOR_TYPE();
		double get_ORDERED_NODE_ITERATOR_TYPE();
		double get_UNORDERED_NODE_SNAPSHOT_TYPE();
		double get_ORDERED_NODE_SNAPSHOT_TYPE();
		double get_ANY_UNORDERED_NODE_TYPE();
		double get_FIRST_ORDERED_NODE_TYPE();
		static XPathResult* prototype;
		XPathResult();
		static double ANY_TYPE;
		static double NUMBER_TYPE;
		static double STRING_TYPE;
		static double BOOLEAN_TYPE;
		static double UNORDERED_NODE_ITERATOR_TYPE;
		static double ORDERED_NODE_ITERATOR_TYPE;
		static double UNORDERED_NODE_SNAPSHOT_TYPE;
		static double ORDERED_NODE_SNAPSHOT_TYPE;
		static double ANY_UNORDERED_NODE_TYPE;
		static double FIRST_ORDERED_NODE_TYPE;
	};
	class XSLTProcessor: public Object {
	public:
		void clearParameters();
		Object* getParameter(const String& namespaceURI, const String& localName);
		void importStylesheet(Node* style);
		void removeParameter(const String& namespaceURI, const String& localName);
		void reset();
		void setParameter(const String& namespaceURI, const String& localName, const _Any& value);
		Document* transformToDocument(Node* source);
		DocumentFragment* transformToFragment(Node* source, Document* output);
		static XSLTProcessor* prototype;
		XSLTProcessor();
	};
	class Console: public Object {
	public:
		[[cheerp::interface_name(("assert"))]]
		void assert_();
		template<class... _Args>
		[[gnu::always_inline]]
		void assert_(bool condition, _Args... data) {
			_assert_(cheerp::clientCast(condition), cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("assert"))]]
		_Any* _assert_(_Args... data);
	public:
		void clear();
		void count();
		void count(const String& label);
		void countReset();
		void countReset(const String& label);
		template<class... _Args>
		[[gnu::always_inline]]
		void debug(_Args... data) {
			_debug(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("debug"))]]
		_Any* _debug(_Args... data);
	public:
		void dir();
		void dir(const _Any& item);
		void dir(const _Any& item, const _Any& options);
		template<class... _Args>
		[[gnu::always_inline]]
		void dirxml(_Args... data) {
			_dirxml(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("dirxml"))]]
		_Any* _dirxml(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void error(_Args... data) {
			_error(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("error"))]]
		_Any* _error(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void group(_Args... data) {
			_group(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("group"))]]
		_Any* _group(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void groupCollapsed(_Args... data) {
			_groupCollapsed(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("groupCollapsed"))]]
		_Any* _groupCollapsed(_Args... data);
	public:
		void groupEnd();
		template<class... _Args>
		[[gnu::always_inline]]
		void info(_Args... data) {
			_info(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("info"))]]
		_Any* _info(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void log(_Args... data) {
			_log(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("log"))]]
		_Any* _log(_Args... data);
	public:
		void table();
		void table(const _Any& tabularData);
		void table(const _Any& tabularData, TArray<String*>* properties);
		void time();
		void time(const String& label);
		void timeEnd();
		void timeEnd(const String& label);
		void timeLog();
		template<class... _Args>
		[[gnu::always_inline]]
		void timeLog(const String& label, _Args... data) {
			_timeLog(cheerp::clientCast(label), cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("timeLog"))]]
		_Any* _timeLog(_Args... data);
	public:
		void timeStamp();
		void timeStamp(const String& label);
		template<class... _Args>
		[[gnu::always_inline]]
		void trace(_Args... data) {
			_trace(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("trace"))]]
		_Any* _trace(_Args... data);
	public:
		template<class... _Args>
		[[gnu::always_inline]]
		void warn(_Args... data) {
			_warn(cheerp::clientCast(data)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("warn"))]]
		_Any* _warn(_Args... data);
	};
	extern Console console;
	namespace CSS {
		CSSUnitValue* Hz(double value);
		CSSUnitValue* Q(double value);
		CSSUnitValue* ch(double value);
		CSSUnitValue* cm(double value);
		CSSUnitValue* cqb(double value);
		CSSUnitValue* cqh(double value);
		CSSUnitValue* cqi(double value);
		CSSUnitValue* cqmax(double value);
		CSSUnitValue* cqmin(double value);
		CSSUnitValue* cqw(double value);
		CSSUnitValue* deg(double value);
		CSSUnitValue* dpcm(double value);
		CSSUnitValue* dpi(double value);
		CSSUnitValue* dppx(double value);
		CSSUnitValue* dvb(double value);
		CSSUnitValue* dvh(double value);
		CSSUnitValue* dvi(double value);
		CSSUnitValue* dvmax(double value);
		CSSUnitValue* dvmin(double value);
		CSSUnitValue* dvw(double value);
		CSSUnitValue* em(double value);
		String* escape(const String& ident);
		CSSUnitValue* ex(double value);
		CSSUnitValue* fr(double value);
		CSSUnitValue* grad(double value);
		CSSUnitValue* kHz(double value);
		CSSUnitValue* lvb(double value);
		CSSUnitValue* lvh(double value);
		CSSUnitValue* lvi(double value);
		CSSUnitValue* lvmax(double value);
		CSSUnitValue* lvmin(double value);
		CSSUnitValue* lvw(double value);
		CSSUnitValue* mm(double value);
		CSSUnitValue* ms(double value);
		CSSUnitValue* number(double value);
		CSSUnitValue* pc(double value);
		CSSUnitValue* percent(double value);
		CSSUnitValue* pt(double value);
		CSSUnitValue* px(double value);
		CSSUnitValue* rad(double value);
		void registerProperty(PropertyDefinition* definition);
		CSSUnitValue* rem(double value);
		CSSUnitValue* s(double value);
		bool supports(const String& property, const String& value);
		bool supports(const String& conditionText);
		CSSUnitValue* svb(double value);
		CSSUnitValue* svh(double value);
		CSSUnitValue* svi(double value);
		CSSUnitValue* svmax(double value);
		CSSUnitValue* svmin(double value);
		CSSUnitValue* svw(double value);
		CSSUnitValue* turn(double value);
		CSSUnitValue* vb(double value);
		CSSUnitValue* vh(double value);
		CSSUnitValue* vi(double value);
		CSSUnitValue* vmax(double value);
		CSSUnitValue* vmin(double value);
		CSSUnitValue* vw(double value);
	}
	namespace WebAssembly {
		class CompileError: public Error {
		public:
			static CompileError* prototype;
			CompileError();
			CompileError(const String& message);
		};
		template<class _T0>
		class GlobalDescriptor;
		template<class _T0>
		class Global: public Object {
			static_assert(cheerp::CanCast<_T0, String*>);
			static_assert(cheerp::CheckTemplate<_T0>);
		public:
			Object* get_value();
			void set_value(Object* value);
			Object* valueOf();
			static Global<String*>* prototype;
			template<class _T1 = String*>
			Global(GlobalDescriptor<_T1>* descriptor);
			template<class _T1 = String*>
			Global(GlobalDescriptor<_T1>* descriptor, Object* v);
		};
		class Module;
		class Instance: public Object {
		public:
			Object* get_exports();
			static Instance* prototype;
			Instance(Module* module);
			Instance(Module* module, Object* importObject);
		};
		class LinkError: public Error {
		public:
			static LinkError* prototype;
			LinkError();
			LinkError(const String& message);
		};
		class MemoryDescriptor;
		class Memory: public Object {
		public:
			ArrayBuffer* get_buffer();
			double grow(double delta);
			static Memory* prototype;
			Memory(MemoryDescriptor* descriptor);
		};
		class ModuleExportDescriptor;
		class ModuleImportDescriptor;
		class Module: public Object {
		public:
			static Module* prototype;
			Module(const _Union<ArrayBuffer*, ArrayBufferView*>& bytes);
			static TArray<ArrayBuffer*>* customSections(Module* moduleObject, const String& sectionName);
			static TArray<ModuleExportDescriptor*>* exports(Module* moduleObject);
			static TArray<ModuleImportDescriptor*>* imports(Module* moduleObject);
		};
		class RuntimeError: public Error {
		public:
			static RuntimeError* prototype;
			RuntimeError();
			RuntimeError(const String& message);
		};
		class TableDescriptor;
		class Table: public Object {
		public:
			int get_length() const;
			Object* get(double index);
			double grow(double delta);
			double grow(double delta, const _Any& value);
			void set(double index);
			void set(double index, const _Any& value);
			static Table* prototype;
			Table(TableDescriptor* descriptor);
			Table(TableDescriptor* descriptor, const _Any& value);
		};
		template<class _T0>
		class GlobalDescriptor: public Object {
			static_assert(cheerp::CanCast<_T0, String*>);
			static_assert(cheerp::CheckTemplate<_T0>);
		public:
			[[cheerp::interface_name(("get_mutable"))]]
			bool get_mutable_();
			[[cheerp::interface_name(("set_mutable"))]]
			void set_mutable_(bool mutable_);
			_T0 get_value();
			void set_value(_T0 value);
		};
		class MemoryDescriptor: public Object {
		public:
			double get_initial();
			void set_initial(double initial);
			double get_maximum();
			void set_maximum(double maximum);
			bool get_shared();
			void set_shared(bool shared);
		};
		class ModuleExportDescriptor: public Object {
		public:
			String* get_kind();
			void set_kind(const String& kind);
			String* get_name();
			void set_name(const String& name);
		};
		class ModuleImportDescriptor: public Object {
		public:
			String* get_kind();
			void set_kind(const String& kind);
			String* get_module();
			void set_module(const String& module);
			String* get_name();
			void set_name(const String& name);
		};
		class TableDescriptor: public Object {
		public:
			String* get_element();
			void set_element(const String& element);
			double get_initial();
			void set_initial(double initial);
			double get_maximum();
			void set_maximum(double maximum);
		};
		class ValueTypeMap: public Object {
		public:
			Function* get_anyfunc();
			void set_anyfunc(const _Function<void()>& anyfunc);
			void set_anyfunc(Function* anyfunc);
			Object* get_externref();
			void set_externref(const _Any& externref);
			double get_f32();
			void set_f32(double f32);
			double get_f64();
			void set_f64(double f64);
			double get_i32();
			void set_i32(double i32);
			BigInt* get_i64();
			void set_i64(BigInt* i64);
			Object* get_v128();
			void set_v128(Object* v128);
		};
		class WebAssemblyInstantiatedSource: public Object {
		public:
			Instance* get_instance();
			void set_instance(Instance* instance);
			Module* get_module();
			void set_module(Module* module);
		};
		using ImportExportKind = String;
		using TableKind = String;
		using ExportValue = _Any;
		using Exports = Object;
		using ImportValue = _Any;
		using Imports = Object;
		using ModuleImports = Object;
		using ValueType = String;
		Promise<Module*>* compile(const _Union<ArrayBuffer*, ArrayBufferView*>& bytes);
		Promise<Module*>* compileStreaming(const _Union<Response*, PromiseLike<Response*>*>& source);
		Promise<WebAssemblyInstantiatedSource*>* instantiate(const _Union<ArrayBuffer*, ArrayBufferView*>& bytes);
		Promise<WebAssemblyInstantiatedSource*>* instantiate(const _Union<ArrayBuffer*, ArrayBufferView*>& bytes, Object* importObject);
		Promise<Instance*>* instantiate(Module* moduleObject);
		Promise<Instance*>* instantiate(Module* moduleObject, Object* importObject);
		Promise<WebAssemblyInstantiatedSource*>* instantiateStreaming(const _Union<Response*, PromiseLike<Response*>*>& source);
		Promise<WebAssemblyInstantiatedSource*>* instantiateStreaming(const _Union<Response*, PromiseLike<Response*>*>& source, Object* importObject);
		bool validate(const _Union<ArrayBuffer*, ArrayBufferView*>& bytes);
	}
	class BlobCallback: public Object {
	};
	class CustomElementConstructor: public Object {
	};
	class DecodeErrorCallback: public Object {
	};
	class DecodeSuccessCallback: public Object {
	};
	class EncodedVideoChunkOutputCallback: public Object {
	};
	class ErrorCallback: public Object {
	};
	class FileCallback: public Object {
	};
	class FileSystemEntriesCallback: public Object {
	};
	class FileSystemEntryCallback: public Object {
	};
	class FrameRequestCallback: public Object {
	};
	class FunctionStringCallback: public Object {
	};
	class IdleRequestCallback: public Object {
	};
	class IntersectionObserverCallback: public Object {
	};
	class LockGrantedCallback: public Object {
	};
	class MediaSessionActionHandler: public Object {
	};
	class MutationCallback: public Object {
	};
	class NotificationPermissionCallback: public Object {
	};
	class OnBeforeUnloadEventHandlerNonNull: public Object {
	};
	class OnErrorEventHandlerNonNull: public Object {
	};
	class PerformanceObserverCallback: public Object {
	};
	class PositionCallback: public Object {
	};
	class PositionErrorCallback: public Object {
	};
	template<class _T0>
	class QueuingStrategySize: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	};
	class RTCPeerConnectionErrorCallback: public Object {
	};
	class RTCSessionDescriptionCallback: public Object {
	};
	class RemotePlaybackAvailabilityCallback: public Object {
	};
	class ReportingObserverCallback: public Object {
	};
	class ResizeObserverCallback: public Object {
	};
	template<class _T0>
	class TransformerFlushCallback: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	};
	template<class _T0>
	class TransformerStartCallback: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	};
	template<class _T0, class _T1>
	class TransformerTransformCallback: public Object {
		static_assert(cheerp::CheckTemplate<_T0, _T1>);
	};
	class UnderlyingSinkAbortCallback: public Object {
	};
	class UnderlyingSinkCloseCallback: public Object {
	};
	class UnderlyingSinkStartCallback: public Object {
	};
	template<class _T0>
	class UnderlyingSinkWriteCallback: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	};
	class UnderlyingSourceCancelCallback: public Object {
	};
	template<class _T0>
	class UnderlyingSourcePullCallback: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	};
	template<class _T0>
	class UnderlyingSourceStartCallback: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	};
	class VideoFrameOutputCallback: public Object {
	};
	class VideoFrameRequestCallback: public Object {
	};
	class VoidFunction: public Object {
	};
	class WebCodecsErrorCallback: public Object {
	};
	class HTMLElementTagNameMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"a\""))]]
		HTMLAnchorElement* get__34_a_34_();
		[[cheerp::interface_name(("set_\"a\""))]]
		void set__34_a_34_(HTMLAnchorElement* _34_a_34_);
		[[cheerp::interface_name(("get_\"abbr\""))]]
		HTMLElement* get__34_abbr_34_();
		[[cheerp::interface_name(("set_\"abbr\""))]]
		void set__34_abbr_34_(HTMLElement* _34_abbr_34_);
		[[cheerp::interface_name(("get_\"address\""))]]
		HTMLElement* get__34_address_34_();
		[[cheerp::interface_name(("set_\"address\""))]]
		void set__34_address_34_(HTMLElement* _34_address_34_);
		[[cheerp::interface_name(("get_\"area\""))]]
		HTMLAreaElement* get__34_area_34_();
		[[cheerp::interface_name(("set_\"area\""))]]
		void set__34_area_34_(HTMLAreaElement* _34_area_34_);
		[[cheerp::interface_name(("get_\"article\""))]]
		HTMLElement* get__34_article_34_();
		[[cheerp::interface_name(("set_\"article\""))]]
		void set__34_article_34_(HTMLElement* _34_article_34_);
		[[cheerp::interface_name(("get_\"aside\""))]]
		HTMLElement* get__34_aside_34_();
		[[cheerp::interface_name(("set_\"aside\""))]]
		void set__34_aside_34_(HTMLElement* _34_aside_34_);
		[[cheerp::interface_name(("get_\"audio\""))]]
		HTMLAudioElement* get__34_audio_34_();
		[[cheerp::interface_name(("set_\"audio\""))]]
		void set__34_audio_34_(HTMLAudioElement* _34_audio_34_);
		[[cheerp::interface_name(("get_\"b\""))]]
		HTMLElement* get__34_b_34_();
		[[cheerp::interface_name(("set_\"b\""))]]
		void set__34_b_34_(HTMLElement* _34_b_34_);
		[[cheerp::interface_name(("get_\"base\""))]]
		HTMLBaseElement* get__34_base_34_();
		[[cheerp::interface_name(("set_\"base\""))]]
		void set__34_base_34_(HTMLBaseElement* _34_base_34_);
		[[cheerp::interface_name(("get_\"bdi\""))]]
		HTMLElement* get__34_bdi_34_();
		[[cheerp::interface_name(("set_\"bdi\""))]]
		void set__34_bdi_34_(HTMLElement* _34_bdi_34_);
		[[cheerp::interface_name(("get_\"bdo\""))]]
		HTMLElement* get__34_bdo_34_();
		[[cheerp::interface_name(("set_\"bdo\""))]]
		void set__34_bdo_34_(HTMLElement* _34_bdo_34_);
		[[cheerp::interface_name(("get_\"blockquote\""))]]
		HTMLQuoteElement* get__34_blockquote_34_();
		[[cheerp::interface_name(("set_\"blockquote\""))]]
		void set__34_blockquote_34_(HTMLQuoteElement* _34_blockquote_34_);
		[[cheerp::interface_name(("get_\"body\""))]]
		HTMLBodyElement* get__34_body_34_();
		[[cheerp::interface_name(("set_\"body\""))]]
		void set__34_body_34_(HTMLBodyElement* _34_body_34_);
		[[cheerp::interface_name(("get_\"br\""))]]
		HTMLBRElement* get__34_br_34_();
		[[cheerp::interface_name(("set_\"br\""))]]
		void set__34_br_34_(HTMLBRElement* _34_br_34_);
		[[cheerp::interface_name(("get_\"button\""))]]
		HTMLButtonElement* get__34_button_34_();
		[[cheerp::interface_name(("set_\"button\""))]]
		void set__34_button_34_(HTMLButtonElement* _34_button_34_);
		[[cheerp::interface_name(("get_\"canvas\""))]]
		HTMLCanvasElement* get__34_canvas_34_();
		[[cheerp::interface_name(("set_\"canvas\""))]]
		void set__34_canvas_34_(HTMLCanvasElement* _34_canvas_34_);
		[[cheerp::interface_name(("get_\"caption\""))]]
		HTMLTableCaptionElement* get__34_caption_34_();
		[[cheerp::interface_name(("set_\"caption\""))]]
		void set__34_caption_34_(HTMLTableCaptionElement* _34_caption_34_);
		[[cheerp::interface_name(("get_\"cite\""))]]
		HTMLElement* get__34_cite_34_();
		[[cheerp::interface_name(("set_\"cite\""))]]
		void set__34_cite_34_(HTMLElement* _34_cite_34_);
		[[cheerp::interface_name(("get_\"code\""))]]
		HTMLElement* get__34_code_34_();
		[[cheerp::interface_name(("set_\"code\""))]]
		void set__34_code_34_(HTMLElement* _34_code_34_);
		[[cheerp::interface_name(("get_\"col\""))]]
		HTMLTableColElement* get__34_col_34_();
		[[cheerp::interface_name(("set_\"col\""))]]
		void set__34_col_34_(HTMLTableColElement* _34_col_34_);
		[[cheerp::interface_name(("get_\"colgroup\""))]]
		HTMLTableColElement* get__34_colgroup_34_();
		[[cheerp::interface_name(("set_\"colgroup\""))]]
		void set__34_colgroup_34_(HTMLTableColElement* _34_colgroup_34_);
		[[cheerp::interface_name(("get_\"data\""))]]
		HTMLDataElement* get__34_data_34_();
		[[cheerp::interface_name(("set_\"data\""))]]
		void set__34_data_34_(HTMLDataElement* _34_data_34_);
		[[cheerp::interface_name(("get_\"datalist\""))]]
		HTMLDataListElement* get__34_datalist_34_();
		[[cheerp::interface_name(("set_\"datalist\""))]]
		void set__34_datalist_34_(HTMLDataListElement* _34_datalist_34_);
		[[cheerp::interface_name(("get_\"dd\""))]]
		HTMLElement* get__34_dd_34_();
		[[cheerp::interface_name(("set_\"dd\""))]]
		void set__34_dd_34_(HTMLElement* _34_dd_34_);
		[[cheerp::interface_name(("get_\"del\""))]]
		HTMLModElement* get__34_del_34_();
		[[cheerp::interface_name(("set_\"del\""))]]
		void set__34_del_34_(HTMLModElement* _34_del_34_);
		[[cheerp::interface_name(("get_\"details\""))]]
		HTMLDetailsElement* get__34_details_34_();
		[[cheerp::interface_name(("set_\"details\""))]]
		void set__34_details_34_(HTMLDetailsElement* _34_details_34_);
		[[cheerp::interface_name(("get_\"dfn\""))]]
		HTMLElement* get__34_dfn_34_();
		[[cheerp::interface_name(("set_\"dfn\""))]]
		void set__34_dfn_34_(HTMLElement* _34_dfn_34_);
		[[cheerp::interface_name(("get_\"dialog\""))]]
		HTMLDialogElement* get__34_dialog_34_();
		[[cheerp::interface_name(("set_\"dialog\""))]]
		void set__34_dialog_34_(HTMLDialogElement* _34_dialog_34_);
		[[cheerp::interface_name(("get_\"div\""))]]
		HTMLDivElement* get__34_div_34_();
		[[cheerp::interface_name(("set_\"div\""))]]
		void set__34_div_34_(HTMLDivElement* _34_div_34_);
		[[cheerp::interface_name(("get_\"dl\""))]]
		HTMLDListElement* get__34_dl_34_();
		[[cheerp::interface_name(("set_\"dl\""))]]
		void set__34_dl_34_(HTMLDListElement* _34_dl_34_);
		[[cheerp::interface_name(("get_\"dt\""))]]
		HTMLElement* get__34_dt_34_();
		[[cheerp::interface_name(("set_\"dt\""))]]
		void set__34_dt_34_(HTMLElement* _34_dt_34_);
		[[cheerp::interface_name(("get_\"em\""))]]
		HTMLElement* get__34_em_34_();
		[[cheerp::interface_name(("set_\"em\""))]]
		void set__34_em_34_(HTMLElement* _34_em_34_);
		[[cheerp::interface_name(("get_\"embed\""))]]
		HTMLEmbedElement* get__34_embed_34_();
		[[cheerp::interface_name(("set_\"embed\""))]]
		void set__34_embed_34_(HTMLEmbedElement* _34_embed_34_);
		[[cheerp::interface_name(("get_\"fieldset\""))]]
		HTMLFieldSetElement* get__34_fieldset_34_();
		[[cheerp::interface_name(("set_\"fieldset\""))]]
		void set__34_fieldset_34_(HTMLFieldSetElement* _34_fieldset_34_);
		[[cheerp::interface_name(("get_\"figcaption\""))]]
		HTMLElement* get__34_figcaption_34_();
		[[cheerp::interface_name(("set_\"figcaption\""))]]
		void set__34_figcaption_34_(HTMLElement* _34_figcaption_34_);
		[[cheerp::interface_name(("get_\"figure\""))]]
		HTMLElement* get__34_figure_34_();
		[[cheerp::interface_name(("set_\"figure\""))]]
		void set__34_figure_34_(HTMLElement* _34_figure_34_);
		[[cheerp::interface_name(("get_\"footer\""))]]
		HTMLElement* get__34_footer_34_();
		[[cheerp::interface_name(("set_\"footer\""))]]
		void set__34_footer_34_(HTMLElement* _34_footer_34_);
		[[cheerp::interface_name(("get_\"form\""))]]
		HTMLFormElement* get__34_form_34_();
		[[cheerp::interface_name(("set_\"form\""))]]
		void set__34_form_34_(HTMLFormElement* _34_form_34_);
		[[cheerp::interface_name(("get_\"h1\""))]]
		HTMLHeadingElement* get__34_h1_34_();
		[[cheerp::interface_name(("set_\"h1\""))]]
		void set__34_h1_34_(HTMLHeadingElement* _34_h1_34_);
		[[cheerp::interface_name(("get_\"h2\""))]]
		HTMLHeadingElement* get__34_h2_34_();
		[[cheerp::interface_name(("set_\"h2\""))]]
		void set__34_h2_34_(HTMLHeadingElement* _34_h2_34_);
		[[cheerp::interface_name(("get_\"h3\""))]]
		HTMLHeadingElement* get__34_h3_34_();
		[[cheerp::interface_name(("set_\"h3\""))]]
		void set__34_h3_34_(HTMLHeadingElement* _34_h3_34_);
		[[cheerp::interface_name(("get_\"h4\""))]]
		HTMLHeadingElement* get__34_h4_34_();
		[[cheerp::interface_name(("set_\"h4\""))]]
		void set__34_h4_34_(HTMLHeadingElement* _34_h4_34_);
		[[cheerp::interface_name(("get_\"h5\""))]]
		HTMLHeadingElement* get__34_h5_34_();
		[[cheerp::interface_name(("set_\"h5\""))]]
		void set__34_h5_34_(HTMLHeadingElement* _34_h5_34_);
		[[cheerp::interface_name(("get_\"h6\""))]]
		HTMLHeadingElement* get__34_h6_34_();
		[[cheerp::interface_name(("set_\"h6\""))]]
		void set__34_h6_34_(HTMLHeadingElement* _34_h6_34_);
		[[cheerp::interface_name(("get_\"head\""))]]
		HTMLHeadElement* get__34_head_34_();
		[[cheerp::interface_name(("set_\"head\""))]]
		void set__34_head_34_(HTMLHeadElement* _34_head_34_);
		[[cheerp::interface_name(("get_\"header\""))]]
		HTMLElement* get__34_header_34_();
		[[cheerp::interface_name(("set_\"header\""))]]
		void set__34_header_34_(HTMLElement* _34_header_34_);
		[[cheerp::interface_name(("get_\"hgroup\""))]]
		HTMLElement* get__34_hgroup_34_();
		[[cheerp::interface_name(("set_\"hgroup\""))]]
		void set__34_hgroup_34_(HTMLElement* _34_hgroup_34_);
		[[cheerp::interface_name(("get_\"hr\""))]]
		HTMLHRElement* get__34_hr_34_();
		[[cheerp::interface_name(("set_\"hr\""))]]
		void set__34_hr_34_(HTMLHRElement* _34_hr_34_);
		[[cheerp::interface_name(("get_\"html\""))]]
		HTMLHtmlElement* get__34_html_34_();
		[[cheerp::interface_name(("set_\"html\""))]]
		void set__34_html_34_(HTMLHtmlElement* _34_html_34_);
		[[cheerp::interface_name(("get_\"i\""))]]
		HTMLElement* get__34_i_34_();
		[[cheerp::interface_name(("set_\"i\""))]]
		void set__34_i_34_(HTMLElement* _34_i_34_);
		[[cheerp::interface_name(("get_\"iframe\""))]]
		HTMLIFrameElement* get__34_iframe_34_();
		[[cheerp::interface_name(("set_\"iframe\""))]]
		void set__34_iframe_34_(HTMLIFrameElement* _34_iframe_34_);
		[[cheerp::interface_name(("get_\"img\""))]]
		HTMLImageElement* get__34_img_34_();
		[[cheerp::interface_name(("set_\"img\""))]]
		void set__34_img_34_(HTMLImageElement* _34_img_34_);
		[[cheerp::interface_name(("get_\"input\""))]]
		HTMLInputElement* get__34_input_34_();
		[[cheerp::interface_name(("set_\"input\""))]]
		void set__34_input_34_(HTMLInputElement* _34_input_34_);
		[[cheerp::interface_name(("get_\"ins\""))]]
		HTMLModElement* get__34_ins_34_();
		[[cheerp::interface_name(("set_\"ins\""))]]
		void set__34_ins_34_(HTMLModElement* _34_ins_34_);
		[[cheerp::interface_name(("get_\"kbd\""))]]
		HTMLElement* get__34_kbd_34_();
		[[cheerp::interface_name(("set_\"kbd\""))]]
		void set__34_kbd_34_(HTMLElement* _34_kbd_34_);
		[[cheerp::interface_name(("get_\"label\""))]]
		HTMLLabelElement* get__34_label_34_();
		[[cheerp::interface_name(("set_\"label\""))]]
		void set__34_label_34_(HTMLLabelElement* _34_label_34_);
		[[cheerp::interface_name(("get_\"legend\""))]]
		HTMLLegendElement* get__34_legend_34_();
		[[cheerp::interface_name(("set_\"legend\""))]]
		void set__34_legend_34_(HTMLLegendElement* _34_legend_34_);
		[[cheerp::interface_name(("get_\"li\""))]]
		HTMLLIElement* get__34_li_34_();
		[[cheerp::interface_name(("set_\"li\""))]]
		void set__34_li_34_(HTMLLIElement* _34_li_34_);
		[[cheerp::interface_name(("get_\"link\""))]]
		HTMLLinkElement* get__34_link_34_();
		[[cheerp::interface_name(("set_\"link\""))]]
		void set__34_link_34_(HTMLLinkElement* _34_link_34_);
		[[cheerp::interface_name(("get_\"main\""))]]
		HTMLElement* get__34_main_34_();
		[[cheerp::interface_name(("set_\"main\""))]]
		void set__34_main_34_(HTMLElement* _34_main_34_);
		[[cheerp::interface_name(("get_\"map\""))]]
		HTMLMapElement* get__34_map_34_();
		[[cheerp::interface_name(("set_\"map\""))]]
		void set__34_map_34_(HTMLMapElement* _34_map_34_);
		[[cheerp::interface_name(("get_\"mark\""))]]
		HTMLElement* get__34_mark_34_();
		[[cheerp::interface_name(("set_\"mark\""))]]
		void set__34_mark_34_(HTMLElement* _34_mark_34_);
		[[cheerp::interface_name(("get_\"menu\""))]]
		HTMLMenuElement* get__34_menu_34_();
		[[cheerp::interface_name(("set_\"menu\""))]]
		void set__34_menu_34_(HTMLMenuElement* _34_menu_34_);
		[[cheerp::interface_name(("get_\"meta\""))]]
		HTMLMetaElement* get__34_meta_34_();
		[[cheerp::interface_name(("set_\"meta\""))]]
		void set__34_meta_34_(HTMLMetaElement* _34_meta_34_);
		[[cheerp::interface_name(("get_\"meter\""))]]
		HTMLMeterElement* get__34_meter_34_();
		[[cheerp::interface_name(("set_\"meter\""))]]
		void set__34_meter_34_(HTMLMeterElement* _34_meter_34_);
		[[cheerp::interface_name(("get_\"nav\""))]]
		HTMLElement* get__34_nav_34_();
		[[cheerp::interface_name(("set_\"nav\""))]]
		void set__34_nav_34_(HTMLElement* _34_nav_34_);
		[[cheerp::interface_name(("get_\"noscript\""))]]
		HTMLElement* get__34_noscript_34_();
		[[cheerp::interface_name(("set_\"noscript\""))]]
		void set__34_noscript_34_(HTMLElement* _34_noscript_34_);
		[[cheerp::interface_name(("get_\"object\""))]]
		HTMLObjectElement* get__34_object_34_();
		[[cheerp::interface_name(("set_\"object\""))]]
		void set__34_object_34_(HTMLObjectElement* _34_object_34_);
		[[cheerp::interface_name(("get_\"ol\""))]]
		HTMLOListElement* get__34_ol_34_();
		[[cheerp::interface_name(("set_\"ol\""))]]
		void set__34_ol_34_(HTMLOListElement* _34_ol_34_);
		[[cheerp::interface_name(("get_\"optgroup\""))]]
		HTMLOptGroupElement* get__34_optgroup_34_();
		[[cheerp::interface_name(("set_\"optgroup\""))]]
		void set__34_optgroup_34_(HTMLOptGroupElement* _34_optgroup_34_);
		[[cheerp::interface_name(("get_\"option\""))]]
		HTMLOptionElement* get__34_option_34_();
		[[cheerp::interface_name(("set_\"option\""))]]
		void set__34_option_34_(HTMLOptionElement* _34_option_34_);
		[[cheerp::interface_name(("get_\"output\""))]]
		HTMLOutputElement* get__34_output_34_();
		[[cheerp::interface_name(("set_\"output\""))]]
		void set__34_output_34_(HTMLOutputElement* _34_output_34_);
		[[cheerp::interface_name(("get_\"p\""))]]
		HTMLParagraphElement* get__34_p_34_();
		[[cheerp::interface_name(("set_\"p\""))]]
		void set__34_p_34_(HTMLParagraphElement* _34_p_34_);
		[[cheerp::interface_name(("get_\"picture\""))]]
		HTMLPictureElement* get__34_picture_34_();
		[[cheerp::interface_name(("set_\"picture\""))]]
		void set__34_picture_34_(HTMLPictureElement* _34_picture_34_);
		[[cheerp::interface_name(("get_\"pre\""))]]
		HTMLPreElement* get__34_pre_34_();
		[[cheerp::interface_name(("set_\"pre\""))]]
		void set__34_pre_34_(HTMLPreElement* _34_pre_34_);
		[[cheerp::interface_name(("get_\"progress\""))]]
		HTMLProgressElement* get__34_progress_34_();
		[[cheerp::interface_name(("set_\"progress\""))]]
		void set__34_progress_34_(HTMLProgressElement* _34_progress_34_);
		[[cheerp::interface_name(("get_\"q\""))]]
		HTMLQuoteElement* get__34_q_34_();
		[[cheerp::interface_name(("set_\"q\""))]]
		void set__34_q_34_(HTMLQuoteElement* _34_q_34_);
		[[cheerp::interface_name(("get_\"rp\""))]]
		HTMLElement* get__34_rp_34_();
		[[cheerp::interface_name(("set_\"rp\""))]]
		void set__34_rp_34_(HTMLElement* _34_rp_34_);
		[[cheerp::interface_name(("get_\"rt\""))]]
		HTMLElement* get__34_rt_34_();
		[[cheerp::interface_name(("set_\"rt\""))]]
		void set__34_rt_34_(HTMLElement* _34_rt_34_);
		[[cheerp::interface_name(("get_\"ruby\""))]]
		HTMLElement* get__34_ruby_34_();
		[[cheerp::interface_name(("set_\"ruby\""))]]
		void set__34_ruby_34_(HTMLElement* _34_ruby_34_);
		[[cheerp::interface_name(("get_\"s\""))]]
		HTMLElement* get__34_s_34_();
		[[cheerp::interface_name(("set_\"s\""))]]
		void set__34_s_34_(HTMLElement* _34_s_34_);
		[[cheerp::interface_name(("get_\"samp\""))]]
		HTMLElement* get__34_samp_34_();
		[[cheerp::interface_name(("set_\"samp\""))]]
		void set__34_samp_34_(HTMLElement* _34_samp_34_);
		[[cheerp::interface_name(("get_\"script\""))]]
		HTMLScriptElement* get__34_script_34_();
		[[cheerp::interface_name(("set_\"script\""))]]
		void set__34_script_34_(HTMLScriptElement* _34_script_34_);
		[[cheerp::interface_name(("get_\"search\""))]]
		HTMLElement* get__34_search_34_();
		[[cheerp::interface_name(("set_\"search\""))]]
		void set__34_search_34_(HTMLElement* _34_search_34_);
		[[cheerp::interface_name(("get_\"section\""))]]
		HTMLElement* get__34_section_34_();
		[[cheerp::interface_name(("set_\"section\""))]]
		void set__34_section_34_(HTMLElement* _34_section_34_);
		[[cheerp::interface_name(("get_\"select\""))]]
		HTMLSelectElement* get__34_select_34_();
		[[cheerp::interface_name(("set_\"select\""))]]
		void set__34_select_34_(HTMLSelectElement* _34_select_34_);
		[[cheerp::interface_name(("get_\"slot\""))]]
		HTMLSlotElement* get__34_slot_34_();
		[[cheerp::interface_name(("set_\"slot\""))]]
		void set__34_slot_34_(HTMLSlotElement* _34_slot_34_);
		[[cheerp::interface_name(("get_\"small\""))]]
		HTMLElement* get__34_small_34_();
		[[cheerp::interface_name(("set_\"small\""))]]
		void set__34_small_34_(HTMLElement* _34_small_34_);
		[[cheerp::interface_name(("get_\"source\""))]]
		HTMLSourceElement* get__34_source_34_();
		[[cheerp::interface_name(("set_\"source\""))]]
		void set__34_source_34_(HTMLSourceElement* _34_source_34_);
		[[cheerp::interface_name(("get_\"span\""))]]
		HTMLSpanElement* get__34_span_34_();
		[[cheerp::interface_name(("set_\"span\""))]]
		void set__34_span_34_(HTMLSpanElement* _34_span_34_);
		[[cheerp::interface_name(("get_\"strong\""))]]
		HTMLElement* get__34_strong_34_();
		[[cheerp::interface_name(("set_\"strong\""))]]
		void set__34_strong_34_(HTMLElement* _34_strong_34_);
		[[cheerp::interface_name(("get_\"style\""))]]
		HTMLStyleElement* get__34_style_34_();
		[[cheerp::interface_name(("set_\"style\""))]]
		void set__34_style_34_(HTMLStyleElement* _34_style_34_);
		[[cheerp::interface_name(("get_\"sub\""))]]
		HTMLElement* get__34_sub_34_();
		[[cheerp::interface_name(("set_\"sub\""))]]
		void set__34_sub_34_(HTMLElement* _34_sub_34_);
		[[cheerp::interface_name(("get_\"summary\""))]]
		HTMLElement* get__34_summary_34_();
		[[cheerp::interface_name(("set_\"summary\""))]]
		void set__34_summary_34_(HTMLElement* _34_summary_34_);
		[[cheerp::interface_name(("get_\"sup\""))]]
		HTMLElement* get__34_sup_34_();
		[[cheerp::interface_name(("set_\"sup\""))]]
		void set__34_sup_34_(HTMLElement* _34_sup_34_);
		[[cheerp::interface_name(("get_\"table\""))]]
		HTMLTableElement* get__34_table_34_();
		[[cheerp::interface_name(("set_\"table\""))]]
		void set__34_table_34_(HTMLTableElement* _34_table_34_);
		[[cheerp::interface_name(("get_\"tbody\""))]]
		HTMLTableSectionElement* get__34_tbody_34_();
		[[cheerp::interface_name(("set_\"tbody\""))]]
		void set__34_tbody_34_(HTMLTableSectionElement* _34_tbody_34_);
		[[cheerp::interface_name(("get_\"td\""))]]
		HTMLTableCellElement* get__34_td_34_();
		[[cheerp::interface_name(("set_\"td\""))]]
		void set__34_td_34_(HTMLTableCellElement* _34_td_34_);
		[[cheerp::interface_name(("get_\"template\""))]]
		HTMLTemplateElement* get__34_template_34_();
		[[cheerp::interface_name(("set_\"template\""))]]
		void set__34_template_34_(HTMLTemplateElement* _34_template_34_);
		[[cheerp::interface_name(("get_\"textarea\""))]]
		HTMLTextAreaElement* get__34_textarea_34_();
		[[cheerp::interface_name(("set_\"textarea\""))]]
		void set__34_textarea_34_(HTMLTextAreaElement* _34_textarea_34_);
		[[cheerp::interface_name(("get_\"tfoot\""))]]
		HTMLTableSectionElement* get__34_tfoot_34_();
		[[cheerp::interface_name(("set_\"tfoot\""))]]
		void set__34_tfoot_34_(HTMLTableSectionElement* _34_tfoot_34_);
		[[cheerp::interface_name(("get_\"th\""))]]
		HTMLTableCellElement* get__34_th_34_();
		[[cheerp::interface_name(("set_\"th\""))]]
		void set__34_th_34_(HTMLTableCellElement* _34_th_34_);
		[[cheerp::interface_name(("get_\"thead\""))]]
		HTMLTableSectionElement* get__34_thead_34_();
		[[cheerp::interface_name(("set_\"thead\""))]]
		void set__34_thead_34_(HTMLTableSectionElement* _34_thead_34_);
		[[cheerp::interface_name(("get_\"time\""))]]
		HTMLTimeElement* get__34_time_34_();
		[[cheerp::interface_name(("set_\"time\""))]]
		void set__34_time_34_(HTMLTimeElement* _34_time_34_);
		[[cheerp::interface_name(("get_\"title\""))]]
		HTMLTitleElement* get__34_title_34_();
		[[cheerp::interface_name(("set_\"title\""))]]
		void set__34_title_34_(HTMLTitleElement* _34_title_34_);
		[[cheerp::interface_name(("get_\"tr\""))]]
		HTMLTableRowElement* get__34_tr_34_();
		[[cheerp::interface_name(("set_\"tr\""))]]
		void set__34_tr_34_(HTMLTableRowElement* _34_tr_34_);
		[[cheerp::interface_name(("get_\"track\""))]]
		HTMLTrackElement* get__34_track_34_();
		[[cheerp::interface_name(("set_\"track\""))]]
		void set__34_track_34_(HTMLTrackElement* _34_track_34_);
		[[cheerp::interface_name(("get_\"u\""))]]
		HTMLElement* get__34_u_34_();
		[[cheerp::interface_name(("set_\"u\""))]]
		void set__34_u_34_(HTMLElement* _34_u_34_);
		[[cheerp::interface_name(("get_\"ul\""))]]
		HTMLUListElement* get__34_ul_34_();
		[[cheerp::interface_name(("set_\"ul\""))]]
		void set__34_ul_34_(HTMLUListElement* _34_ul_34_);
		[[cheerp::interface_name(("get_\"var\""))]]
		HTMLElement* get__34_var_34_();
		[[cheerp::interface_name(("set_\"var\""))]]
		void set__34_var_34_(HTMLElement* _34_var_34_);
		[[cheerp::interface_name(("get_\"video\""))]]
		HTMLVideoElement* get__34_video_34_();
		[[cheerp::interface_name(("set_\"video\""))]]
		void set__34_video_34_(HTMLVideoElement* _34_video_34_);
		[[cheerp::interface_name(("get_\"wbr\""))]]
		HTMLElement* get__34_wbr_34_();
		[[cheerp::interface_name(("set_\"wbr\""))]]
		void set__34_wbr_34_(HTMLElement* _34_wbr_34_);
	};
	class HTMLElementDeprecatedTagNameMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"acronym\""))]]
		HTMLElement* get__34_acronym_34_();
		[[cheerp::interface_name(("set_\"acronym\""))]]
		void set__34_acronym_34_(HTMLElement* _34_acronym_34_);
		[[cheerp::interface_name(("get_\"applet\""))]]
		HTMLUnknownElement* get__34_applet_34_();
		[[cheerp::interface_name(("set_\"applet\""))]]
		void set__34_applet_34_(HTMLUnknownElement* _34_applet_34_);
		[[cheerp::interface_name(("get_\"basefont\""))]]
		HTMLElement* get__34_basefont_34_();
		[[cheerp::interface_name(("set_\"basefont\""))]]
		void set__34_basefont_34_(HTMLElement* _34_basefont_34_);
		[[cheerp::interface_name(("get_\"bgsound\""))]]
		HTMLUnknownElement* get__34_bgsound_34_();
		[[cheerp::interface_name(("set_\"bgsound\""))]]
		void set__34_bgsound_34_(HTMLUnknownElement* _34_bgsound_34_);
		[[cheerp::interface_name(("get_\"big\""))]]
		HTMLElement* get__34_big_34_();
		[[cheerp::interface_name(("set_\"big\""))]]
		void set__34_big_34_(HTMLElement* _34_big_34_);
		[[cheerp::interface_name(("get_\"blink\""))]]
		HTMLUnknownElement* get__34_blink_34_();
		[[cheerp::interface_name(("set_\"blink\""))]]
		void set__34_blink_34_(HTMLUnknownElement* _34_blink_34_);
		[[cheerp::interface_name(("get_\"center\""))]]
		HTMLElement* get__34_center_34_();
		[[cheerp::interface_name(("set_\"center\""))]]
		void set__34_center_34_(HTMLElement* _34_center_34_);
		[[cheerp::interface_name(("get_\"dir\""))]]
		HTMLDirectoryElement* get__34_dir_34_();
		[[cheerp::interface_name(("set_\"dir\""))]]
		void set__34_dir_34_(HTMLDirectoryElement* _34_dir_34_);
		[[cheerp::interface_name(("get_\"font\""))]]
		HTMLFontElement* get__34_font_34_();
		[[cheerp::interface_name(("set_\"font\""))]]
		void set__34_font_34_(HTMLFontElement* _34_font_34_);
		[[cheerp::interface_name(("get_\"frame\""))]]
		HTMLFrameElement* get__34_frame_34_();
		[[cheerp::interface_name(("set_\"frame\""))]]
		void set__34_frame_34_(HTMLFrameElement* _34_frame_34_);
		[[cheerp::interface_name(("get_\"frameset\""))]]
		HTMLFrameSetElement* get__34_frameset_34_();
		[[cheerp::interface_name(("set_\"frameset\""))]]
		void set__34_frameset_34_(HTMLFrameSetElement* _34_frameset_34_);
		[[cheerp::interface_name(("get_\"isindex\""))]]
		HTMLUnknownElement* get__34_isindex_34_();
		[[cheerp::interface_name(("set_\"isindex\""))]]
		void set__34_isindex_34_(HTMLUnknownElement* _34_isindex_34_);
		[[cheerp::interface_name(("get_\"keygen\""))]]
		HTMLUnknownElement* get__34_keygen_34_();
		[[cheerp::interface_name(("set_\"keygen\""))]]
		void set__34_keygen_34_(HTMLUnknownElement* _34_keygen_34_);
		[[cheerp::interface_name(("get_\"listing\""))]]
		HTMLPreElement* get__34_listing_34_();
		[[cheerp::interface_name(("set_\"listing\""))]]
		void set__34_listing_34_(HTMLPreElement* _34_listing_34_);
		[[cheerp::interface_name(("get_\"marquee\""))]]
		HTMLMarqueeElement* get__34_marquee_34_();
		[[cheerp::interface_name(("set_\"marquee\""))]]
		void set__34_marquee_34_(HTMLMarqueeElement* _34_marquee_34_);
		[[cheerp::interface_name(("get_\"menuitem\""))]]
		HTMLElement* get__34_menuitem_34_();
		[[cheerp::interface_name(("set_\"menuitem\""))]]
		void set__34_menuitem_34_(HTMLElement* _34_menuitem_34_);
		[[cheerp::interface_name(("get_\"multicol\""))]]
		HTMLUnknownElement* get__34_multicol_34_();
		[[cheerp::interface_name(("set_\"multicol\""))]]
		void set__34_multicol_34_(HTMLUnknownElement* _34_multicol_34_);
		[[cheerp::interface_name(("get_\"nextid\""))]]
		HTMLUnknownElement* get__34_nextid_34_();
		[[cheerp::interface_name(("set_\"nextid\""))]]
		void set__34_nextid_34_(HTMLUnknownElement* _34_nextid_34_);
		[[cheerp::interface_name(("get_\"nobr\""))]]
		HTMLElement* get__34_nobr_34_();
		[[cheerp::interface_name(("set_\"nobr\""))]]
		void set__34_nobr_34_(HTMLElement* _34_nobr_34_);
		[[cheerp::interface_name(("get_\"noembed\""))]]
		HTMLElement* get__34_noembed_34_();
		[[cheerp::interface_name(("set_\"noembed\""))]]
		void set__34_noembed_34_(HTMLElement* _34_noembed_34_);
		[[cheerp::interface_name(("get_\"noframes\""))]]
		HTMLElement* get__34_noframes_34_();
		[[cheerp::interface_name(("set_\"noframes\""))]]
		void set__34_noframes_34_(HTMLElement* _34_noframes_34_);
		[[cheerp::interface_name(("get_\"param\""))]]
		HTMLParamElement* get__34_param_34_();
		[[cheerp::interface_name(("set_\"param\""))]]
		void set__34_param_34_(HTMLParamElement* _34_param_34_);
		[[cheerp::interface_name(("get_\"plaintext\""))]]
		HTMLElement* get__34_plaintext_34_();
		[[cheerp::interface_name(("set_\"plaintext\""))]]
		void set__34_plaintext_34_(HTMLElement* _34_plaintext_34_);
		[[cheerp::interface_name(("get_\"rb\""))]]
		HTMLElement* get__34_rb_34_();
		[[cheerp::interface_name(("set_\"rb\""))]]
		void set__34_rb_34_(HTMLElement* _34_rb_34_);
		[[cheerp::interface_name(("get_\"rtc\""))]]
		HTMLElement* get__34_rtc_34_();
		[[cheerp::interface_name(("set_\"rtc\""))]]
		void set__34_rtc_34_(HTMLElement* _34_rtc_34_);
		[[cheerp::interface_name(("get_\"spacer\""))]]
		HTMLUnknownElement* get__34_spacer_34_();
		[[cheerp::interface_name(("set_\"spacer\""))]]
		void set__34_spacer_34_(HTMLUnknownElement* _34_spacer_34_);
		[[cheerp::interface_name(("get_\"strike\""))]]
		HTMLElement* get__34_strike_34_();
		[[cheerp::interface_name(("set_\"strike\""))]]
		void set__34_strike_34_(HTMLElement* _34_strike_34_);
		[[cheerp::interface_name(("get_\"tt\""))]]
		HTMLElement* get__34_tt_34_();
		[[cheerp::interface_name(("set_\"tt\""))]]
		void set__34_tt_34_(HTMLElement* _34_tt_34_);
		[[cheerp::interface_name(("get_\"xmp\""))]]
		HTMLPreElement* get__34_xmp_34_();
		[[cheerp::interface_name(("set_\"xmp\""))]]
		void set__34_xmp_34_(HTMLPreElement* _34_xmp_34_);
	};
	class SVGElementTagNameMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"a\""))]]
		SVGAElement* get__34_a_34_();
		[[cheerp::interface_name(("set_\"a\""))]]
		void set__34_a_34_(SVGAElement* _34_a_34_);
		[[cheerp::interface_name(("get_\"animate\""))]]
		SVGAnimateElement* get__34_animate_34_();
		[[cheerp::interface_name(("set_\"animate\""))]]
		void set__34_animate_34_(SVGAnimateElement* _34_animate_34_);
		[[cheerp::interface_name(("get_\"animateMotion\""))]]
		SVGAnimateMotionElement* get__34_animateMotion_34_();
		[[cheerp::interface_name(("set_\"animateMotion\""))]]
		void set__34_animateMotion_34_(SVGAnimateMotionElement* _34_animateMotion_34_);
		[[cheerp::interface_name(("get_\"animateTransform\""))]]
		SVGAnimateTransformElement* get__34_animateTransform_34_();
		[[cheerp::interface_name(("set_\"animateTransform\""))]]
		void set__34_animateTransform_34_(SVGAnimateTransformElement* _34_animateTransform_34_);
		[[cheerp::interface_name(("get_\"circle\""))]]
		SVGCircleElement* get__34_circle_34_();
		[[cheerp::interface_name(("set_\"circle\""))]]
		void set__34_circle_34_(SVGCircleElement* _34_circle_34_);
		[[cheerp::interface_name(("get_\"clipPath\""))]]
		SVGClipPathElement* get__34_clipPath_34_();
		[[cheerp::interface_name(("set_\"clipPath\""))]]
		void set__34_clipPath_34_(SVGClipPathElement* _34_clipPath_34_);
		[[cheerp::interface_name(("get_\"defs\""))]]
		SVGDefsElement* get__34_defs_34_();
		[[cheerp::interface_name(("set_\"defs\""))]]
		void set__34_defs_34_(SVGDefsElement* _34_defs_34_);
		[[cheerp::interface_name(("get_\"desc\""))]]
		SVGDescElement* get__34_desc_34_();
		[[cheerp::interface_name(("set_\"desc\""))]]
		void set__34_desc_34_(SVGDescElement* _34_desc_34_);
		[[cheerp::interface_name(("get_\"ellipse\""))]]
		SVGEllipseElement* get__34_ellipse_34_();
		[[cheerp::interface_name(("set_\"ellipse\""))]]
		void set__34_ellipse_34_(SVGEllipseElement* _34_ellipse_34_);
		[[cheerp::interface_name(("get_\"feBlend\""))]]
		SVGFEBlendElement* get__34_feBlend_34_();
		[[cheerp::interface_name(("set_\"feBlend\""))]]
		void set__34_feBlend_34_(SVGFEBlendElement* _34_feBlend_34_);
		[[cheerp::interface_name(("get_\"feColorMatrix\""))]]
		SVGFEColorMatrixElement* get__34_feColorMatrix_34_();
		[[cheerp::interface_name(("set_\"feColorMatrix\""))]]
		void set__34_feColorMatrix_34_(SVGFEColorMatrixElement* _34_feColorMatrix_34_);
		[[cheerp::interface_name(("get_\"feComponentTransfer\""))]]
		SVGFEComponentTransferElement* get__34_feComponentTransfer_34_();
		[[cheerp::interface_name(("set_\"feComponentTransfer\""))]]
		void set__34_feComponentTransfer_34_(SVGFEComponentTransferElement* _34_feComponentTransfer_34_);
		[[cheerp::interface_name(("get_\"feComposite\""))]]
		SVGFECompositeElement* get__34_feComposite_34_();
		[[cheerp::interface_name(("set_\"feComposite\""))]]
		void set__34_feComposite_34_(SVGFECompositeElement* _34_feComposite_34_);
		[[cheerp::interface_name(("get_\"feConvolveMatrix\""))]]
		SVGFEConvolveMatrixElement* get__34_feConvolveMatrix_34_();
		[[cheerp::interface_name(("set_\"feConvolveMatrix\""))]]
		void set__34_feConvolveMatrix_34_(SVGFEConvolveMatrixElement* _34_feConvolveMatrix_34_);
		[[cheerp::interface_name(("get_\"feDiffuseLighting\""))]]
		SVGFEDiffuseLightingElement* get__34_feDiffuseLighting_34_();
		[[cheerp::interface_name(("set_\"feDiffuseLighting\""))]]
		void set__34_feDiffuseLighting_34_(SVGFEDiffuseLightingElement* _34_feDiffuseLighting_34_);
		[[cheerp::interface_name(("get_\"feDisplacementMap\""))]]
		SVGFEDisplacementMapElement* get__34_feDisplacementMap_34_();
		[[cheerp::interface_name(("set_\"feDisplacementMap\""))]]
		void set__34_feDisplacementMap_34_(SVGFEDisplacementMapElement* _34_feDisplacementMap_34_);
		[[cheerp::interface_name(("get_\"feDistantLight\""))]]
		SVGFEDistantLightElement* get__34_feDistantLight_34_();
		[[cheerp::interface_name(("set_\"feDistantLight\""))]]
		void set__34_feDistantLight_34_(SVGFEDistantLightElement* _34_feDistantLight_34_);
		[[cheerp::interface_name(("get_\"feDropShadow\""))]]
		SVGFEDropShadowElement* get__34_feDropShadow_34_();
		[[cheerp::interface_name(("set_\"feDropShadow\""))]]
		void set__34_feDropShadow_34_(SVGFEDropShadowElement* _34_feDropShadow_34_);
		[[cheerp::interface_name(("get_\"feFlood\""))]]
		SVGFEFloodElement* get__34_feFlood_34_();
		[[cheerp::interface_name(("set_\"feFlood\""))]]
		void set__34_feFlood_34_(SVGFEFloodElement* _34_feFlood_34_);
		[[cheerp::interface_name(("get_\"feFuncA\""))]]
		SVGFEFuncAElement* get__34_feFuncA_34_();
		[[cheerp::interface_name(("set_\"feFuncA\""))]]
		void set__34_feFuncA_34_(SVGFEFuncAElement* _34_feFuncA_34_);
		[[cheerp::interface_name(("get_\"feFuncB\""))]]
		SVGFEFuncBElement* get__34_feFuncB_34_();
		[[cheerp::interface_name(("set_\"feFuncB\""))]]
		void set__34_feFuncB_34_(SVGFEFuncBElement* _34_feFuncB_34_);
		[[cheerp::interface_name(("get_\"feFuncG\""))]]
		SVGFEFuncGElement* get__34_feFuncG_34_();
		[[cheerp::interface_name(("set_\"feFuncG\""))]]
		void set__34_feFuncG_34_(SVGFEFuncGElement* _34_feFuncG_34_);
		[[cheerp::interface_name(("get_\"feFuncR\""))]]
		SVGFEFuncRElement* get__34_feFuncR_34_();
		[[cheerp::interface_name(("set_\"feFuncR\""))]]
		void set__34_feFuncR_34_(SVGFEFuncRElement* _34_feFuncR_34_);
		[[cheerp::interface_name(("get_\"feGaussianBlur\""))]]
		SVGFEGaussianBlurElement* get__34_feGaussianBlur_34_();
		[[cheerp::interface_name(("set_\"feGaussianBlur\""))]]
		void set__34_feGaussianBlur_34_(SVGFEGaussianBlurElement* _34_feGaussianBlur_34_);
		[[cheerp::interface_name(("get_\"feImage\""))]]
		SVGFEImageElement* get__34_feImage_34_();
		[[cheerp::interface_name(("set_\"feImage\""))]]
		void set__34_feImage_34_(SVGFEImageElement* _34_feImage_34_);
		[[cheerp::interface_name(("get_\"feMerge\""))]]
		SVGFEMergeElement* get__34_feMerge_34_();
		[[cheerp::interface_name(("set_\"feMerge\""))]]
		void set__34_feMerge_34_(SVGFEMergeElement* _34_feMerge_34_);
		[[cheerp::interface_name(("get_\"feMergeNode\""))]]
		SVGFEMergeNodeElement* get__34_feMergeNode_34_();
		[[cheerp::interface_name(("set_\"feMergeNode\""))]]
		void set__34_feMergeNode_34_(SVGFEMergeNodeElement* _34_feMergeNode_34_);
		[[cheerp::interface_name(("get_\"feMorphology\""))]]
		SVGFEMorphologyElement* get__34_feMorphology_34_();
		[[cheerp::interface_name(("set_\"feMorphology\""))]]
		void set__34_feMorphology_34_(SVGFEMorphologyElement* _34_feMorphology_34_);
		[[cheerp::interface_name(("get_\"feOffset\""))]]
		SVGFEOffsetElement* get__34_feOffset_34_();
		[[cheerp::interface_name(("set_\"feOffset\""))]]
		void set__34_feOffset_34_(SVGFEOffsetElement* _34_feOffset_34_);
		[[cheerp::interface_name(("get_\"fePointLight\""))]]
		SVGFEPointLightElement* get__34_fePointLight_34_();
		[[cheerp::interface_name(("set_\"fePointLight\""))]]
		void set__34_fePointLight_34_(SVGFEPointLightElement* _34_fePointLight_34_);
		[[cheerp::interface_name(("get_\"feSpecularLighting\""))]]
		SVGFESpecularLightingElement* get__34_feSpecularLighting_34_();
		[[cheerp::interface_name(("set_\"feSpecularLighting\""))]]
		void set__34_feSpecularLighting_34_(SVGFESpecularLightingElement* _34_feSpecularLighting_34_);
		[[cheerp::interface_name(("get_\"feSpotLight\""))]]
		SVGFESpotLightElement* get__34_feSpotLight_34_();
		[[cheerp::interface_name(("set_\"feSpotLight\""))]]
		void set__34_feSpotLight_34_(SVGFESpotLightElement* _34_feSpotLight_34_);
		[[cheerp::interface_name(("get_\"feTile\""))]]
		SVGFETileElement* get__34_feTile_34_();
		[[cheerp::interface_name(("set_\"feTile\""))]]
		void set__34_feTile_34_(SVGFETileElement* _34_feTile_34_);
		[[cheerp::interface_name(("get_\"feTurbulence\""))]]
		SVGFETurbulenceElement* get__34_feTurbulence_34_();
		[[cheerp::interface_name(("set_\"feTurbulence\""))]]
		void set__34_feTurbulence_34_(SVGFETurbulenceElement* _34_feTurbulence_34_);
		[[cheerp::interface_name(("get_\"filter\""))]]
		SVGFilterElement* get__34_filter_34_();
		[[cheerp::interface_name(("set_\"filter\""))]]
		void set__34_filter_34_(SVGFilterElement* _34_filter_34_);
		[[cheerp::interface_name(("get_\"foreignObject\""))]]
		SVGForeignObjectElement* get__34_foreignObject_34_();
		[[cheerp::interface_name(("set_\"foreignObject\""))]]
		void set__34_foreignObject_34_(SVGForeignObjectElement* _34_foreignObject_34_);
		[[cheerp::interface_name(("get_\"g\""))]]
		SVGGElement* get__34_g_34_();
		[[cheerp::interface_name(("set_\"g\""))]]
		void set__34_g_34_(SVGGElement* _34_g_34_);
		[[cheerp::interface_name(("get_\"image\""))]]
		SVGImageElement* get__34_image_34_();
		[[cheerp::interface_name(("set_\"image\""))]]
		void set__34_image_34_(SVGImageElement* _34_image_34_);
		[[cheerp::interface_name(("get_\"line\""))]]
		SVGLineElement* get__34_line_34_();
		[[cheerp::interface_name(("set_\"line\""))]]
		void set__34_line_34_(SVGLineElement* _34_line_34_);
		[[cheerp::interface_name(("get_\"linearGradient\""))]]
		SVGLinearGradientElement* get__34_linearGradient_34_();
		[[cheerp::interface_name(("set_\"linearGradient\""))]]
		void set__34_linearGradient_34_(SVGLinearGradientElement* _34_linearGradient_34_);
		[[cheerp::interface_name(("get_\"marker\""))]]
		SVGMarkerElement* get__34_marker_34_();
		[[cheerp::interface_name(("set_\"marker\""))]]
		void set__34_marker_34_(SVGMarkerElement* _34_marker_34_);
		[[cheerp::interface_name(("get_\"mask\""))]]
		SVGMaskElement* get__34_mask_34_();
		[[cheerp::interface_name(("set_\"mask\""))]]
		void set__34_mask_34_(SVGMaskElement* _34_mask_34_);
		[[cheerp::interface_name(("get_\"metadata\""))]]
		SVGMetadataElement* get__34_metadata_34_();
		[[cheerp::interface_name(("set_\"metadata\""))]]
		void set__34_metadata_34_(SVGMetadataElement* _34_metadata_34_);
		[[cheerp::interface_name(("get_\"mpath\""))]]
		SVGMPathElement* get__34_mpath_34_();
		[[cheerp::interface_name(("set_\"mpath\""))]]
		void set__34_mpath_34_(SVGMPathElement* _34_mpath_34_);
		[[cheerp::interface_name(("get_\"path\""))]]
		SVGPathElement* get__34_path_34_();
		[[cheerp::interface_name(("set_\"path\""))]]
		void set__34_path_34_(SVGPathElement* _34_path_34_);
		[[cheerp::interface_name(("get_\"pattern\""))]]
		SVGPatternElement* get__34_pattern_34_();
		[[cheerp::interface_name(("set_\"pattern\""))]]
		void set__34_pattern_34_(SVGPatternElement* _34_pattern_34_);
		[[cheerp::interface_name(("get_\"polygon\""))]]
		SVGPolygonElement* get__34_polygon_34_();
		[[cheerp::interface_name(("set_\"polygon\""))]]
		void set__34_polygon_34_(SVGPolygonElement* _34_polygon_34_);
		[[cheerp::interface_name(("get_\"polyline\""))]]
		SVGPolylineElement* get__34_polyline_34_();
		[[cheerp::interface_name(("set_\"polyline\""))]]
		void set__34_polyline_34_(SVGPolylineElement* _34_polyline_34_);
		[[cheerp::interface_name(("get_\"radialGradient\""))]]
		SVGRadialGradientElement* get__34_radialGradient_34_();
		[[cheerp::interface_name(("set_\"radialGradient\""))]]
		void set__34_radialGradient_34_(SVGRadialGradientElement* _34_radialGradient_34_);
		[[cheerp::interface_name(("get_\"rect\""))]]
		SVGRectElement* get__34_rect_34_();
		[[cheerp::interface_name(("set_\"rect\""))]]
		void set__34_rect_34_(SVGRectElement* _34_rect_34_);
		[[cheerp::interface_name(("get_\"script\""))]]
		SVGScriptElement* get__34_script_34_();
		[[cheerp::interface_name(("set_\"script\""))]]
		void set__34_script_34_(SVGScriptElement* _34_script_34_);
		[[cheerp::interface_name(("get_\"set\""))]]
		SVGSetElement* get__34_set_34_();
		[[cheerp::interface_name(("set_\"set\""))]]
		void set__34_set_34_(SVGSetElement* _34_set_34_);
		[[cheerp::interface_name(("get_\"stop\""))]]
		SVGStopElement* get__34_stop_34_();
		[[cheerp::interface_name(("set_\"stop\""))]]
		void set__34_stop_34_(SVGStopElement* _34_stop_34_);
		[[cheerp::interface_name(("get_\"style\""))]]
		SVGStyleElement* get__34_style_34_();
		[[cheerp::interface_name(("set_\"style\""))]]
		void set__34_style_34_(SVGStyleElement* _34_style_34_);
		[[cheerp::interface_name(("get_\"svg\""))]]
		SVGSVGElement* get__34_svg_34_();
		[[cheerp::interface_name(("set_\"svg\""))]]
		void set__34_svg_34_(SVGSVGElement* _34_svg_34_);
		[[cheerp::interface_name(("get_\"switch\""))]]
		SVGSwitchElement* get__34_switch_34_();
		[[cheerp::interface_name(("set_\"switch\""))]]
		void set__34_switch_34_(SVGSwitchElement* _34_switch_34_);
		[[cheerp::interface_name(("get_\"symbol\""))]]
		SVGSymbolElement* get__34_symbol_34_();
		[[cheerp::interface_name(("set_\"symbol\""))]]
		void set__34_symbol_34_(SVGSymbolElement* _34_symbol_34_);
		[[cheerp::interface_name(("get_\"text\""))]]
		SVGTextElement* get__34_text_34_();
		[[cheerp::interface_name(("set_\"text\""))]]
		void set__34_text_34_(SVGTextElement* _34_text_34_);
		[[cheerp::interface_name(("get_\"textPath\""))]]
		SVGTextPathElement* get__34_textPath_34_();
		[[cheerp::interface_name(("set_\"textPath\""))]]
		void set__34_textPath_34_(SVGTextPathElement* _34_textPath_34_);
		[[cheerp::interface_name(("get_\"title\""))]]
		SVGTitleElement* get__34_title_34_();
		[[cheerp::interface_name(("set_\"title\""))]]
		void set__34_title_34_(SVGTitleElement* _34_title_34_);
		[[cheerp::interface_name(("get_\"tspan\""))]]
		SVGTSpanElement* get__34_tspan_34_();
		[[cheerp::interface_name(("set_\"tspan\""))]]
		void set__34_tspan_34_(SVGTSpanElement* _34_tspan_34_);
		[[cheerp::interface_name(("get_\"use\""))]]
		SVGUseElement* get__34_use_34_();
		[[cheerp::interface_name(("set_\"use\""))]]
		void set__34_use_34_(SVGUseElement* _34_use_34_);
		[[cheerp::interface_name(("get_\"view\""))]]
		SVGViewElement* get__34_view_34_();
		[[cheerp::interface_name(("set_\"view\""))]]
		void set__34_view_34_(SVGViewElement* _34_view_34_);
	};
	class MathMLElementTagNameMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"annotation\""))]]
		MathMLElement* get__34_annotation_34_();
		[[cheerp::interface_name(("set_\"annotation\""))]]
		void set__34_annotation_34_(MathMLElement* _34_annotation_34_);
		[[cheerp::interface_name(("get_\"annotation-xml\""))]]
		MathMLElement* get__34_annotation_45_xml_34_();
		[[cheerp::interface_name(("set_\"annotation-xml\""))]]
		void set__34_annotation_45_xml_34_(MathMLElement* _34_annotation_45_xml_34_);
		[[cheerp::interface_name(("get_\"maction\""))]]
		MathMLElement* get__34_maction_34_();
		[[cheerp::interface_name(("set_\"maction\""))]]
		void set__34_maction_34_(MathMLElement* _34_maction_34_);
		[[cheerp::interface_name(("get_\"math\""))]]
		MathMLElement* get__34_math_34_();
		[[cheerp::interface_name(("set_\"math\""))]]
		void set__34_math_34_(MathMLElement* _34_math_34_);
		[[cheerp::interface_name(("get_\"merror\""))]]
		MathMLElement* get__34_merror_34_();
		[[cheerp::interface_name(("set_\"merror\""))]]
		void set__34_merror_34_(MathMLElement* _34_merror_34_);
		[[cheerp::interface_name(("get_\"mfrac\""))]]
		MathMLElement* get__34_mfrac_34_();
		[[cheerp::interface_name(("set_\"mfrac\""))]]
		void set__34_mfrac_34_(MathMLElement* _34_mfrac_34_);
		[[cheerp::interface_name(("get_\"mi\""))]]
		MathMLElement* get__34_mi_34_();
		[[cheerp::interface_name(("set_\"mi\""))]]
		void set__34_mi_34_(MathMLElement* _34_mi_34_);
		[[cheerp::interface_name(("get_\"mmultiscripts\""))]]
		MathMLElement* get__34_mmultiscripts_34_();
		[[cheerp::interface_name(("set_\"mmultiscripts\""))]]
		void set__34_mmultiscripts_34_(MathMLElement* _34_mmultiscripts_34_);
		[[cheerp::interface_name(("get_\"mn\""))]]
		MathMLElement* get__34_mn_34_();
		[[cheerp::interface_name(("set_\"mn\""))]]
		void set__34_mn_34_(MathMLElement* _34_mn_34_);
		[[cheerp::interface_name(("get_\"mo\""))]]
		MathMLElement* get__34_mo_34_();
		[[cheerp::interface_name(("set_\"mo\""))]]
		void set__34_mo_34_(MathMLElement* _34_mo_34_);
		[[cheerp::interface_name(("get_\"mover\""))]]
		MathMLElement* get__34_mover_34_();
		[[cheerp::interface_name(("set_\"mover\""))]]
		void set__34_mover_34_(MathMLElement* _34_mover_34_);
		[[cheerp::interface_name(("get_\"mpadded\""))]]
		MathMLElement* get__34_mpadded_34_();
		[[cheerp::interface_name(("set_\"mpadded\""))]]
		void set__34_mpadded_34_(MathMLElement* _34_mpadded_34_);
		[[cheerp::interface_name(("get_\"mphantom\""))]]
		MathMLElement* get__34_mphantom_34_();
		[[cheerp::interface_name(("set_\"mphantom\""))]]
		void set__34_mphantom_34_(MathMLElement* _34_mphantom_34_);
		[[cheerp::interface_name(("get_\"mprescripts\""))]]
		MathMLElement* get__34_mprescripts_34_();
		[[cheerp::interface_name(("set_\"mprescripts\""))]]
		void set__34_mprescripts_34_(MathMLElement* _34_mprescripts_34_);
		[[cheerp::interface_name(("get_\"mroot\""))]]
		MathMLElement* get__34_mroot_34_();
		[[cheerp::interface_name(("set_\"mroot\""))]]
		void set__34_mroot_34_(MathMLElement* _34_mroot_34_);
		[[cheerp::interface_name(("get_\"mrow\""))]]
		MathMLElement* get__34_mrow_34_();
		[[cheerp::interface_name(("set_\"mrow\""))]]
		void set__34_mrow_34_(MathMLElement* _34_mrow_34_);
		[[cheerp::interface_name(("get_\"ms\""))]]
		MathMLElement* get__34_ms_34_();
		[[cheerp::interface_name(("set_\"ms\""))]]
		void set__34_ms_34_(MathMLElement* _34_ms_34_);
		[[cheerp::interface_name(("get_\"mspace\""))]]
		MathMLElement* get__34_mspace_34_();
		[[cheerp::interface_name(("set_\"mspace\""))]]
		void set__34_mspace_34_(MathMLElement* _34_mspace_34_);
		[[cheerp::interface_name(("get_\"msqrt\""))]]
		MathMLElement* get__34_msqrt_34_();
		[[cheerp::interface_name(("set_\"msqrt\""))]]
		void set__34_msqrt_34_(MathMLElement* _34_msqrt_34_);
		[[cheerp::interface_name(("get_\"mstyle\""))]]
		MathMLElement* get__34_mstyle_34_();
		[[cheerp::interface_name(("set_\"mstyle\""))]]
		void set__34_mstyle_34_(MathMLElement* _34_mstyle_34_);
		[[cheerp::interface_name(("get_\"msub\""))]]
		MathMLElement* get__34_msub_34_();
		[[cheerp::interface_name(("set_\"msub\""))]]
		void set__34_msub_34_(MathMLElement* _34_msub_34_);
		[[cheerp::interface_name(("get_\"msubsup\""))]]
		MathMLElement* get__34_msubsup_34_();
		[[cheerp::interface_name(("set_\"msubsup\""))]]
		void set__34_msubsup_34_(MathMLElement* _34_msubsup_34_);
		[[cheerp::interface_name(("get_\"msup\""))]]
		MathMLElement* get__34_msup_34_();
		[[cheerp::interface_name(("set_\"msup\""))]]
		void set__34_msup_34_(MathMLElement* _34_msup_34_);
		[[cheerp::interface_name(("get_\"mtable\""))]]
		MathMLElement* get__34_mtable_34_();
		[[cheerp::interface_name(("set_\"mtable\""))]]
		void set__34_mtable_34_(MathMLElement* _34_mtable_34_);
		[[cheerp::interface_name(("get_\"mtd\""))]]
		MathMLElement* get__34_mtd_34_();
		[[cheerp::interface_name(("set_\"mtd\""))]]
		void set__34_mtd_34_(MathMLElement* _34_mtd_34_);
		[[cheerp::interface_name(("get_\"mtext\""))]]
		MathMLElement* get__34_mtext_34_();
		[[cheerp::interface_name(("set_\"mtext\""))]]
		void set__34_mtext_34_(MathMLElement* _34_mtext_34_);
		[[cheerp::interface_name(("get_\"mtr\""))]]
		MathMLElement* get__34_mtr_34_();
		[[cheerp::interface_name(("set_\"mtr\""))]]
		void set__34_mtr_34_(MathMLElement* _34_mtr_34_);
		[[cheerp::interface_name(("get_\"munder\""))]]
		MathMLElement* get__34_munder_34_();
		[[cheerp::interface_name(("set_\"munder\""))]]
		void set__34_munder_34_(MathMLElement* _34_munder_34_);
		[[cheerp::interface_name(("get_\"munderover\""))]]
		MathMLElement* get__34_munderover_34_();
		[[cheerp::interface_name(("set_\"munderover\""))]]
		void set__34_munderover_34_(MathMLElement* _34_munderover_34_);
		[[cheerp::interface_name(("get_\"semantics\""))]]
		MathMLElement* get__34_semantics_34_();
		[[cheerp::interface_name(("set_\"semantics\""))]]
		void set__34_semantics_34_(MathMLElement* _34_semantics_34_);
	};
	using ElementTagNameMap = HTMLElementTagNameMap;
	extern Object Audio;
	extern Object Image;
	extern Object Option;
	extern Navigator clientInformation;
	extern bool closed;
	extern CustomElementRegistry customElements;
	extern double devicePixelRatio;
	extern Document document;
	extern Event event;
	extern External external;
	extern Element frameElement;
	extern Window frames;
	extern History history;
	extern double innerHeight;
	extern double innerWidth;
	extern double length;
	class WorkerLocation;
	extern WorkerLocation location;
	extern BarProp locationbar;
	extern BarProp menubar;
	extern String name;
	class WorkerNavigator;
	extern WorkerNavigator navigator;
	extern _Function<_Any*(DeviceMotionEvent*)> ondevicemotion;
	extern _Function<_Any*(DeviceOrientationEvent*)> ondeviceorientation;
	extern _Function<_Any*(Event*)> onorientationchange;
	extern _Any* opener;
	extern double orientation;
	extern double outerHeight;
	extern double outerWidth;
	extern double pageXOffset;
	extern double pageYOffset;
	extern Window parent;
	extern BarProp personalbar;
	extern Screen screen;
	extern double screenLeft;
	extern double screenTop;
	extern double screenX;
	extern double screenY;
	extern double scrollX;
	extern double scrollY;
	extern BarProp scrollbars;
	class WorkerGlobalScope;
	extern WorkerGlobalScope self;
	extern SpeechSynthesis speechSynthesis;
	extern String status;
	extern BarProp statusbar;
	extern BarProp toolbar;
	extern Window top;
	extern VisualViewport visualViewport;
	extern Window window;
	void alert();
	void alert(const _Any& message);
	void blur();
	void cancelIdleCallback(double handle);
	void captureEvents();
	void close();
	bool confirm();
	bool confirm(const String& message);
	void focus();
	CSSStyleDeclaration* getComputedStyle(Element* elt);
	CSSStyleDeclaration* getComputedStyle(Element* elt, const String& pseudoElt);
	Selection* getSelection();
	MediaQueryList* matchMedia(const String& query);
	void moveBy(double x, double y);
	void moveTo(double x, double y);
	Window* open();
	Window* open(const String& url);
	Window* open(URL* url);
	Window* open(const String& url, const String& target);
	Window* open(URL* url, const String& target);
	Window* open(const String& url, const String& target, const String& features);
	Window* open(URL* url, const String& target, const String& features);
	void postMessage(const _Any& message, const String& targetOrigin);
	void postMessage(const _Any& message, const String& targetOrigin, Array* transfer);
	void postMessage(const _Any& message);
	void postMessage(const _Any& message, WindowPostMessageOptions* options);
	void postMessage(const _Any& message, Array* transfer);
	void postMessage(const _Any& message, StructuredSerializeOptions* options);
	void print();
	String* prompt();
	String* prompt(const String& message);
	String* prompt(const String& message, const String& _default);
	void releaseEvents();
	double requestIdleCallback(EventListener* callback);
	double requestIdleCallback(const _Function<void(IdleDeadline*)>& callback);
	double requestIdleCallback(EventListener* callback, IdleRequestOptions* options);
	double requestIdleCallback(const _Function<void(IdleDeadline*)>& callback, IdleRequestOptions* options);
	void resizeBy(double x, double y);
	void resizeTo(double width, double height);
	void scroll();
	void scroll(ScrollToOptions* options);
	void scroll(double x, double y);
	void scrollBy();
	void scrollBy(ScrollToOptions* options);
	void scrollBy(double x, double y);
	void scrollTo();
	void scrollTo(ScrollToOptions* options);
	void scrollTo(double x, double y);
	void stop();
	String* toString();
	bool dispatchEvent(Event* event);
	void cancelAnimationFrame(double handle);
	double requestAnimationFrame(EventListener* callback);
	double requestAnimationFrame(const _Function<void(double)>& callback);
	extern _Function<_Any*(UIEvent*)> onabort;
	extern _Function<_Any*(AnimationEvent*)> onanimationcancel;
	extern _Function<_Any*(AnimationEvent*)> onanimationend;
	extern _Function<_Any*(AnimationEvent*)> onanimationiteration;
	extern _Function<_Any*(AnimationEvent*)> onanimationstart;
	extern _Function<_Any*(MouseEvent*)> onauxclick;
	extern _Function<_Any*(InputEvent*)> onbeforeinput;
	extern _Function<_Any*(FocusEvent*)> onblur;
	extern _Function<_Any*(Event*)> oncancel;
	extern _Function<_Any*(Event*)> oncanplay;
	extern _Function<_Any*(Event*)> oncanplaythrough;
	extern _Function<_Any*(Event*)> onchange;
	extern _Function<_Any*(MouseEvent*)> onclick;
	extern _Function<_Any*(Event*)> onclose;
	extern _Function<_Any*(MouseEvent*)> oncontextmenu;
	extern _Function<_Any*(ClipboardEvent*)> oncopy;
	extern _Function<_Any*(Event*)> oncuechange;
	extern _Function<_Any*(ClipboardEvent*)> oncut;
	extern _Function<_Any*(MouseEvent*)> ondblclick;
	extern _Function<_Any*(DragEvent*)> ondrag;
	extern _Function<_Any*(DragEvent*)> ondragend;
	extern _Function<_Any*(DragEvent*)> ondragenter;
	extern _Function<_Any*(DragEvent*)> ondragleave;
	extern _Function<_Any*(DragEvent*)> ondragover;
	extern _Function<_Any*(DragEvent*)> ondragstart;
	extern _Function<_Any*(DragEvent*)> ondrop;
	extern _Function<_Any*(Event*)> ondurationchange;
	extern _Function<_Any*(Event*)> onemptied;
	extern _Function<_Any*(Event*)> onended;
	extern _Function<_Any*(ErrorEvent*)> onerror;
	extern _Function<_Any*(FocusEvent*)> onfocus;
	extern _Function<_Any*(FormDataEvent*)> onformdata;
	extern _Function<_Any*(PointerEvent*)> ongotpointercapture;
	extern _Function<_Any*(Event*)> oninput;
	extern _Function<_Any*(Event*)> oninvalid;
	extern _Function<_Any*(KeyboardEvent*)> onkeydown;
	extern _Function<_Any*(KeyboardEvent*)> onkeypress;
	extern _Function<_Any*(KeyboardEvent*)> onkeyup;
	extern _Function<_Any*(Event*)> onload;
	extern _Function<_Any*(Event*)> onloadeddata;
	extern _Function<_Any*(Event*)> onloadedmetadata;
	extern _Function<_Any*(Event*)> onloadstart;
	extern _Function<_Any*(PointerEvent*)> onlostpointercapture;
	extern _Function<_Any*(MouseEvent*)> onmousedown;
	extern _Function<_Any*(MouseEvent*)> onmouseenter;
	extern _Function<_Any*(MouseEvent*)> onmouseleave;
	extern _Function<_Any*(MouseEvent*)> onmousemove;
	extern _Function<_Any*(MouseEvent*)> onmouseout;
	extern _Function<_Any*(MouseEvent*)> onmouseover;
	extern _Function<_Any*(MouseEvent*)> onmouseup;
	extern _Function<_Any*(ClipboardEvent*)> onpaste;
	extern _Function<_Any*(Event*)> onpause;
	extern _Function<_Any*(Event*)> onplay;
	extern _Function<_Any*(Event*)> onplaying;
	extern _Function<_Any*(PointerEvent*)> onpointercancel;
	extern _Function<_Any*(PointerEvent*)> onpointerdown;
	extern _Function<_Any*(PointerEvent*)> onpointerenter;
	extern _Function<_Any*(PointerEvent*)> onpointerleave;
	extern _Function<_Any*(PointerEvent*)> onpointermove;
	extern _Function<_Any*(PointerEvent*)> onpointerout;
	extern _Function<_Any*(PointerEvent*)> onpointerover;
	extern _Function<_Any*(PointerEvent*)> onpointerup;
	extern _Function<_Any*(ProgressEvent<EventTarget*>*)> onprogress;
	extern _Function<_Any*(Event*)> onratechange;
	extern _Function<_Any*(Event*)> onreset;
	extern _Function<_Any*(UIEvent*)> onresize;
	extern _Function<_Any*(Event*)> onscroll;
	extern _Function<_Any*(Event*)> onscrollend;
	extern _Function<_Any*(SecurityPolicyViolationEvent*)> onsecuritypolicyviolation;
	extern _Function<_Any*(Event*)> onseeked;
	extern _Function<_Any*(Event*)> onseeking;
	extern _Function<_Any*(Event*)> onselect;
	extern _Function<_Any*(Event*)> onselectionchange;
	extern _Function<_Any*(Event*)> onselectstart;
	extern _Function<_Any*(Event*)> onslotchange;
	extern _Function<_Any*(Event*)> onstalled;
	extern _Function<_Any*(SubmitEvent*)> onsubmit;
	extern _Function<_Any*(Event*)> onsuspend;
	extern _Function<_Any*(Event*)> ontimeupdate;
	extern _Function<_Any*(Event*)> ontoggle;
	extern _Function<_Any*(TouchEvent*)> ontouchcancel;
	extern _Function<_Any*(TouchEvent*)> ontouchend;
	extern _Function<_Any*(TouchEvent*)> ontouchmove;
	extern _Function<_Any*(TouchEvent*)> ontouchstart;
	extern _Function<_Any*(TransitionEvent*)> ontransitioncancel;
	extern _Function<_Any*(TransitionEvent*)> ontransitionend;
	extern _Function<_Any*(TransitionEvent*)> ontransitionrun;
	extern _Function<_Any*(TransitionEvent*)> ontransitionstart;
	extern _Function<_Any*(Event*)> onvolumechange;
	extern _Function<_Any*(Event*)> onwaiting;
	extern _Function<_Any*(Event*)> onwebkitanimationend;
	extern _Function<_Any*(Event*)> onwebkitanimationiteration;
	extern _Function<_Any*(Event*)> onwebkitanimationstart;
	extern _Function<_Any*(Event*)> onwebkittransitionend;
	extern _Function<_Any*(WheelEvent*)> onwheel;
	extern _Function<_Any*(Event*)> onafterprint;
	extern _Function<_Any*(Event*)> onbeforeprint;
	extern _Function<_Any*(BeforeUnloadEvent*)> onbeforeunload;
	extern _Function<_Any*(GamepadEvent*)> ongamepadconnected;
	extern _Function<_Any*(GamepadEvent*)> ongamepaddisconnected;
	extern _Function<_Any*(HashChangeEvent*)> onhashchange;
	extern _Function<_Any*(Event*)> onlanguagechange;
	extern _Function<_Any*(MessageEvent<_Any*>*)> onmessage;
	extern _Function<_Any*(MessageEvent<_Any*>*)> onmessageerror;
	extern _Function<_Any*(Event*)> onoffline;
	extern _Function<_Any*(Event*)> ononline;
	extern _Function<_Any*(PageTransitionEvent*)> onpagehide;
	extern _Function<_Any*(PageTransitionEvent*)> onpageshow;
	extern _Function<_Any*(PopStateEvent*)> onpopstate;
	extern _Function<_Any*(PromiseRejectionEvent*)> onrejectionhandled;
	extern _Function<_Any*(StorageEvent*)> onstorage;
	extern _Function<_Any*(PromiseRejectionEvent*)> onunhandledrejection;
	extern _Function<_Any*(Event*)> onunload;
	extern Storage localStorage;
	extern CacheStorage caches;
	extern bool crossOriginIsolated;
	extern Crypto crypto;
	extern IDBFactory indexedDB;
	extern bool isSecureContext;
	extern String origin;
	extern Performance performance;
	String* atob(const String& data);
	String* btoa(const String& data);
	void clearInterval(double id);
	void clearTimeout(double id);
	Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image);
	Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, ImageBitmapOptions* options);
	Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh);
	Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh, ImageBitmapOptions* options);
	Promise<Response*>* fetch(const String& input);
	Promise<Response*>* fetch(const _Union<Request*, URL*>& input);
	Promise<Response*>* fetch(const String& input, RequestInit* init);
	Promise<Response*>* fetch(const _Union<Request*, URL*>& input, RequestInit* init);
	void queueMicrotask(EventListener* callback);
	void queueMicrotask(const _Function<void()>& callback);
	void reportError(const _Any& e);
	double setInterval(const String& handler);
	double setInterval(const _Function<void()>& handler);
	double setInterval(Function* handler);
	template<class... _Args>
	double setInterval(const String& handler, double timeout, _Args... arguments);
	template<class... _Args>
	double setInterval(const _Function<void()>& handler, double timeout, _Args... arguments);
	template<class... _Args>
	double setInterval(Function* handler, double timeout, _Args... arguments);
	double setTimeout(const String& handler);
	double setTimeout(const _Function<void()>& handler);
	double setTimeout(Function* handler);
	template<class... _Args>
	double setTimeout(const String& handler, double timeout, _Args... arguments);
	template<class... _Args>
	double setTimeout(const _Function<void()>& handler, double timeout, _Args... arguments);
	template<class... _Args>
	double setTimeout(Function* handler, double timeout, _Args... arguments);
	template<class _T0 = _Any*>
	_T0 structuredClone(_T0 value);
	template<class _T0 = _Any*>
	_T0 structuredClone(_T0 value, StructuredSerializeOptions* options);
	extern Storage sessionStorage;
	void addEventListener(const String& type, EventListener* listener);
	void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
	void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
	void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
	void addEventListener(const String& type, EventListenerObject* listener);
	void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
	void removeEventListener(const String& type, EventListener* listener);
	void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
	void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
	void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
	void removeEventListener(const String& type, EventListenerObject* listener);
	void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
	using AlgorithmIdentifier = _Any;
	using AllowSharedBufferSource = _Any;
	using AutoFill = String;
	using AutoFillField = String;
	using AutoFillSection = String;
	using BigInteger = Uint8Array;
	using BinaryData = _Any;
	using BlobPart = _Any;
	using BodyInit = _Any;
	using BufferSource = _Any;
	using COSEAlgorithmIdentifier = double;
	using CSSKeywordish = _Any;
	using CSSNumberish = _Any;
	using CSSPerspectiveValue = _Any;
	using CSSUnparsedSegment = _Any;
	using CanvasImageSource = _Any;
	using ClipboardItemData = Promise<_Any*>;
	using ClipboardItems = TArray<ClipboardItem*>;
	using ConstrainBoolean = _Any;
	using ConstrainDOMString = _Any;
	using ConstrainDouble = _Any;
	using ConstrainULong = _Any;
	using DOMHighResTimeStamp = double;
	using EpochTimeStamp = double;
	using EventListenerOrEventListenerObject = _Any;
	using FileSystemWriteChunkType = _Any;
	using Float32List = _Any;
	using FormDataEntryValue = _Any;
	using GLbitfield = double;
	using GLboolean = bool;
	using GLclampf = double;
	using GLenum = double;
	using GLfloat = double;
	using GLint = double;
	using GLint64 = double;
	using GLintptr = double;
	using GLsizei = double;
	using GLsizeiptr = double;
	using GLuint = double;
	using GLuint64 = double;
	using HTMLOrSVGImageElement = _Any;
	using HTMLOrSVGScriptElement = _Any;
	using HashAlgorithmIdentifier = _Any;
	using HeadersInit = _Any;
	using IDBValidKey = _Any;
	using ImageBitmapSource = _Any;
	using Int32List = _Any;
	using LineAndPositionSetting = _Any;
	using MediaProvider = _Any;
	using MessageEventSource = _Any;
	using MutationRecordType = String;
	using NamedCurve = String;
	using OffscreenRenderingContext = _Any;
	using OnBeforeUnloadEventHandler = _Function<String*(Event*)>;
	using OnErrorEventHandler = _Function<_Any*(_Union<String*, Event*>*, String*, double, double, Error*)>;
	using OptionalPostfixToken = String;
	using OptionalPrefixToken = String;
	using PerformanceEntryList = TArray<PerformanceEntry*>;
	using ReadableStreamController = _Any;
	using ReadableStreamReadResult = _Any;
	using ReadableStreamReader = _Any;
	using RenderingContext = _Any;
	using ReportList = TArray<Report*>;
	using RequestInfo = _Any;
	using TexImageSource = _Any;
	using TimerHandler = _Any;
	using Transferable = _Any;
	using Uint32List = _Any;
	using VibratePattern = _Any;
	using WindowProxy = Window;
	using XMLHttpRequestBodyInit = _Any;
	using AlignSetting = String;
	using AlphaOption = String;
	using AnimationPlayState = String;
	using AnimationReplaceState = String;
	using AppendMode = String;
	using AttestationConveyancePreference = String;
	using AudioContextLatencyCategory = String;
	using AudioContextState = String;
	using AuthenticatorAttachment = String;
	using AuthenticatorTransport = String;
	using AutoFillAddressKind = String;
	using AutoFillBase = String;
	using AutoFillContactField = String;
	using AutoFillContactKind = String;
	using AutoFillCredentialField = String;
	using AutoFillNormalField = String;
	using AutoKeyword = String;
	using AutomationRate = String;
	using AvcBitstreamFormat = String;
	using BinaryType = String;
	using BiquadFilterType = String;
	using CSSMathOperator = String;
	using CSSNumericBaseType = String;
	using CanPlayTypeResult = String;
	using CanvasDirection = String;
	using CanvasFillRule = String;
	using CanvasFontKerning = String;
	using CanvasFontStretch = String;
	using CanvasFontVariantCaps = String;
	using CanvasLineCap = String;
	using CanvasLineJoin = String;
	using CanvasTextAlign = String;
	using CanvasTextBaseline = String;
	using CanvasTextRendering = String;
	using ChannelCountMode = String;
	using ChannelInterpretation = String;
	using ClientTypes = String;
	using CodecState = String;
	using ColorGamut = String;
	using ColorSpaceConversion = String;
	using CompositeOperation = String;
	using CompositeOperationOrAuto = String;
	using CompressionFormat = String;
	using CredentialMediationRequirement = String;
	using DOMParserSupportedType = String;
	using DirectionSetting = String;
	using DisplayCaptureSurfaceType = String;
	using DistanceModelType = String;
	using DocumentReadyState = String;
	using DocumentVisibilityState = String;
	using EncodedVideoChunkType = String;
	using EndOfStreamError = String;
	using EndingType = String;
	using FileSystemHandleKind = String;
	using FillMode = String;
	using FontDisplay = String;
	using FontFaceLoadStatus = String;
	using FontFaceSetLoadStatus = String;
	using FullscreenNavigationUI = String;
	using GamepadHapticActuatorType = String;
	using GamepadHapticEffectType = String;
	using GamepadHapticsResult = String;
	using GamepadMappingType = String;
	using GlobalCompositeOperation = String;
	using HardwareAcceleration = String;
	using HdrMetadataType = String;
	using IDBCursorDirection = String;
	using IDBRequestReadyState = String;
	using IDBTransactionDurability = String;
	using IDBTransactionMode = String;
	using ImageOrientation = String;
	using ImageSmoothingQuality = String;
	using InsertPosition = String;
	using IterationCompositeOperation = String;
	using KeyFormat = String;
	using KeyType = String;
	using KeyUsage = String;
	using LatencyMode = String;
	using LineAlignSetting = String;
	using LockMode = String;
	using MIDIPortConnectionState = String;
	using MIDIPortDeviceState = String;
	using MIDIPortType = String;
	using MediaDecodingType = String;
	using MediaDeviceKind = String;
	using MediaEncodingType = String;
	using MediaKeyMessageType = String;
	using MediaKeySessionClosedReason = String;
	using MediaKeySessionType = String;
	using MediaKeyStatus = String;
	using MediaKeysRequirement = String;
	using MediaSessionAction = String;
	using MediaSessionPlaybackState = String;
	using MediaStreamTrackState = String;
	using NavigationTimingType = String;
	using NotificationDirection = String;
	using NotificationPermission = String;
	using OffscreenRenderingContextId = String;
	using OrientationType = String;
	using OscillatorType = String;
	using OverSampleType = String;
	using PanningModelType = String;
	using PaymentComplete = String;
	using PermissionName = String;
	using PermissionState = String;
	using PlaybackDirection = String;
	using PositionAlignSetting = String;
	using PredefinedColorSpace = String;
	using PremultiplyAlpha = String;
	using PresentationStyle = String;
	using PublicKeyCredentialType = String;
	using PushEncryptionKeyName = String;
	using RTCBundlePolicy = String;
	using RTCDataChannelState = String;
	using RTCDegradationPreference = String;
	using RTCDtlsTransportState = String;
	using RTCEncodedVideoFrameType = String;
	using RTCErrorDetailType = String;
	using RTCIceCandidateType = String;
	using RTCIceComponent = String;
	using RTCIceConnectionState = String;
	using RTCIceGathererState = String;
	using RTCIceGatheringState = String;
	using RTCIceProtocol = String;
	using RTCIceTcpCandidateType = String;
	using RTCIceTransportPolicy = String;
	using RTCIceTransportState = String;
	using RTCPeerConnectionState = String;
	using RTCPriorityType = String;
	using RTCRtcpMuxPolicy = String;
	using RTCRtpTransceiverDirection = String;
	using RTCSctpTransportState = String;
	using RTCSdpType = String;
	using RTCSignalingState = String;
	using RTCStatsIceCandidatePairState = String;
	using RTCStatsType = String;
	using ReadableStreamReaderMode = String;
	using ReadableStreamType = String;
	using ReadyState = String;
	using RecordingState = String;
	using ReferrerPolicy = String;
	using RemotePlaybackState = String;
	using RequestCache = String;
	using RequestCredentials = String;
	using RequestDestination = String;
	using RequestMode = String;
	using RequestRedirect = String;
	using ResidentKeyRequirement = String;
	using ResizeObserverBoxOptions = String;
	using ResizeQuality = String;
	using ResponseType = String;
	using ScrollBehavior = String;
	using ScrollLogicalPosition = String;
	using ScrollRestoration = String;
	using ScrollSetting = String;
	using SecurityPolicyViolationEventDisposition = String;
	using SelectionMode = String;
	using ServiceWorkerState = String;
	using ServiceWorkerUpdateViaCache = String;
	using ShadowRootMode = String;
	using SlotAssignmentMode = String;
	using SpeechSynthesisErrorCode = String;
	using TextTrackKind = String;
	using TextTrackMode = String;
	using TouchType = String;
	using TransferFunction = String;
	using UserVerificationRequirement = String;
	using VideoColorPrimaries = String;
	using VideoEncoderBitrateMode = String;
	using VideoFacingModeEnum = String;
	using VideoMatrixCoefficients = String;
	using VideoPixelFormat = String;
	using VideoTransferCharacteristics = String;
	using WakeLockType = String;
	using WebGLPowerPreference = String;
	using WebTransportCongestionControl = String;
	using WebTransportErrorSource = String;
	using WorkerType = String;
	using WriteCommandType = String;
	using XMLHttpRequestResponseType = String;
	class ExtendableEventInit: public EventInit {
	};
	class Client;
	class ExtendableMessageEventInit: public ExtendableEventInit {
	public:
		Object* get_data();
		void set_data(const _Any& data);
		String* get_lastEventId();
		void set_lastEventId(const String& lastEventId);
		String* get_origin();
		void set_origin(const String& origin);
		TArray<MessagePort*>* get_ports();
		void set_ports(TArray<MessagePort*>* ports);
		_Union<MessagePort*, ServiceWorker*, Client*>* get_source();
		void set_source(const _Union<MessagePort*, ServiceWorker*, Client*>& source);
	};
	class FetchEventInit: public ExtendableEventInit {
	public:
		String* get_clientId();
		void set_clientId(const String& clientId);
		Promise<_Any*>* get_handled();
		void set_handled(Promise<_Any*>* handled);
		Promise<_Any*>* get_preloadResponse();
		void set_preloadResponse(Promise<_Any*>* preloadResponse);
		String* get_replacesClientId();
		void set_replacesClientId(const String& replacesClientId);
		Request* get_request();
		void set_request(Request* request);
		String* get_resultingClientId();
		void set_resultingClientId(const String& resultingClientId);
	};
	class FileSystemReadWriteOptions: public Object {
	public:
		double get_at();
		void set_at(double at);
	};
	class NotificationEventInit: public ExtendableEventInit {
	public:
		String* get_action();
		void set_action(const String& action);
		Notification* get_notification();
		void set_notification(Notification* notification);
	};
	class PushEventInit: public ExtendableEventInit {
	public:
		_Union<String*, ArrayBuffer*, ArrayBufferView*>* get_data();
		void set_data(const String& data);
		void set_data(const _Union<ArrayBuffer*, ArrayBufferView*>& data);
	};
	class Client: public Object {
	public:
		String* get_frameType();
		String* get_id();
		String* get_type();
		String* get_url();
		void postMessage(const _Any& message, Array* transfer);
		void postMessage(const _Any& message);
		void postMessage(const _Any& message, StructuredSerializeOptions* options);
		static Client* prototype;
		Client();
	};
	class WindowClient;
	class Clients: public Object {
	public:
		Promise<_Any*>* claim();
		Promise<Client*>* get(const String& id);
		Promise<ReadonlyArray<Object*>*>* matchAll();
		Promise<ReadonlyArray<Object*>*>* matchAll(ClientQueryOptions* options);
		Promise<WindowClient*>* openWindow(const String& url);
		Promise<WindowClient*>* openWindow(URL* url);
		static Clients* prototype;
		Clients();
	};
	class WorkerGlobalScopeEventMap: public Object {
	public:
		[[cheerp::interface_name(("get_\"error\""))]]
		ErrorEvent* get__34_error_34_();
		[[cheerp::interface_name(("set_\"error\""))]]
		void set__34_error_34_(ErrorEvent* _34_error_34_);
		[[cheerp::interface_name(("get_\"languagechange\""))]]
		Event* get__34_languagechange_34_();
		[[cheerp::interface_name(("set_\"languagechange\""))]]
		void set__34_languagechange_34_(Event* _34_languagechange_34_);
		[[cheerp::interface_name(("get_\"offline\""))]]
		Event* get__34_offline_34_();
		[[cheerp::interface_name(("set_\"offline\""))]]
		void set__34_offline_34_(Event* _34_offline_34_);
		[[cheerp::interface_name(("get_\"online\""))]]
		Event* get__34_online_34_();
		[[cheerp::interface_name(("set_\"online\""))]]
		void set__34_online_34_(Event* _34_online_34_);
		[[cheerp::interface_name(("get_\"rejectionhandled\""))]]
		PromiseRejectionEvent* get__34_rejectionhandled_34_();
		[[cheerp::interface_name(("set_\"rejectionhandled\""))]]
		void set__34_rejectionhandled_34_(PromiseRejectionEvent* _34_rejectionhandled_34_);
		[[cheerp::interface_name(("get_\"unhandledrejection\""))]]
		PromiseRejectionEvent* get__34_unhandledrejection_34_();
		[[cheerp::interface_name(("set_\"unhandledrejection\""))]]
		void set__34_unhandledrejection_34_(PromiseRejectionEvent* _34_unhandledrejection_34_);
	};
	class DedicatedWorkerGlobalScopeEventMap: public WorkerGlobalScopeEventMap {
	public:
		[[cheerp::interface_name(("get_\"message\""))]]
		MessageEvent<_Any*>* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(MessageEvent<_Any*>* _34_message_34_);
		[[cheerp::interface_name(("get_\"messageerror\""))]]
		MessageEvent<_Any*>* get__34_messageerror_34_();
		[[cheerp::interface_name(("set_\"messageerror\""))]]
		void set__34_messageerror_34_(MessageEvent<_Any*>* _34_messageerror_34_);
	};
	class WorkerGlobalScope: public EventTarget, public FontFaceSource, public WindowOrWorkerGlobalScope {
	public:
		Object* eval(const String& x);
		double parseInt(const String& string);
		double parseInt(const String& string, double radix);
		double parseFloat(const String& string);
		bool isNaN(double number);
		bool isFinite(double number);
		String* decodeURI(const String& encodedURI);
		String* decodeURIComponent(const String& encodedURIComponent);
		String* encodeURI(const String& uri);
		String* encodeURIComponent(const String& uriComponent);
		String* encodeURIComponent(const _Union<double, bool>& uriComponent);
		String* escape(const String& string);
		String* unescape(const String& string);
		void alert();
		void alert(const _Any& message);
		void blur();
		void cancelIdleCallback(double handle);
		void captureEvents();
		void close();
		bool confirm();
		bool confirm(const String& message);
		void focus();
		CSSStyleDeclaration* getComputedStyle(Element* elt);
		CSSStyleDeclaration* getComputedStyle(Element* elt, const String& pseudoElt);
		Selection* getSelection();
		MediaQueryList* matchMedia(const String& query);
		void moveBy(double x, double y);
		void moveTo(double x, double y);
		Window* open();
		Window* open(const String& url);
		Window* open(URL* url);
		Window* open(const String& url, const String& target);
		Window* open(URL* url, const String& target);
		Window* open(const String& url, const String& target, const String& features);
		Window* open(URL* url, const String& target, const String& features);
		void postMessage(const _Any& message, const String& targetOrigin);
		void postMessage(const _Any& message, const String& targetOrigin, Array* transfer);
		void postMessage(const _Any& message);
		void postMessage(const _Any& message, WindowPostMessageOptions* options);
		void postMessage(const _Any& message, Array* transfer);
		void postMessage(const _Any& message, StructuredSerializeOptions* options);
		void print();
		String* prompt();
		String* prompt(const String& message);
		String* prompt(const String& message, const String& _default);
		void releaseEvents();
		double requestIdleCallback(EventListener* callback);
		double requestIdleCallback(const _Function<void(IdleDeadline*)>& callback);
		double requestIdleCallback(EventListener* callback, IdleRequestOptions* options);
		double requestIdleCallback(const _Function<void(IdleDeadline*)>& callback, IdleRequestOptions* options);
		void resizeBy(double x, double y);
		void resizeTo(double width, double height);
		void scroll();
		void scroll(ScrollToOptions* options);
		void scroll(double x, double y);
		void scrollBy();
		void scrollBy(ScrollToOptions* options);
		void scrollBy(double x, double y);
		void scrollTo();
		void scrollTo(ScrollToOptions* options);
		void scrollTo(double x, double y);
		void stop();
		String* toString();
		bool dispatchEvent(Event* event);
		void cancelAnimationFrame(double handle);
		double requestAnimationFrame(EventListener* callback);
		double requestAnimationFrame(const _Function<void(double)>& callback);
		String* atob(const String& data);
		String* btoa(const String& data);
		void clearInterval(double id);
		void clearTimeout(double id);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, ImageBitmapOptions* options);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh);
		Promise<ImageBitmap*>* createImageBitmap(const _Union<Blob*, HTMLCanvasElement*, HTMLImageElement*, HTMLVideoElement*, ImageBitmap*, ImageData*, OffscreenCanvas*, SVGImageElement*, VideoFrame*>& image, double sx, double sy, double sw, double sh, ImageBitmapOptions* options);
		Promise<Response*>* fetch(const String& input);
		Promise<Response*>* fetch(const _Union<Request*, URL*>& input);
		Promise<Response*>* fetch(const String& input, RequestInit* init);
		Promise<Response*>* fetch(const _Union<Request*, URL*>& input, RequestInit* init);
		void queueMicrotask(EventListener* callback);
		void queueMicrotask(const _Function<void()>& callback);
		void reportError(const _Any& e);
		double setInterval(const String& handler);
		double setInterval(const _Function<void()>& handler);
		double setInterval(Function* handler);
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(const String& handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(const _Function<void()>& handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setInterval(Function* handler, double timeout, _Args... arguments) {
			return _setInterval(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("setInterval"))]]
		_Any* _setInterval(_Args... data);
	public:
		double setTimeout(const String& handler);
		double setTimeout(const _Function<void()>& handler);
		double setTimeout(Function* handler);
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(const String& handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(const _Function<void()>& handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
		template<class... _Args>
		[[gnu::always_inline]]
		double setTimeout(Function* handler, double timeout, _Args... arguments) {
			return _setTimeout(cheerp::clientCast(handler), cheerp::clientCast(timeout), cheerp::clientCast(arguments)...)->template cast<double>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("setTimeout"))]]
		_Any* _setTimeout(_Args... data);
	public:
		template<class _T0 = _Any*>
		_T0 structuredClone(_T0 value);
		template<class _T0 = _Any*>
		_T0 structuredClone(_T0 value, StructuredSerializeOptions* options);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		WorkerLocation* get_location();
		WorkerNavigator* get_navigator();
		_Function<_Any*(ErrorEvent*)>* get_onerror();
		void set_onerror(EventListener* onerror);
		void set_onerror(const _Function<_Any*(ErrorEvent*)>& onerror);
		_Function<_Any*(Event*)>* get_onlanguagechange();
		void set_onlanguagechange(EventListener* onlanguagechange);
		void set_onlanguagechange(const _Function<_Any*(Event*)>& onlanguagechange);
		_Function<_Any*(Event*)>* get_onoffline();
		void set_onoffline(EventListener* onoffline);
		void set_onoffline(const _Function<_Any*(Event*)>& onoffline);
		_Function<_Any*(Event*)>* get_ononline();
		void set_ononline(EventListener* ononline);
		void set_ononline(const _Function<_Any*(Event*)>& ononline);
		_Function<_Any*(PromiseRejectionEvent*)>* get_onrejectionhandled();
		void set_onrejectionhandled(EventListener* onrejectionhandled);
		void set_onrejectionhandled(const _Function<_Any*(PromiseRejectionEvent*)>& onrejectionhandled);
		_Function<_Any*(PromiseRejectionEvent*)>* get_onunhandledrejection();
		void set_onunhandledrejection(EventListener* onunhandledrejection);
		void set_onunhandledrejection(const _Function<_Any*(PromiseRejectionEvent*)>& onunhandledrejection);
		WorkerGlobalScope* get_self();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, String*> && ...), void> importScripts(_Args... urls) {
			_importScripts(cheerp::clientCast(urls)...);
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("importScripts"))]]
		_Any* _importScripts(_Args... data);
	public:
		static WorkerGlobalScope* prototype;
		WorkerGlobalScope();
	};
	class DedicatedWorkerGlobalScope: public WorkerGlobalScope, public AnimationFrameProvider {
	public:
		String* get_name();
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessage);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessageerror();
		void set_onmessageerror(EventListener* onmessageerror);
		void set_onmessageerror(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessageerror);
		void close();
		void postMessage(const _Any& message, Array* transfer);
		void postMessage(const _Any& message);
		void postMessage(const _Any& message, StructuredSerializeOptions* options);
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static DedicatedWorkerGlobalScope* prototype;
		DedicatedWorkerGlobalScope();
	};
	class ExtendableEvent: public Event {
	public:
		void waitUntil(Promise<_Any*>* f);
		static ExtendableEvent* prototype;
		ExtendableEvent(const String& type);
		ExtendableEvent(const String& type, ExtendableEventInit* eventInitDict);
	};
	class ExtendableMessageEvent: public ExtendableEvent {
	public:
		Object* get_data();
		String* get_lastEventId();
		String* get_origin();
		ReadonlyArray<MessagePort*>* get_ports();
		_Union<MessagePort*, ServiceWorker*, Client*>* get_source();
		static ExtendableMessageEvent* prototype;
		ExtendableMessageEvent(const String& type);
		ExtendableMessageEvent(const String& type, ExtendableMessageEventInit* eventInitDict);
	};
	class FetchEvent: public ExtendableEvent {
	public:
		String* get_clientId();
		Promise<_Any*>* get_handled();
		Promise<_Any*>* get_preloadResponse();
		Request* get_request();
		String* get_resultingClientId();
		void respondWith(const _Union<Response*, PromiseLike<Response*>*>& r);
		static FetchEvent* prototype;
		FetchEvent(const String& type, FetchEventInit* eventInitDict);
	};
	class FileReaderSync: public Object {
	public:
		ArrayBuffer* readAsArrayBuffer(Blob* blob);
		String* readAsBinaryString(Blob* blob);
		String* readAsDataURL(Blob* blob);
		String* readAsText(Blob* blob);
		String* readAsText(Blob* blob, const String& encoding);
		static FileReaderSync* prototype;
		FileReaderSync();
	};
	class FileSystemSyncAccessHandle: public Object {
	public:
		void close();
		void flush();
		double getSize();
		double read(const _Union<ArrayBuffer*, ArrayBufferView*>& buffer);
		double read(const _Union<ArrayBuffer*, ArrayBufferView*>& buffer, FileSystemReadWriteOptions* options);
		void truncate(double newSize);
		double write(const _Union<ArrayBuffer*, ArrayBufferView*>& buffer);
		double write(const _Union<ArrayBuffer*, ArrayBufferView*>& buffer, FileSystemReadWriteOptions* options);
		static FileSystemSyncAccessHandle* prototype;
		FileSystemSyncAccessHandle();
	};
	class NotificationEvent: public ExtendableEvent {
	public:
		String* get_action();
		Notification* get_notification();
		static NotificationEvent* prototype;
		NotificationEvent(const String& type, NotificationEventInit* eventInitDict);
	};
	class PushMessageData;
	class PushEvent: public ExtendableEvent {
	public:
		PushMessageData* get_data();
		static PushEvent* prototype;
		PushEvent(const String& type);
		PushEvent(const String& type, PushEventInit* eventInitDict);
	};
	class PushMessageData: public Object {
	public:
		ArrayBuffer* arrayBuffer();
		Blob* blob();
		Object* json();
		String* text();
		static PushMessageData* prototype;
		PushMessageData();
	};
	class ServiceWorkerGlobalScopeEventMap: public WorkerGlobalScopeEventMap {
	public:
		[[cheerp::interface_name(("get_\"activate\""))]]
		ExtendableEvent* get__34_activate_34_();
		[[cheerp::interface_name(("set_\"activate\""))]]
		void set__34_activate_34_(ExtendableEvent* _34_activate_34_);
		[[cheerp::interface_name(("get_\"fetch\""))]]
		FetchEvent* get__34_fetch_34_();
		[[cheerp::interface_name(("set_\"fetch\""))]]
		void set__34_fetch_34_(FetchEvent* _34_fetch_34_);
		[[cheerp::interface_name(("get_\"install\""))]]
		ExtendableEvent* get__34_install_34_();
		[[cheerp::interface_name(("set_\"install\""))]]
		void set__34_install_34_(ExtendableEvent* _34_install_34_);
		[[cheerp::interface_name(("get_\"message\""))]]
		ExtendableMessageEvent* get__34_message_34_();
		[[cheerp::interface_name(("set_\"message\""))]]
		void set__34_message_34_(ExtendableMessageEvent* _34_message_34_);
		[[cheerp::interface_name(("get_\"messageerror\""))]]
		MessageEvent<_Any*>* get__34_messageerror_34_();
		[[cheerp::interface_name(("set_\"messageerror\""))]]
		void set__34_messageerror_34_(MessageEvent<_Any*>* _34_messageerror_34_);
		[[cheerp::interface_name(("get_\"notificationclick\""))]]
		NotificationEvent* get__34_notificationclick_34_();
		[[cheerp::interface_name(("set_\"notificationclick\""))]]
		void set__34_notificationclick_34_(NotificationEvent* _34_notificationclick_34_);
		[[cheerp::interface_name(("get_\"notificationclose\""))]]
		NotificationEvent* get__34_notificationclose_34_();
		[[cheerp::interface_name(("set_\"notificationclose\""))]]
		void set__34_notificationclose_34_(NotificationEvent* _34_notificationclose_34_);
		[[cheerp::interface_name(("get_\"push\""))]]
		PushEvent* get__34_push_34_();
		[[cheerp::interface_name(("set_\"push\""))]]
		void set__34_push_34_(PushEvent* _34_push_34_);
		[[cheerp::interface_name(("get_\"pushsubscriptionchange\""))]]
		Event* get__34_pushsubscriptionchange_34_();
		[[cheerp::interface_name(("set_\"pushsubscriptionchange\""))]]
		void set__34_pushsubscriptionchange_34_(Event* _34_pushsubscriptionchange_34_);
	};
	class ServiceWorkerGlobalScope: public WorkerGlobalScope {
	public:
		Clients* get_clients();
		_Function<_Any*(ExtendableEvent*)>* get_onactivate();
		void set_onactivate(EventListener* onactivate);
		void set_onactivate(const _Function<_Any*(ExtendableEvent*)>& onactivate);
		_Function<_Any*(FetchEvent*)>* get_onfetch();
		void set_onfetch(EventListener* onfetch);
		void set_onfetch(const _Function<_Any*(FetchEvent*)>& onfetch);
		_Function<_Any*(ExtendableEvent*)>* get_oninstall();
		void set_oninstall(EventListener* oninstall);
		void set_oninstall(const _Function<_Any*(ExtendableEvent*)>& oninstall);
		_Function<_Any*(ExtendableMessageEvent*)>* get_onmessage();
		void set_onmessage(EventListener* onmessage);
		void set_onmessage(const _Function<_Any*(ExtendableMessageEvent*)>& onmessage);
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onmessageerror();
		void set_onmessageerror(EventListener* onmessageerror);
		void set_onmessageerror(const _Function<_Any*(MessageEvent<_Any*>*)>& onmessageerror);
		_Function<_Any*(NotificationEvent*)>* get_onnotificationclick();
		void set_onnotificationclick(EventListener* onnotificationclick);
		void set_onnotificationclick(const _Function<_Any*(NotificationEvent*)>& onnotificationclick);
		_Function<_Any*(NotificationEvent*)>* get_onnotificationclose();
		void set_onnotificationclose(EventListener* onnotificationclose);
		void set_onnotificationclose(const _Function<_Any*(NotificationEvent*)>& onnotificationclose);
		_Function<_Any*(PushEvent*)>* get_onpush();
		void set_onpush(EventListener* onpush);
		void set_onpush(const _Function<_Any*(PushEvent*)>& onpush);
		_Function<_Any*(Event*)>* get_onpushsubscriptionchange();
		void set_onpushsubscriptionchange(EventListener* onpushsubscriptionchange);
		void set_onpushsubscriptionchange(const _Function<_Any*(Event*)>& onpushsubscriptionchange);
		ServiceWorkerRegistration* get_registration();
		ServiceWorker* get_serviceWorker();
		Promise<_Any*>* skipWaiting();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static ServiceWorkerGlobalScope* prototype;
		ServiceWorkerGlobalScope();
	};
	class SharedWorkerGlobalScopeEventMap: public WorkerGlobalScopeEventMap {
	public:
		[[cheerp::interface_name(("get_\"connect\""))]]
		MessageEvent<_Any*>* get__34_connect_34_();
		[[cheerp::interface_name(("set_\"connect\""))]]
		void set__34_connect_34_(MessageEvent<_Any*>* _34_connect_34_);
	};
	class SharedWorkerGlobalScope: public WorkerGlobalScope {
	public:
		String* get_name();
		_Function<_Any*(MessageEvent<_Any*>*)>* get_onconnect();
		void set_onconnect(EventListener* onconnect);
		void set_onconnect(const _Function<_Any*(MessageEvent<_Any*>*)>& onconnect);
		void close();
		void addEventListener(const String& type, EventListener* listener);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void addEventListener(const String& type, EventListener* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, AddEventListenerOptions*>& options);
		void addEventListener(const String& type, EventListenerObject* listener);
		void addEventListener(const String& type, EventListenerObject* listener, const _Union<bool, AddEventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListener* listener);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener);
		void removeEventListener(const String& type, EventListener* listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, const _Function<_Any*(_Union<Object*, Event*>*)>& listener, const _Union<bool, EventListenerOptions*>& options);
		void removeEventListener(const String& type, EventListenerObject* listener);
		void removeEventListener(const String& type, EventListenerObject* listener, const _Union<bool, EventListenerOptions*>& options);
		static SharedWorkerGlobalScope* prototype;
		SharedWorkerGlobalScope();
	};
	class WindowClient: public Client {
	public:
		bool get_focused();
		String* get_visibilityState();
		Promise<WindowClient*>* focus();
		Promise<WindowClient*>* navigate(const String& url);
		Promise<WindowClient*>* navigate(URL* url);
		static WindowClient* prototype;
		WindowClient();
	};
	class WorkerLocation: public Object {
	public:
		String* get_hash();
		String* get_host();
		String* get_hostname();
		String* get_href();
		String* toString();
		String* get_origin();
		String* get_pathname();
		String* get_port();
		String* get_protocol();
		String* get_search();
		static WorkerLocation* prototype;
		WorkerLocation();
	};
	class WorkerNavigator: public NavigatorBadge, public NavigatorConcurrentHardware, public NavigatorID, public NavigatorLanguage, public NavigatorLocks, public NavigatorOnLine, public NavigatorStorage {
	public:
		MediaCapabilities* get_mediaCapabilities();
		Permissions* get_permissions();
		static WorkerNavigator* prototype;
		WorkerNavigator();
	};
	template<class... _Args>
	cheerp::EnableIf<(cheerp::CanCastArgs<_Args, String*> && ...), void> importScripts(_Args... urls);
	extern FontFaceSet fonts;
	using PushMessageDataInit = _Any;
	using FrameType = String;
	class ActiveXObjectClass;
	extern ActiveXObjectClass ActiveXObject;
	class ActiveXObjectClass: public Object {
	};
	class ITextWriter: public Object {
	public:
		void Write(const String& s);
		void WriteLine(const String& s);
		void Close();
	};
	class TextStreamBase: public Object {
	public:
		double get_Column();
		void set_Column(double Column);
		double get_Line();
		void set_Line(double Line);
		void Close();
	};
	class TextStreamWriter: public TextStreamBase {
	public:
		void Write(const String& s);
		void WriteBlankLines(double intLines);
		void WriteLine(const String& s);
	};
	class TextStreamReader: public TextStreamBase {
	public:
		String* Read(double characters);
		String* ReadAll();
		String* ReadLine();
		void Skip(double characters);
		void SkipLine();
		bool get_AtEndOfLine();
		void set_AtEndOfLine(bool AtEndOfLine);
		bool get_AtEndOfStream();
		void set_AtEndOfStream(bool AtEndOfStream);
	};
	extern Object WScript;
	extern Object WSH;
	template<class _T0>
	class SafeArray: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		SafeArray();
		SafeArray<_T0>* get_SafeArray_typekey();
		void set_SafeArray_typekey(SafeArray<_T0>* SafeArray_typekey);
	};
	template<class _T0>
	class Enumerator: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		bool atEnd();
		_T0 item();
		void moveFirst();
		void moveNext();
		template<class _T1 = _Any*>
		Enumerator(SafeArray<_T1>* safearray);
		Enumerator(Object* collection);
		Enumerator(const _Any& collection);
	};
	class EnumeratorConstructor: public Object {
	};
	template<class _T0>
	class VBArray: public Object {
		static_assert(cheerp::CheckTemplate<_T0>);
	public:
		double dimensions();
		template<class... _Args>
		[[gnu::always_inline]]
		cheerp::EnableIf<(cheerp::CanCastArgs<_Args, double> && ...), _T0> getItem(double dimension1Index, _Args... dimensionNIndexes) {
			return _getItem(cheerp::clientCast(dimension1Index), cheerp::clientCast(dimensionNIndexes)...)->template cast<_T0>();
		}
	private:
		template<class... _Args>
		[[cheerp::interface_name(("getItem"))]]
		_Any* _getItem(_Args... data);
	public:
		double lbound();
		double lbound(double dimension);
		double ubound();
		double ubound(double dimension);
		TArray<_T0>* toArray();
		template<class _T1 = _Any*>
		VBArray(SafeArray<_T1>* safeArray);
	};
	class VBArrayConstructor: public Object {
	};
	class VarDate: public Object {
	public:
		VarDate();
		VarDate* get_VarDate_typekey();
		void set_VarDate_typekey(VarDate* VarDate_typekey);
	};
	extern URL URL;
}
#endif
